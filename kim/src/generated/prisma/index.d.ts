
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model QRTZ_BLOB_TRIGGERS
 * 
 */
export type QRTZ_BLOB_TRIGGERS = $Result.DefaultSelection<Prisma.$QRTZ_BLOB_TRIGGERSPayload>
/**
 * Model QRTZ_CALENDARS
 * 
 */
export type QRTZ_CALENDARS = $Result.DefaultSelection<Prisma.$QRTZ_CALENDARSPayload>
/**
 * Model QRTZ_CRON_TRIGGERS
 * 
 */
export type QRTZ_CRON_TRIGGERS = $Result.DefaultSelection<Prisma.$QRTZ_CRON_TRIGGERSPayload>
/**
 * Model QRTZ_FIRED_TRIGGERS
 * 
 */
export type QRTZ_FIRED_TRIGGERS = $Result.DefaultSelection<Prisma.$QRTZ_FIRED_TRIGGERSPayload>
/**
 * Model QRTZ_JOB_DETAILS
 * 
 */
export type QRTZ_JOB_DETAILS = $Result.DefaultSelection<Prisma.$QRTZ_JOB_DETAILSPayload>
/**
 * Model QRTZ_LOCKS
 * 
 */
export type QRTZ_LOCKS = $Result.DefaultSelection<Prisma.$QRTZ_LOCKSPayload>
/**
 * Model QRTZ_PAUSED_TRIGGER_GRPS
 * 
 */
export type QRTZ_PAUSED_TRIGGER_GRPS = $Result.DefaultSelection<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload>
/**
 * Model QRTZ_SCHEDULER_STATE
 * 
 */
export type QRTZ_SCHEDULER_STATE = $Result.DefaultSelection<Prisma.$QRTZ_SCHEDULER_STATEPayload>
/**
 * Model QRTZ_SIMPLE_TRIGGERS
 * 
 */
export type QRTZ_SIMPLE_TRIGGERS = $Result.DefaultSelection<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload>
/**
 * Model QRTZ_SIMPROP_TRIGGERS
 * 
 */
export type QRTZ_SIMPROP_TRIGGERS = $Result.DefaultSelection<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload>
/**
 * Model QRTZ_TRIGGERS
 * 
 */
export type QRTZ_TRIGGERS = $Result.DefaultSelection<Prisma.$QRTZ_TRIGGERSPayload>
/**
 * Model bag
 * 
 */
export type bag = $Result.DefaultSelection<Prisma.$bagPayload>
/**
 * Model ban_word
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type ban_word = $Result.DefaultSelection<Prisma.$ban_wordPayload>
/**
 * Model flyway_schema_history
 * 
 */
export type flyway_schema_history = $Result.DefaultSelection<Prisma.$flyway_schema_historyPayload>
/**
 * Model follow
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type follow = $Result.DefaultSelection<Prisma.$followPayload>
/**
 * Model hashtag
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type hashtag = $Result.DefaultSelection<Prisma.$hashtagPayload>
/**
 * Model hobby
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type hobby = $Result.DefaultSelection<Prisma.$hobbyPayload>
/**
 * Model hobby_category
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type hobby_category = $Result.DefaultSelection<Prisma.$hobby_categoryPayload>
/**
 * Model hobby_comment
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type hobby_comment = $Result.DefaultSelection<Prisma.$hobby_commentPayload>
/**
 * Model hobby_group
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type hobby_group = $Result.DefaultSelection<Prisma.$hobby_groupPayload>
/**
 * Model hobby_like
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type hobby_like = $Result.DefaultSelection<Prisma.$hobby_likePayload>
/**
 * Model hobby_photo
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type hobby_photo = $Result.DefaultSelection<Prisma.$hobby_photoPayload>
/**
 * Model hobby_post
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type hobby_post = $Result.DefaultSelection<Prisma.$hobby_postPayload>
/**
 * Model hobby_sub_comment
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type hobby_sub_comment = $Result.DefaultSelection<Prisma.$hobby_sub_commentPayload>
/**
 * Model hobby_top_ten
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type hobby_top_ten = $Result.DefaultSelection<Prisma.$hobby_top_tenPayload>
/**
 * Model hobby_view_history
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type hobby_view_history = $Result.DefaultSelection<Prisma.$hobby_view_historyPayload>
/**
 * Model item
 * 
 */
export type item = $Result.DefaultSelection<Prisma.$itemPayload>
/**
 * Model member
 * 
 */
export type member = $Result.DefaultSelection<Prisma.$memberPayload>
/**
 * Model policy_agree
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type policy_agree = $Result.DefaultSelection<Prisma.$policy_agreePayload>
/**
 * Model policy_history
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type policy_history = $Result.DefaultSelection<Prisma.$policy_historyPayload>
/**
 * Model post_hashtag
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type post_hashtag = $Result.DefaultSelection<Prisma.$post_hashtagPayload>
/**
 * Model recommended_feed
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type recommended_feed = $Result.DefaultSelection<Prisma.$recommended_feedPayload>
/**
 * Model report
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type report = $Result.DefaultSelection<Prisma.$reportPayload>
/**
 * Model setting
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type setting = $Result.DefaultSelection<Prisma.$settingPayload>
/**
 * Model today_hobby
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type today_hobby = $Result.DefaultSelection<Prisma.$today_hobbyPayload>
/**
 * Model user
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model user_metrics
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type user_metrics = $Result.DefaultSelection<Prisma.$user_metricsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const hobby_category_hobby_category_name: {
  cooking: 'cooking',
  exercise: 'exercise'
};

export type hobby_category_hobby_category_name = (typeof hobby_category_hobby_category_name)[keyof typeof hobby_category_hobby_category_name]


export const policy_agree_policy_type: {
  REQUIRED_IS_OVER_FOURTEEN: 'REQUIRED_IS_OVER_FOURTEEN',
  REQUIRED_TERMS_OF_SERVICE: 'REQUIRED_TERMS_OF_SERVICE',
  REQUIRED_PERSONAL_INFO_PROCESS: 'REQUIRED_PERSONAL_INFO_PROCESS',
  OPTION_PERSONAL_INFO_MARKETING: 'OPTION_PERSONAL_INFO_MARKETING',
  OPTION_EVENT_MAIL_OR_SMS: 'OPTION_EVENT_MAIL_OR_SMS'
};

export type policy_agree_policy_type = (typeof policy_agree_policy_type)[keyof typeof policy_agree_policy_type]


export const policy_history_policy_type: {
  REQUIRED_IS_OVER_FOURTEEN: 'REQUIRED_IS_OVER_FOURTEEN',
  REQUIRED_TERMS_OF_SERVICE: 'REQUIRED_TERMS_OF_SERVICE',
  REQUIRED_PERSONAL_INFO_PROCESS: 'REQUIRED_PERSONAL_INFO_PROCESS',
  OPTION_PERSONAL_INFO_MARKETING: 'OPTION_PERSONAL_INFO_MARKETING',
  OPTION_EVENT_MAIL_OR_SMS: 'OPTION_EVENT_MAIL_OR_SMS'
};

export type policy_history_policy_type = (typeof policy_history_policy_type)[keyof typeof policy_history_policy_type]


export const recommended_feed_recommended_type: {
  INFLUENCE: 'INFLUENCE',
  POPULAR_POST: 'POPULAR_POST'
};

export type recommended_feed_recommended_type = (typeof recommended_feed_recommended_type)[keyof typeof recommended_feed_recommended_type]


export const hobby_top_ten_category: {
  cooking: 'cooking',
  exercise: 'exercise'
};

export type hobby_top_ten_category = (typeof hobby_top_ten_category)[keyof typeof hobby_top_ten_category]


export const hobby_view_history_category: {
  cooking: 'cooking',
  exercise: 'exercise'
};

export type hobby_view_history_category = (typeof hobby_view_history_category)[keyof typeof hobby_view_history_category]


export const user_user_type: {
  ADMIN: 'ADMIN',
  BASIC_USER: 'BASIC_USER'
};

export type user_user_type = (typeof user_user_type)[keyof typeof user_user_type]


export const report_report_status: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED'
};

export type report_report_status = (typeof report_report_status)[keyof typeof report_report_status]


export const user_provider_type: {
  KAKAO: 'KAKAO',
  NAVER: 'NAVER',
  GOOGLE: 'GOOGLE',
  ORIGIN: 'ORIGIN'
};

export type user_provider_type = (typeof user_provider_type)[keyof typeof user_provider_type]

}

export type hobby_category_hobby_category_name = $Enums.hobby_category_hobby_category_name

export const hobby_category_hobby_category_name: typeof $Enums.hobby_category_hobby_category_name

export type policy_agree_policy_type = $Enums.policy_agree_policy_type

export const policy_agree_policy_type: typeof $Enums.policy_agree_policy_type

export type policy_history_policy_type = $Enums.policy_history_policy_type

export const policy_history_policy_type: typeof $Enums.policy_history_policy_type

export type recommended_feed_recommended_type = $Enums.recommended_feed_recommended_type

export const recommended_feed_recommended_type: typeof $Enums.recommended_feed_recommended_type

export type hobby_top_ten_category = $Enums.hobby_top_ten_category

export const hobby_top_ten_category: typeof $Enums.hobby_top_ten_category

export type hobby_view_history_category = $Enums.hobby_view_history_category

export const hobby_view_history_category: typeof $Enums.hobby_view_history_category

export type user_user_type = $Enums.user_user_type

export const user_user_type: typeof $Enums.user_user_type

export type report_report_status = $Enums.report_report_status

export const report_report_status: typeof $Enums.report_report_status

export type user_provider_type = $Enums.user_provider_type

export const user_provider_type: typeof $Enums.user_provider_type

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more QRTZ_BLOB_TRIGGERS
 * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more QRTZ_BLOB_TRIGGERS
   * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.qRTZ_BLOB_TRIGGERS`: Exposes CRUD operations for the **QRTZ_BLOB_TRIGGERS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRTZ_BLOB_TRIGGERS
    * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.findMany()
    * ```
    */
  get qRTZ_BLOB_TRIGGERS(): Prisma.QRTZ_BLOB_TRIGGERSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRTZ_CALENDARS`: Exposes CRUD operations for the **QRTZ_CALENDARS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRTZ_CALENDARS
    * const qRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.findMany()
    * ```
    */
  get qRTZ_CALENDARS(): Prisma.QRTZ_CALENDARSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRTZ_CRON_TRIGGERS`: Exposes CRUD operations for the **QRTZ_CRON_TRIGGERS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRTZ_CRON_TRIGGERS
    * const qRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.findMany()
    * ```
    */
  get qRTZ_CRON_TRIGGERS(): Prisma.QRTZ_CRON_TRIGGERSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRTZ_FIRED_TRIGGERS`: Exposes CRUD operations for the **QRTZ_FIRED_TRIGGERS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRTZ_FIRED_TRIGGERS
    * const qRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.findMany()
    * ```
    */
  get qRTZ_FIRED_TRIGGERS(): Prisma.QRTZ_FIRED_TRIGGERSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRTZ_JOB_DETAILS`: Exposes CRUD operations for the **QRTZ_JOB_DETAILS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRTZ_JOB_DETAILS
    * const qRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.findMany()
    * ```
    */
  get qRTZ_JOB_DETAILS(): Prisma.QRTZ_JOB_DETAILSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRTZ_LOCKS`: Exposes CRUD operations for the **QRTZ_LOCKS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRTZ_LOCKS
    * const qRTZ_LOCKS = await prisma.qRTZ_LOCKS.findMany()
    * ```
    */
  get qRTZ_LOCKS(): Prisma.QRTZ_LOCKSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRTZ_PAUSED_TRIGGER_GRPS`: Exposes CRUD operations for the **QRTZ_PAUSED_TRIGGER_GRPS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRTZ_PAUSED_TRIGGER_GRPS
    * const qRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.findMany()
    * ```
    */
  get qRTZ_PAUSED_TRIGGER_GRPS(): Prisma.QRTZ_PAUSED_TRIGGER_GRPSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRTZ_SCHEDULER_STATE`: Exposes CRUD operations for the **QRTZ_SCHEDULER_STATE** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRTZ_SCHEDULER_STATES
    * const qRTZ_SCHEDULER_STATES = await prisma.qRTZ_SCHEDULER_STATE.findMany()
    * ```
    */
  get qRTZ_SCHEDULER_STATE(): Prisma.QRTZ_SCHEDULER_STATEDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRTZ_SIMPLE_TRIGGERS`: Exposes CRUD operations for the **QRTZ_SIMPLE_TRIGGERS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRTZ_SIMPLE_TRIGGERS
    * const qRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.findMany()
    * ```
    */
  get qRTZ_SIMPLE_TRIGGERS(): Prisma.QRTZ_SIMPLE_TRIGGERSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRTZ_SIMPROP_TRIGGERS`: Exposes CRUD operations for the **QRTZ_SIMPROP_TRIGGERS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRTZ_SIMPROP_TRIGGERS
    * const qRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.findMany()
    * ```
    */
  get qRTZ_SIMPROP_TRIGGERS(): Prisma.QRTZ_SIMPROP_TRIGGERSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRTZ_TRIGGERS`: Exposes CRUD operations for the **QRTZ_TRIGGERS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRTZ_TRIGGERS
    * const qRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.findMany()
    * ```
    */
  get qRTZ_TRIGGERS(): Prisma.QRTZ_TRIGGERSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bag`: Exposes CRUD operations for the **bag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bags
    * const bags = await prisma.bag.findMany()
    * ```
    */
  get bag(): Prisma.bagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ban_word`: Exposes CRUD operations for the **ban_word** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ban_words
    * const ban_words = await prisma.ban_word.findMany()
    * ```
    */
  get ban_word(): Prisma.ban_wordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flyway_schema_history`: Exposes CRUD operations for the **flyway_schema_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flyway_schema_histories
    * const flyway_schema_histories = await prisma.flyway_schema_history.findMany()
    * ```
    */
  get flyway_schema_history(): Prisma.flyway_schema_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.followDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hashtag`: Exposes CRUD operations for the **hashtag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hashtags
    * const hashtags = await prisma.hashtag.findMany()
    * ```
    */
  get hashtag(): Prisma.hashtagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hobby`: Exposes CRUD operations for the **hobby** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hobbies
    * const hobbies = await prisma.hobby.findMany()
    * ```
    */
  get hobby(): Prisma.hobbyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hobby_category`: Exposes CRUD operations for the **hobby_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hobby_categories
    * const hobby_categories = await prisma.hobby_category.findMany()
    * ```
    */
  get hobby_category(): Prisma.hobby_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hobby_comment`: Exposes CRUD operations for the **hobby_comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hobby_comments
    * const hobby_comments = await prisma.hobby_comment.findMany()
    * ```
    */
  get hobby_comment(): Prisma.hobby_commentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hobby_group`: Exposes CRUD operations for the **hobby_group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hobby_groups
    * const hobby_groups = await prisma.hobby_group.findMany()
    * ```
    */
  get hobby_group(): Prisma.hobby_groupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hobby_like`: Exposes CRUD operations for the **hobby_like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hobby_likes
    * const hobby_likes = await prisma.hobby_like.findMany()
    * ```
    */
  get hobby_like(): Prisma.hobby_likeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hobby_photo`: Exposes CRUD operations for the **hobby_photo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hobby_photos
    * const hobby_photos = await prisma.hobby_photo.findMany()
    * ```
    */
  get hobby_photo(): Prisma.hobby_photoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hobby_post`: Exposes CRUD operations for the **hobby_post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hobby_posts
    * const hobby_posts = await prisma.hobby_post.findMany()
    * ```
    */
  get hobby_post(): Prisma.hobby_postDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hobby_sub_comment`: Exposes CRUD operations for the **hobby_sub_comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hobby_sub_comments
    * const hobby_sub_comments = await prisma.hobby_sub_comment.findMany()
    * ```
    */
  get hobby_sub_comment(): Prisma.hobby_sub_commentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hobby_top_ten`: Exposes CRUD operations for the **hobby_top_ten** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hobby_top_tens
    * const hobby_top_tens = await prisma.hobby_top_ten.findMany()
    * ```
    */
  get hobby_top_ten(): Prisma.hobby_top_tenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hobby_view_history`: Exposes CRUD operations for the **hobby_view_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hobby_view_histories
    * const hobby_view_histories = await prisma.hobby_view_history.findMany()
    * ```
    */
  get hobby_view_history(): Prisma.hobby_view_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.itemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.memberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.policy_agree`: Exposes CRUD operations for the **policy_agree** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policy_agrees
    * const policy_agrees = await prisma.policy_agree.findMany()
    * ```
    */
  get policy_agree(): Prisma.policy_agreeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.policy_history`: Exposes CRUD operations for the **policy_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policy_histories
    * const policy_histories = await prisma.policy_history.findMany()
    * ```
    */
  get policy_history(): Prisma.policy_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post_hashtag`: Exposes CRUD operations for the **post_hashtag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Post_hashtags
    * const post_hashtags = await prisma.post_hashtag.findMany()
    * ```
    */
  get post_hashtag(): Prisma.post_hashtagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recommended_feed`: Exposes CRUD operations for the **recommended_feed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recommended_feeds
    * const recommended_feeds = await prisma.recommended_feed.findMany()
    * ```
    */
  get recommended_feed(): Prisma.recommended_feedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.reportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.settingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.today_hobby`: Exposes CRUD operations for the **today_hobby** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Today_hobbies
    * const today_hobbies = await prisma.today_hobby.findMany()
    * ```
    */
  get today_hobby(): Prisma.today_hobbyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_metrics`: Exposes CRUD operations for the **user_metrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_metrics
    * const user_metrics = await prisma.user_metrics.findMany()
    * ```
    */
  get user_metrics(): Prisma.user_metricsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    QRTZ_BLOB_TRIGGERS: 'QRTZ_BLOB_TRIGGERS',
    QRTZ_CALENDARS: 'QRTZ_CALENDARS',
    QRTZ_CRON_TRIGGERS: 'QRTZ_CRON_TRIGGERS',
    QRTZ_FIRED_TRIGGERS: 'QRTZ_FIRED_TRIGGERS',
    QRTZ_JOB_DETAILS: 'QRTZ_JOB_DETAILS',
    QRTZ_LOCKS: 'QRTZ_LOCKS',
    QRTZ_PAUSED_TRIGGER_GRPS: 'QRTZ_PAUSED_TRIGGER_GRPS',
    QRTZ_SCHEDULER_STATE: 'QRTZ_SCHEDULER_STATE',
    QRTZ_SIMPLE_TRIGGERS: 'QRTZ_SIMPLE_TRIGGERS',
    QRTZ_SIMPROP_TRIGGERS: 'QRTZ_SIMPROP_TRIGGERS',
    QRTZ_TRIGGERS: 'QRTZ_TRIGGERS',
    bag: 'bag',
    ban_word: 'ban_word',
    flyway_schema_history: 'flyway_schema_history',
    follow: 'follow',
    hashtag: 'hashtag',
    hobby: 'hobby',
    hobby_category: 'hobby_category',
    hobby_comment: 'hobby_comment',
    hobby_group: 'hobby_group',
    hobby_like: 'hobby_like',
    hobby_photo: 'hobby_photo',
    hobby_post: 'hobby_post',
    hobby_sub_comment: 'hobby_sub_comment',
    hobby_top_ten: 'hobby_top_ten',
    hobby_view_history: 'hobby_view_history',
    item: 'item',
    member: 'member',
    policy_agree: 'policy_agree',
    policy_history: 'policy_history',
    post_hashtag: 'post_hashtag',
    recommended_feed: 'recommended_feed',
    report: 'report',
    setting: 'setting',
    today_hobby: 'today_hobby',
    user: 'user',
    user_metrics: 'user_metrics'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "qRTZ_BLOB_TRIGGERS" | "qRTZ_CALENDARS" | "qRTZ_CRON_TRIGGERS" | "qRTZ_FIRED_TRIGGERS" | "qRTZ_JOB_DETAILS" | "qRTZ_LOCKS" | "qRTZ_PAUSED_TRIGGER_GRPS" | "qRTZ_SCHEDULER_STATE" | "qRTZ_SIMPLE_TRIGGERS" | "qRTZ_SIMPROP_TRIGGERS" | "qRTZ_TRIGGERS" | "bag" | "ban_word" | "flyway_schema_history" | "follow" | "hashtag" | "hobby" | "hobby_category" | "hobby_comment" | "hobby_group" | "hobby_like" | "hobby_photo" | "hobby_post" | "hobby_sub_comment" | "hobby_top_ten" | "hobby_view_history" | "item" | "member" | "policy_agree" | "policy_history" | "post_hashtag" | "recommended_feed" | "report" | "setting" | "today_hobby" | "user" | "user_metrics"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      QRTZ_BLOB_TRIGGERS: {
        payload: Prisma.$QRTZ_BLOB_TRIGGERSPayload<ExtArgs>
        fields: Prisma.QRTZ_BLOB_TRIGGERSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRTZ_BLOB_TRIGGERSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRTZ_BLOB_TRIGGERSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload>
          }
          findFirst: {
            args: Prisma.QRTZ_BLOB_TRIGGERSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRTZ_BLOB_TRIGGERSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload>
          }
          findMany: {
            args: Prisma.QRTZ_BLOB_TRIGGERSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload>[]
          }
          create: {
            args: Prisma.QRTZ_BLOB_TRIGGERSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload>
          }
          createMany: {
            args: Prisma.QRTZ_BLOB_TRIGGERSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QRTZ_BLOB_TRIGGERSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload>
          }
          update: {
            args: Prisma.QRTZ_BLOB_TRIGGERSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload>
          }
          deleteMany: {
            args: Prisma.QRTZ_BLOB_TRIGGERSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRTZ_BLOB_TRIGGERSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QRTZ_BLOB_TRIGGERSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload>
          }
          aggregate: {
            args: Prisma.QRTZ_BLOB_TRIGGERSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRTZ_BLOB_TRIGGERS>
          }
          groupBy: {
            args: Prisma.QRTZ_BLOB_TRIGGERSGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_BLOB_TRIGGERSGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRTZ_BLOB_TRIGGERSCountArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_BLOB_TRIGGERSCountAggregateOutputType> | number
          }
        }
      }
      QRTZ_CALENDARS: {
        payload: Prisma.$QRTZ_CALENDARSPayload<ExtArgs>
        fields: Prisma.QRTZ_CALENDARSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRTZ_CALENDARSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CALENDARSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRTZ_CALENDARSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CALENDARSPayload>
          }
          findFirst: {
            args: Prisma.QRTZ_CALENDARSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CALENDARSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRTZ_CALENDARSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CALENDARSPayload>
          }
          findMany: {
            args: Prisma.QRTZ_CALENDARSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CALENDARSPayload>[]
          }
          create: {
            args: Prisma.QRTZ_CALENDARSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CALENDARSPayload>
          }
          createMany: {
            args: Prisma.QRTZ_CALENDARSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QRTZ_CALENDARSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CALENDARSPayload>
          }
          update: {
            args: Prisma.QRTZ_CALENDARSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CALENDARSPayload>
          }
          deleteMany: {
            args: Prisma.QRTZ_CALENDARSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRTZ_CALENDARSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QRTZ_CALENDARSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CALENDARSPayload>
          }
          aggregate: {
            args: Prisma.QRTZ_CALENDARSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRTZ_CALENDARS>
          }
          groupBy: {
            args: Prisma.QRTZ_CALENDARSGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_CALENDARSGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRTZ_CALENDARSCountArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_CALENDARSCountAggregateOutputType> | number
          }
        }
      }
      QRTZ_CRON_TRIGGERS: {
        payload: Prisma.$QRTZ_CRON_TRIGGERSPayload<ExtArgs>
        fields: Prisma.QRTZ_CRON_TRIGGERSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRTZ_CRON_TRIGGERSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CRON_TRIGGERSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRTZ_CRON_TRIGGERSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CRON_TRIGGERSPayload>
          }
          findFirst: {
            args: Prisma.QRTZ_CRON_TRIGGERSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CRON_TRIGGERSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRTZ_CRON_TRIGGERSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CRON_TRIGGERSPayload>
          }
          findMany: {
            args: Prisma.QRTZ_CRON_TRIGGERSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CRON_TRIGGERSPayload>[]
          }
          create: {
            args: Prisma.QRTZ_CRON_TRIGGERSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CRON_TRIGGERSPayload>
          }
          createMany: {
            args: Prisma.QRTZ_CRON_TRIGGERSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QRTZ_CRON_TRIGGERSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CRON_TRIGGERSPayload>
          }
          update: {
            args: Prisma.QRTZ_CRON_TRIGGERSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CRON_TRIGGERSPayload>
          }
          deleteMany: {
            args: Prisma.QRTZ_CRON_TRIGGERSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRTZ_CRON_TRIGGERSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QRTZ_CRON_TRIGGERSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_CRON_TRIGGERSPayload>
          }
          aggregate: {
            args: Prisma.QRTZ_CRON_TRIGGERSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRTZ_CRON_TRIGGERS>
          }
          groupBy: {
            args: Prisma.QRTZ_CRON_TRIGGERSGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_CRON_TRIGGERSGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRTZ_CRON_TRIGGERSCountArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_CRON_TRIGGERSCountAggregateOutputType> | number
          }
        }
      }
      QRTZ_FIRED_TRIGGERS: {
        payload: Prisma.$QRTZ_FIRED_TRIGGERSPayload<ExtArgs>
        fields: Prisma.QRTZ_FIRED_TRIGGERSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRTZ_FIRED_TRIGGERSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRTZ_FIRED_TRIGGERSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload>
          }
          findFirst: {
            args: Prisma.QRTZ_FIRED_TRIGGERSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRTZ_FIRED_TRIGGERSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload>
          }
          findMany: {
            args: Prisma.QRTZ_FIRED_TRIGGERSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload>[]
          }
          create: {
            args: Prisma.QRTZ_FIRED_TRIGGERSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload>
          }
          createMany: {
            args: Prisma.QRTZ_FIRED_TRIGGERSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QRTZ_FIRED_TRIGGERSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload>
          }
          update: {
            args: Prisma.QRTZ_FIRED_TRIGGERSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload>
          }
          deleteMany: {
            args: Prisma.QRTZ_FIRED_TRIGGERSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRTZ_FIRED_TRIGGERSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QRTZ_FIRED_TRIGGERSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload>
          }
          aggregate: {
            args: Prisma.QRTZ_FIRED_TRIGGERSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRTZ_FIRED_TRIGGERS>
          }
          groupBy: {
            args: Prisma.QRTZ_FIRED_TRIGGERSGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_FIRED_TRIGGERSGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRTZ_FIRED_TRIGGERSCountArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_FIRED_TRIGGERSCountAggregateOutputType> | number
          }
        }
      }
      QRTZ_JOB_DETAILS: {
        payload: Prisma.$QRTZ_JOB_DETAILSPayload<ExtArgs>
        fields: Prisma.QRTZ_JOB_DETAILSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRTZ_JOB_DETAILSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_JOB_DETAILSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRTZ_JOB_DETAILSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_JOB_DETAILSPayload>
          }
          findFirst: {
            args: Prisma.QRTZ_JOB_DETAILSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_JOB_DETAILSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRTZ_JOB_DETAILSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_JOB_DETAILSPayload>
          }
          findMany: {
            args: Prisma.QRTZ_JOB_DETAILSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_JOB_DETAILSPayload>[]
          }
          create: {
            args: Prisma.QRTZ_JOB_DETAILSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_JOB_DETAILSPayload>
          }
          createMany: {
            args: Prisma.QRTZ_JOB_DETAILSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QRTZ_JOB_DETAILSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_JOB_DETAILSPayload>
          }
          update: {
            args: Prisma.QRTZ_JOB_DETAILSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_JOB_DETAILSPayload>
          }
          deleteMany: {
            args: Prisma.QRTZ_JOB_DETAILSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRTZ_JOB_DETAILSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QRTZ_JOB_DETAILSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_JOB_DETAILSPayload>
          }
          aggregate: {
            args: Prisma.QRTZ_JOB_DETAILSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRTZ_JOB_DETAILS>
          }
          groupBy: {
            args: Prisma.QRTZ_JOB_DETAILSGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_JOB_DETAILSGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRTZ_JOB_DETAILSCountArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_JOB_DETAILSCountAggregateOutputType> | number
          }
        }
      }
      QRTZ_LOCKS: {
        payload: Prisma.$QRTZ_LOCKSPayload<ExtArgs>
        fields: Prisma.QRTZ_LOCKSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRTZ_LOCKSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_LOCKSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRTZ_LOCKSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_LOCKSPayload>
          }
          findFirst: {
            args: Prisma.QRTZ_LOCKSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_LOCKSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRTZ_LOCKSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_LOCKSPayload>
          }
          findMany: {
            args: Prisma.QRTZ_LOCKSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_LOCKSPayload>[]
          }
          create: {
            args: Prisma.QRTZ_LOCKSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_LOCKSPayload>
          }
          createMany: {
            args: Prisma.QRTZ_LOCKSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QRTZ_LOCKSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_LOCKSPayload>
          }
          update: {
            args: Prisma.QRTZ_LOCKSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_LOCKSPayload>
          }
          deleteMany: {
            args: Prisma.QRTZ_LOCKSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRTZ_LOCKSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QRTZ_LOCKSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_LOCKSPayload>
          }
          aggregate: {
            args: Prisma.QRTZ_LOCKSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRTZ_LOCKS>
          }
          groupBy: {
            args: Prisma.QRTZ_LOCKSGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_LOCKSGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRTZ_LOCKSCountArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_LOCKSCountAggregateOutputType> | number
          }
        }
      }
      QRTZ_PAUSED_TRIGGER_GRPS: {
        payload: Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload<ExtArgs>
        fields: Prisma.QRTZ_PAUSED_TRIGGER_GRPSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload>
          }
          findFirst: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload>
          }
          findMany: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload>[]
          }
          create: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload>
          }
          createMany: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload>
          }
          update: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload>
          }
          deleteMany: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload>
          }
          aggregate: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRTZ_PAUSED_TRIGGER_GRPS>
          }
          groupBy: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_PAUSED_TRIGGER_GRPSGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRTZ_PAUSED_TRIGGER_GRPSCountArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_PAUSED_TRIGGER_GRPSCountAggregateOutputType> | number
          }
        }
      }
      QRTZ_SCHEDULER_STATE: {
        payload: Prisma.$QRTZ_SCHEDULER_STATEPayload<ExtArgs>
        fields: Prisma.QRTZ_SCHEDULER_STATEFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRTZ_SCHEDULER_STATEFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SCHEDULER_STATEPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRTZ_SCHEDULER_STATEFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SCHEDULER_STATEPayload>
          }
          findFirst: {
            args: Prisma.QRTZ_SCHEDULER_STATEFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SCHEDULER_STATEPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRTZ_SCHEDULER_STATEFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SCHEDULER_STATEPayload>
          }
          findMany: {
            args: Prisma.QRTZ_SCHEDULER_STATEFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SCHEDULER_STATEPayload>[]
          }
          create: {
            args: Prisma.QRTZ_SCHEDULER_STATECreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SCHEDULER_STATEPayload>
          }
          createMany: {
            args: Prisma.QRTZ_SCHEDULER_STATECreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QRTZ_SCHEDULER_STATEDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SCHEDULER_STATEPayload>
          }
          update: {
            args: Prisma.QRTZ_SCHEDULER_STATEUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SCHEDULER_STATEPayload>
          }
          deleteMany: {
            args: Prisma.QRTZ_SCHEDULER_STATEDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRTZ_SCHEDULER_STATEUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QRTZ_SCHEDULER_STATEUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SCHEDULER_STATEPayload>
          }
          aggregate: {
            args: Prisma.QRTZ_SCHEDULER_STATEAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRTZ_SCHEDULER_STATE>
          }
          groupBy: {
            args: Prisma.QRTZ_SCHEDULER_STATEGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_SCHEDULER_STATEGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRTZ_SCHEDULER_STATECountArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_SCHEDULER_STATECountAggregateOutputType> | number
          }
        }
      }
      QRTZ_SIMPLE_TRIGGERS: {
        payload: Prisma.$QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs>
        fields: Prisma.QRTZ_SIMPLE_TRIGGERSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload>
          }
          findFirst: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload>
          }
          findMany: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload>[]
          }
          create: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload>
          }
          createMany: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload>
          }
          update: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload>
          }
          deleteMany: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload>
          }
          aggregate: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRTZ_SIMPLE_TRIGGERS>
          }
          groupBy: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_SIMPLE_TRIGGERSGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRTZ_SIMPLE_TRIGGERSCountArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_SIMPLE_TRIGGERSCountAggregateOutputType> | number
          }
        }
      }
      QRTZ_SIMPROP_TRIGGERS: {
        payload: Prisma.$QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs>
        fields: Prisma.QRTZ_SIMPROP_TRIGGERSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload>
          }
          findFirst: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload>
          }
          findMany: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload>[]
          }
          create: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload>
          }
          createMany: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload>
          }
          update: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload>
          }
          deleteMany: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload>
          }
          aggregate: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRTZ_SIMPROP_TRIGGERS>
          }
          groupBy: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_SIMPROP_TRIGGERSGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRTZ_SIMPROP_TRIGGERSCountArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_SIMPROP_TRIGGERSCountAggregateOutputType> | number
          }
        }
      }
      QRTZ_TRIGGERS: {
        payload: Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>
        fields: Prisma.QRTZ_TRIGGERSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRTZ_TRIGGERSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_TRIGGERSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRTZ_TRIGGERSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_TRIGGERSPayload>
          }
          findFirst: {
            args: Prisma.QRTZ_TRIGGERSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_TRIGGERSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRTZ_TRIGGERSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_TRIGGERSPayload>
          }
          findMany: {
            args: Prisma.QRTZ_TRIGGERSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_TRIGGERSPayload>[]
          }
          create: {
            args: Prisma.QRTZ_TRIGGERSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_TRIGGERSPayload>
          }
          createMany: {
            args: Prisma.QRTZ_TRIGGERSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QRTZ_TRIGGERSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_TRIGGERSPayload>
          }
          update: {
            args: Prisma.QRTZ_TRIGGERSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_TRIGGERSPayload>
          }
          deleteMany: {
            args: Prisma.QRTZ_TRIGGERSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRTZ_TRIGGERSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QRTZ_TRIGGERSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRTZ_TRIGGERSPayload>
          }
          aggregate: {
            args: Prisma.QRTZ_TRIGGERSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRTZ_TRIGGERS>
          }
          groupBy: {
            args: Prisma.QRTZ_TRIGGERSGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_TRIGGERSGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRTZ_TRIGGERSCountArgs<ExtArgs>
            result: $Utils.Optional<QRTZ_TRIGGERSCountAggregateOutputType> | number
          }
        }
      }
      bag: {
        payload: Prisma.$bagPayload<ExtArgs>
        fields: Prisma.bagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagPayload>
          }
          findFirst: {
            args: Prisma.bagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagPayload>
          }
          findMany: {
            args: Prisma.bagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagPayload>[]
          }
          create: {
            args: Prisma.bagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagPayload>
          }
          createMany: {
            args: Prisma.bagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagPayload>
          }
          update: {
            args: Prisma.bagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagPayload>
          }
          deleteMany: {
            args: Prisma.bagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagPayload>
          }
          aggregate: {
            args: Prisma.BagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBag>
          }
          groupBy: {
            args: Prisma.bagGroupByArgs<ExtArgs>
            result: $Utils.Optional<BagGroupByOutputType>[]
          }
          count: {
            args: Prisma.bagCountArgs<ExtArgs>
            result: $Utils.Optional<BagCountAggregateOutputType> | number
          }
        }
      }
      ban_word: {
        payload: Prisma.$ban_wordPayload<ExtArgs>
        fields: Prisma.ban_wordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ban_wordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ban_wordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ban_wordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ban_wordPayload>
          }
          findFirst: {
            args: Prisma.ban_wordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ban_wordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ban_wordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ban_wordPayload>
          }
          findMany: {
            args: Prisma.ban_wordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ban_wordPayload>[]
          }
          create: {
            args: Prisma.ban_wordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ban_wordPayload>
          }
          createMany: {
            args: Prisma.ban_wordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ban_wordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ban_wordPayload>
          }
          update: {
            args: Prisma.ban_wordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ban_wordPayload>
          }
          deleteMany: {
            args: Prisma.ban_wordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ban_wordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ban_wordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ban_wordPayload>
          }
          aggregate: {
            args: Prisma.Ban_wordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBan_word>
          }
          groupBy: {
            args: Prisma.ban_wordGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ban_wordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ban_wordCountArgs<ExtArgs>
            result: $Utils.Optional<Ban_wordCountAggregateOutputType> | number
          }
        }
      }
      flyway_schema_history: {
        payload: Prisma.$flyway_schema_historyPayload<ExtArgs>
        fields: Prisma.flyway_schema_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.flyway_schema_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flyway_schema_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.flyway_schema_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flyway_schema_historyPayload>
          }
          findFirst: {
            args: Prisma.flyway_schema_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flyway_schema_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.flyway_schema_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flyway_schema_historyPayload>
          }
          findMany: {
            args: Prisma.flyway_schema_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flyway_schema_historyPayload>[]
          }
          create: {
            args: Prisma.flyway_schema_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flyway_schema_historyPayload>
          }
          createMany: {
            args: Prisma.flyway_schema_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.flyway_schema_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flyway_schema_historyPayload>
          }
          update: {
            args: Prisma.flyway_schema_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flyway_schema_historyPayload>
          }
          deleteMany: {
            args: Prisma.flyway_schema_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.flyway_schema_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.flyway_schema_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flyway_schema_historyPayload>
          }
          aggregate: {
            args: Prisma.Flyway_schema_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlyway_schema_history>
          }
          groupBy: {
            args: Prisma.flyway_schema_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Flyway_schema_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.flyway_schema_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Flyway_schema_historyCountAggregateOutputType> | number
          }
        }
      }
      follow: {
        payload: Prisma.$followPayload<ExtArgs>
        fields: Prisma.followFieldRefs
        operations: {
          findUnique: {
            args: Prisma.followFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.followFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followPayload>
          }
          findFirst: {
            args: Prisma.followFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.followFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followPayload>
          }
          findMany: {
            args: Prisma.followFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followPayload>[]
          }
          create: {
            args: Prisma.followCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followPayload>
          }
          createMany: {
            args: Prisma.followCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.followDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followPayload>
          }
          update: {
            args: Prisma.followUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followPayload>
          }
          deleteMany: {
            args: Prisma.followDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.followUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.followUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.followGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.followCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      hashtag: {
        payload: Prisma.$hashtagPayload<ExtArgs>
        fields: Prisma.hashtagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hashtagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashtagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hashtagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashtagPayload>
          }
          findFirst: {
            args: Prisma.hashtagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashtagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hashtagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashtagPayload>
          }
          findMany: {
            args: Prisma.hashtagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashtagPayload>[]
          }
          create: {
            args: Prisma.hashtagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashtagPayload>
          }
          createMany: {
            args: Prisma.hashtagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hashtagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashtagPayload>
          }
          update: {
            args: Prisma.hashtagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashtagPayload>
          }
          deleteMany: {
            args: Prisma.hashtagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hashtagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hashtagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hashtagPayload>
          }
          aggregate: {
            args: Prisma.HashtagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHashtag>
          }
          groupBy: {
            args: Prisma.hashtagGroupByArgs<ExtArgs>
            result: $Utils.Optional<HashtagGroupByOutputType>[]
          }
          count: {
            args: Prisma.hashtagCountArgs<ExtArgs>
            result: $Utils.Optional<HashtagCountAggregateOutputType> | number
          }
        }
      }
      hobby: {
        payload: Prisma.$hobbyPayload<ExtArgs>
        fields: Prisma.hobbyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hobbyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobbyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hobbyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobbyPayload>
          }
          findFirst: {
            args: Prisma.hobbyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobbyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hobbyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobbyPayload>
          }
          findMany: {
            args: Prisma.hobbyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobbyPayload>[]
          }
          create: {
            args: Prisma.hobbyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobbyPayload>
          }
          createMany: {
            args: Prisma.hobbyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hobbyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobbyPayload>
          }
          update: {
            args: Prisma.hobbyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobbyPayload>
          }
          deleteMany: {
            args: Prisma.hobbyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hobbyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hobbyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobbyPayload>
          }
          aggregate: {
            args: Prisma.HobbyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHobby>
          }
          groupBy: {
            args: Prisma.hobbyGroupByArgs<ExtArgs>
            result: $Utils.Optional<HobbyGroupByOutputType>[]
          }
          count: {
            args: Prisma.hobbyCountArgs<ExtArgs>
            result: $Utils.Optional<HobbyCountAggregateOutputType> | number
          }
        }
      }
      hobby_category: {
        payload: Prisma.$hobby_categoryPayload<ExtArgs>
        fields: Prisma.hobby_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hobby_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hobby_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_categoryPayload>
          }
          findFirst: {
            args: Prisma.hobby_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hobby_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_categoryPayload>
          }
          findMany: {
            args: Prisma.hobby_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_categoryPayload>[]
          }
          create: {
            args: Prisma.hobby_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_categoryPayload>
          }
          createMany: {
            args: Prisma.hobby_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hobby_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_categoryPayload>
          }
          update: {
            args: Prisma.hobby_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_categoryPayload>
          }
          deleteMany: {
            args: Prisma.hobby_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hobby_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hobby_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_categoryPayload>
          }
          aggregate: {
            args: Prisma.Hobby_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHobby_category>
          }
          groupBy: {
            args: Prisma.hobby_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Hobby_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.hobby_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Hobby_categoryCountAggregateOutputType> | number
          }
        }
      }
      hobby_comment: {
        payload: Prisma.$hobby_commentPayload<ExtArgs>
        fields: Prisma.hobby_commentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hobby_commentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_commentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hobby_commentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_commentPayload>
          }
          findFirst: {
            args: Prisma.hobby_commentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_commentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hobby_commentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_commentPayload>
          }
          findMany: {
            args: Prisma.hobby_commentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_commentPayload>[]
          }
          create: {
            args: Prisma.hobby_commentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_commentPayload>
          }
          createMany: {
            args: Prisma.hobby_commentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hobby_commentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_commentPayload>
          }
          update: {
            args: Prisma.hobby_commentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_commentPayload>
          }
          deleteMany: {
            args: Prisma.hobby_commentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hobby_commentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hobby_commentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_commentPayload>
          }
          aggregate: {
            args: Prisma.Hobby_commentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHobby_comment>
          }
          groupBy: {
            args: Prisma.hobby_commentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Hobby_commentGroupByOutputType>[]
          }
          count: {
            args: Prisma.hobby_commentCountArgs<ExtArgs>
            result: $Utils.Optional<Hobby_commentCountAggregateOutputType> | number
          }
        }
      }
      hobby_group: {
        payload: Prisma.$hobby_groupPayload<ExtArgs>
        fields: Prisma.hobby_groupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hobby_groupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_groupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hobby_groupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_groupPayload>
          }
          findFirst: {
            args: Prisma.hobby_groupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_groupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hobby_groupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_groupPayload>
          }
          findMany: {
            args: Prisma.hobby_groupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_groupPayload>[]
          }
          create: {
            args: Prisma.hobby_groupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_groupPayload>
          }
          createMany: {
            args: Prisma.hobby_groupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hobby_groupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_groupPayload>
          }
          update: {
            args: Prisma.hobby_groupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_groupPayload>
          }
          deleteMany: {
            args: Prisma.hobby_groupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hobby_groupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hobby_groupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_groupPayload>
          }
          aggregate: {
            args: Prisma.Hobby_groupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHobby_group>
          }
          groupBy: {
            args: Prisma.hobby_groupGroupByArgs<ExtArgs>
            result: $Utils.Optional<Hobby_groupGroupByOutputType>[]
          }
          count: {
            args: Prisma.hobby_groupCountArgs<ExtArgs>
            result: $Utils.Optional<Hobby_groupCountAggregateOutputType> | number
          }
        }
      }
      hobby_like: {
        payload: Prisma.$hobby_likePayload<ExtArgs>
        fields: Prisma.hobby_likeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hobby_likeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_likePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hobby_likeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_likePayload>
          }
          findFirst: {
            args: Prisma.hobby_likeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_likePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hobby_likeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_likePayload>
          }
          findMany: {
            args: Prisma.hobby_likeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_likePayload>[]
          }
          create: {
            args: Prisma.hobby_likeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_likePayload>
          }
          createMany: {
            args: Prisma.hobby_likeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hobby_likeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_likePayload>
          }
          update: {
            args: Prisma.hobby_likeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_likePayload>
          }
          deleteMany: {
            args: Prisma.hobby_likeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hobby_likeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hobby_likeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_likePayload>
          }
          aggregate: {
            args: Prisma.Hobby_likeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHobby_like>
          }
          groupBy: {
            args: Prisma.hobby_likeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Hobby_likeGroupByOutputType>[]
          }
          count: {
            args: Prisma.hobby_likeCountArgs<ExtArgs>
            result: $Utils.Optional<Hobby_likeCountAggregateOutputType> | number
          }
        }
      }
      hobby_photo: {
        payload: Prisma.$hobby_photoPayload<ExtArgs>
        fields: Prisma.hobby_photoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hobby_photoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_photoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hobby_photoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_photoPayload>
          }
          findFirst: {
            args: Prisma.hobby_photoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_photoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hobby_photoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_photoPayload>
          }
          findMany: {
            args: Prisma.hobby_photoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_photoPayload>[]
          }
          create: {
            args: Prisma.hobby_photoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_photoPayload>
          }
          createMany: {
            args: Prisma.hobby_photoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hobby_photoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_photoPayload>
          }
          update: {
            args: Prisma.hobby_photoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_photoPayload>
          }
          deleteMany: {
            args: Prisma.hobby_photoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hobby_photoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hobby_photoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_photoPayload>
          }
          aggregate: {
            args: Prisma.Hobby_photoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHobby_photo>
          }
          groupBy: {
            args: Prisma.hobby_photoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Hobby_photoGroupByOutputType>[]
          }
          count: {
            args: Prisma.hobby_photoCountArgs<ExtArgs>
            result: $Utils.Optional<Hobby_photoCountAggregateOutputType> | number
          }
        }
      }
      hobby_post: {
        payload: Prisma.$hobby_postPayload<ExtArgs>
        fields: Prisma.hobby_postFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hobby_postFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_postPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hobby_postFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_postPayload>
          }
          findFirst: {
            args: Prisma.hobby_postFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_postPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hobby_postFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_postPayload>
          }
          findMany: {
            args: Prisma.hobby_postFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_postPayload>[]
          }
          create: {
            args: Prisma.hobby_postCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_postPayload>
          }
          createMany: {
            args: Prisma.hobby_postCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hobby_postDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_postPayload>
          }
          update: {
            args: Prisma.hobby_postUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_postPayload>
          }
          deleteMany: {
            args: Prisma.hobby_postDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hobby_postUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hobby_postUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_postPayload>
          }
          aggregate: {
            args: Prisma.Hobby_postAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHobby_post>
          }
          groupBy: {
            args: Prisma.hobby_postGroupByArgs<ExtArgs>
            result: $Utils.Optional<Hobby_postGroupByOutputType>[]
          }
          count: {
            args: Prisma.hobby_postCountArgs<ExtArgs>
            result: $Utils.Optional<Hobby_postCountAggregateOutputType> | number
          }
        }
      }
      hobby_sub_comment: {
        payload: Prisma.$hobby_sub_commentPayload<ExtArgs>
        fields: Prisma.hobby_sub_commentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hobby_sub_commentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_sub_commentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hobby_sub_commentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_sub_commentPayload>
          }
          findFirst: {
            args: Prisma.hobby_sub_commentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_sub_commentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hobby_sub_commentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_sub_commentPayload>
          }
          findMany: {
            args: Prisma.hobby_sub_commentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_sub_commentPayload>[]
          }
          create: {
            args: Prisma.hobby_sub_commentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_sub_commentPayload>
          }
          createMany: {
            args: Prisma.hobby_sub_commentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hobby_sub_commentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_sub_commentPayload>
          }
          update: {
            args: Prisma.hobby_sub_commentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_sub_commentPayload>
          }
          deleteMany: {
            args: Prisma.hobby_sub_commentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hobby_sub_commentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hobby_sub_commentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_sub_commentPayload>
          }
          aggregate: {
            args: Prisma.Hobby_sub_commentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHobby_sub_comment>
          }
          groupBy: {
            args: Prisma.hobby_sub_commentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Hobby_sub_commentGroupByOutputType>[]
          }
          count: {
            args: Prisma.hobby_sub_commentCountArgs<ExtArgs>
            result: $Utils.Optional<Hobby_sub_commentCountAggregateOutputType> | number
          }
        }
      }
      hobby_top_ten: {
        payload: Prisma.$hobby_top_tenPayload<ExtArgs>
        fields: Prisma.hobby_top_tenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hobby_top_tenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_top_tenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hobby_top_tenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_top_tenPayload>
          }
          findFirst: {
            args: Prisma.hobby_top_tenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_top_tenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hobby_top_tenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_top_tenPayload>
          }
          findMany: {
            args: Prisma.hobby_top_tenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_top_tenPayload>[]
          }
          create: {
            args: Prisma.hobby_top_tenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_top_tenPayload>
          }
          createMany: {
            args: Prisma.hobby_top_tenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hobby_top_tenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_top_tenPayload>
          }
          update: {
            args: Prisma.hobby_top_tenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_top_tenPayload>
          }
          deleteMany: {
            args: Prisma.hobby_top_tenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hobby_top_tenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hobby_top_tenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_top_tenPayload>
          }
          aggregate: {
            args: Prisma.Hobby_top_tenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHobby_top_ten>
          }
          groupBy: {
            args: Prisma.hobby_top_tenGroupByArgs<ExtArgs>
            result: $Utils.Optional<Hobby_top_tenGroupByOutputType>[]
          }
          count: {
            args: Prisma.hobby_top_tenCountArgs<ExtArgs>
            result: $Utils.Optional<Hobby_top_tenCountAggregateOutputType> | number
          }
        }
      }
      hobby_view_history: {
        payload: Prisma.$hobby_view_historyPayload<ExtArgs>
        fields: Prisma.hobby_view_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hobby_view_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_view_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hobby_view_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_view_historyPayload>
          }
          findFirst: {
            args: Prisma.hobby_view_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_view_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hobby_view_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_view_historyPayload>
          }
          findMany: {
            args: Prisma.hobby_view_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_view_historyPayload>[]
          }
          create: {
            args: Prisma.hobby_view_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_view_historyPayload>
          }
          createMany: {
            args: Prisma.hobby_view_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hobby_view_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_view_historyPayload>
          }
          update: {
            args: Prisma.hobby_view_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_view_historyPayload>
          }
          deleteMany: {
            args: Prisma.hobby_view_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hobby_view_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hobby_view_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hobby_view_historyPayload>
          }
          aggregate: {
            args: Prisma.Hobby_view_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHobby_view_history>
          }
          groupBy: {
            args: Prisma.hobby_view_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Hobby_view_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.hobby_view_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Hobby_view_historyCountAggregateOutputType> | number
          }
        }
      }
      item: {
        payload: Prisma.$itemPayload<ExtArgs>
        fields: Prisma.itemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>
          }
          findFirst: {
            args: Prisma.itemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>
          }
          findMany: {
            args: Prisma.itemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>[]
          }
          create: {
            args: Prisma.itemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>
          }
          createMany: {
            args: Prisma.itemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.itemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>
          }
          update: {
            args: Prisma.itemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>
          }
          deleteMany: {
            args: Prisma.itemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.itemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.itemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.itemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.itemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      member: {
        payload: Prisma.$memberPayload<ExtArgs>
        fields: Prisma.memberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.memberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.memberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          findFirst: {
            args: Prisma.memberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.memberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          findMany: {
            args: Prisma.memberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>[]
          }
          create: {
            args: Prisma.memberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          createMany: {
            args: Prisma.memberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.memberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          update: {
            args: Prisma.memberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          deleteMany: {
            args: Prisma.memberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.memberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.memberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$memberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.memberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.memberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      policy_agree: {
        payload: Prisma.$policy_agreePayload<ExtArgs>
        fields: Prisma.policy_agreeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.policy_agreeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_agreePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.policy_agreeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_agreePayload>
          }
          findFirst: {
            args: Prisma.policy_agreeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_agreePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.policy_agreeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_agreePayload>
          }
          findMany: {
            args: Prisma.policy_agreeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_agreePayload>[]
          }
          create: {
            args: Prisma.policy_agreeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_agreePayload>
          }
          createMany: {
            args: Prisma.policy_agreeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.policy_agreeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_agreePayload>
          }
          update: {
            args: Prisma.policy_agreeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_agreePayload>
          }
          deleteMany: {
            args: Prisma.policy_agreeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.policy_agreeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.policy_agreeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_agreePayload>
          }
          aggregate: {
            args: Prisma.Policy_agreeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicy_agree>
          }
          groupBy: {
            args: Prisma.policy_agreeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Policy_agreeGroupByOutputType>[]
          }
          count: {
            args: Prisma.policy_agreeCountArgs<ExtArgs>
            result: $Utils.Optional<Policy_agreeCountAggregateOutputType> | number
          }
        }
      }
      policy_history: {
        payload: Prisma.$policy_historyPayload<ExtArgs>
        fields: Prisma.policy_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.policy_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.policy_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_historyPayload>
          }
          findFirst: {
            args: Prisma.policy_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.policy_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_historyPayload>
          }
          findMany: {
            args: Prisma.policy_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_historyPayload>[]
          }
          create: {
            args: Prisma.policy_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_historyPayload>
          }
          createMany: {
            args: Prisma.policy_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.policy_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_historyPayload>
          }
          update: {
            args: Prisma.policy_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_historyPayload>
          }
          deleteMany: {
            args: Prisma.policy_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.policy_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.policy_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$policy_historyPayload>
          }
          aggregate: {
            args: Prisma.Policy_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicy_history>
          }
          groupBy: {
            args: Prisma.policy_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Policy_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.policy_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Policy_historyCountAggregateOutputType> | number
          }
        }
      }
      post_hashtag: {
        payload: Prisma.$post_hashtagPayload<ExtArgs>
        fields: Prisma.post_hashtagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.post_hashtagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_hashtagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.post_hashtagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_hashtagPayload>
          }
          findFirst: {
            args: Prisma.post_hashtagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_hashtagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.post_hashtagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_hashtagPayload>
          }
          findMany: {
            args: Prisma.post_hashtagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_hashtagPayload>[]
          }
          create: {
            args: Prisma.post_hashtagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_hashtagPayload>
          }
          createMany: {
            args: Prisma.post_hashtagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.post_hashtagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_hashtagPayload>
          }
          update: {
            args: Prisma.post_hashtagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_hashtagPayload>
          }
          deleteMany: {
            args: Prisma.post_hashtagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.post_hashtagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.post_hashtagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_hashtagPayload>
          }
          aggregate: {
            args: Prisma.Post_hashtagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost_hashtag>
          }
          groupBy: {
            args: Prisma.post_hashtagGroupByArgs<ExtArgs>
            result: $Utils.Optional<Post_hashtagGroupByOutputType>[]
          }
          count: {
            args: Prisma.post_hashtagCountArgs<ExtArgs>
            result: $Utils.Optional<Post_hashtagCountAggregateOutputType> | number
          }
        }
      }
      recommended_feed: {
        payload: Prisma.$recommended_feedPayload<ExtArgs>
        fields: Prisma.recommended_feedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recommended_feedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recommended_feedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recommended_feedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recommended_feedPayload>
          }
          findFirst: {
            args: Prisma.recommended_feedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recommended_feedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recommended_feedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recommended_feedPayload>
          }
          findMany: {
            args: Prisma.recommended_feedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recommended_feedPayload>[]
          }
          create: {
            args: Prisma.recommended_feedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recommended_feedPayload>
          }
          createMany: {
            args: Prisma.recommended_feedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.recommended_feedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recommended_feedPayload>
          }
          update: {
            args: Prisma.recommended_feedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recommended_feedPayload>
          }
          deleteMany: {
            args: Prisma.recommended_feedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.recommended_feedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.recommended_feedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recommended_feedPayload>
          }
          aggregate: {
            args: Prisma.Recommended_feedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecommended_feed>
          }
          groupBy: {
            args: Prisma.recommended_feedGroupByArgs<ExtArgs>
            result: $Utils.Optional<Recommended_feedGroupByOutputType>[]
          }
          count: {
            args: Prisma.recommended_feedCountArgs<ExtArgs>
            result: $Utils.Optional<Recommended_feedCountAggregateOutputType> | number
          }
        }
      }
      report: {
        payload: Prisma.$reportPayload<ExtArgs>
        fields: Prisma.reportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>
          }
          findFirst: {
            args: Prisma.reportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>
          }
          findMany: {
            args: Prisma.reportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>[]
          }
          create: {
            args: Prisma.reportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>
          }
          createMany: {
            args: Prisma.reportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.reportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>
          }
          update: {
            args: Prisma.reportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>
          }
          deleteMany: {
            args: Prisma.reportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.reportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.reportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      setting: {
        payload: Prisma.$settingPayload<ExtArgs>
        fields: Prisma.settingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.settingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.settingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          findFirst: {
            args: Prisma.settingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.settingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          findMany: {
            args: Prisma.settingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>[]
          }
          create: {
            args: Prisma.settingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          createMany: {
            args: Prisma.settingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.settingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          update: {
            args: Prisma.settingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          deleteMany: {
            args: Prisma.settingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.settingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.settingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.settingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.settingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      today_hobby: {
        payload: Prisma.$today_hobbyPayload<ExtArgs>
        fields: Prisma.today_hobbyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.today_hobbyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$today_hobbyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.today_hobbyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$today_hobbyPayload>
          }
          findFirst: {
            args: Prisma.today_hobbyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$today_hobbyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.today_hobbyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$today_hobbyPayload>
          }
          findMany: {
            args: Prisma.today_hobbyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$today_hobbyPayload>[]
          }
          create: {
            args: Prisma.today_hobbyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$today_hobbyPayload>
          }
          createMany: {
            args: Prisma.today_hobbyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.today_hobbyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$today_hobbyPayload>
          }
          update: {
            args: Prisma.today_hobbyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$today_hobbyPayload>
          }
          deleteMany: {
            args: Prisma.today_hobbyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.today_hobbyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.today_hobbyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$today_hobbyPayload>
          }
          aggregate: {
            args: Prisma.Today_hobbyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToday_hobby>
          }
          groupBy: {
            args: Prisma.today_hobbyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Today_hobbyGroupByOutputType>[]
          }
          count: {
            args: Prisma.today_hobbyCountArgs<ExtArgs>
            result: $Utils.Optional<Today_hobbyCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      user_metrics: {
        payload: Prisma.$user_metricsPayload<ExtArgs>
        fields: Prisma.user_metricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_metricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_metricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_metricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_metricsPayload>
          }
          findFirst: {
            args: Prisma.user_metricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_metricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_metricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_metricsPayload>
          }
          findMany: {
            args: Prisma.user_metricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_metricsPayload>[]
          }
          create: {
            args: Prisma.user_metricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_metricsPayload>
          }
          createMany: {
            args: Prisma.user_metricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.user_metricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_metricsPayload>
          }
          update: {
            args: Prisma.user_metricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_metricsPayload>
          }
          deleteMany: {
            args: Prisma.user_metricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_metricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_metricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_metricsPayload>
          }
          aggregate: {
            args: Prisma.User_metricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_metrics>
          }
          groupBy: {
            args: Prisma.user_metricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_metricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_metricsCountArgs<ExtArgs>
            result: $Utils.Optional<User_metricsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    qRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSOmit
    qRTZ_CALENDARS?: QRTZ_CALENDARSOmit
    qRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSOmit
    qRTZ_FIRED_TRIGGERS?: QRTZ_FIRED_TRIGGERSOmit
    qRTZ_JOB_DETAILS?: QRTZ_JOB_DETAILSOmit
    qRTZ_LOCKS?: QRTZ_LOCKSOmit
    qRTZ_PAUSED_TRIGGER_GRPS?: QRTZ_PAUSED_TRIGGER_GRPSOmit
    qRTZ_SCHEDULER_STATE?: QRTZ_SCHEDULER_STATEOmit
    qRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSOmit
    qRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSOmit
    qRTZ_TRIGGERS?: QRTZ_TRIGGERSOmit
    bag?: bagOmit
    ban_word?: ban_wordOmit
    flyway_schema_history?: flyway_schema_historyOmit
    follow?: followOmit
    hashtag?: hashtagOmit
    hobby?: hobbyOmit
    hobby_category?: hobby_categoryOmit
    hobby_comment?: hobby_commentOmit
    hobby_group?: hobby_groupOmit
    hobby_like?: hobby_likeOmit
    hobby_photo?: hobby_photoOmit
    hobby_post?: hobby_postOmit
    hobby_sub_comment?: hobby_sub_commentOmit
    hobby_top_ten?: hobby_top_tenOmit
    hobby_view_history?: hobby_view_historyOmit
    item?: itemOmit
    member?: memberOmit
    policy_agree?: policy_agreeOmit
    policy_history?: policy_historyOmit
    post_hashtag?: post_hashtagOmit
    recommended_feed?: recommended_feedOmit
    report?: reportOmit
    setting?: settingOmit
    today_hobby?: today_hobbyOmit
    user?: userOmit
    user_metrics?: user_metricsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type QRTZ_JOB_DETAILSCountOutputType
   */

  export type QRTZ_JOB_DETAILSCountOutputType = {
    QRTZ_TRIGGERS: number
  }

  export type QRTZ_JOB_DETAILSCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QRTZ_TRIGGERS?: boolean | QRTZ_JOB_DETAILSCountOutputTypeCountQRTZ_TRIGGERSArgs
  }

  // Custom InputTypes
  /**
   * QRTZ_JOB_DETAILSCountOutputType without action
   */
  export type QRTZ_JOB_DETAILSCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_JOB_DETAILSCountOutputType
     */
    select?: QRTZ_JOB_DETAILSCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QRTZ_JOB_DETAILSCountOutputType without action
   */
  export type QRTZ_JOB_DETAILSCountOutputTypeCountQRTZ_TRIGGERSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRTZ_TRIGGERSWhereInput
  }


  /**
   * Models
   */

  /**
   * Model QRTZ_BLOB_TRIGGERS
   */

  export type AggregateQRTZ_BLOB_TRIGGERS = {
    _count: QRTZ_BLOB_TRIGGERSCountAggregateOutputType | null
    _min: QRTZ_BLOB_TRIGGERSMinAggregateOutputType | null
    _max: QRTZ_BLOB_TRIGGERSMaxAggregateOutputType | null
  }

  export type QRTZ_BLOB_TRIGGERSMinAggregateOutputType = {
    SCHED_NAME: string | null
    TRIGGER_NAME: string | null
    TRIGGER_GROUP: string | null
    BLOB_DATA: Uint8Array | null
  }

  export type QRTZ_BLOB_TRIGGERSMaxAggregateOutputType = {
    SCHED_NAME: string | null
    TRIGGER_NAME: string | null
    TRIGGER_GROUP: string | null
    BLOB_DATA: Uint8Array | null
  }

  export type QRTZ_BLOB_TRIGGERSCountAggregateOutputType = {
    SCHED_NAME: number
    TRIGGER_NAME: number
    TRIGGER_GROUP: number
    BLOB_DATA: number
    _all: number
  }


  export type QRTZ_BLOB_TRIGGERSMinAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    BLOB_DATA?: true
  }

  export type QRTZ_BLOB_TRIGGERSMaxAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    BLOB_DATA?: true
  }

  export type QRTZ_BLOB_TRIGGERSCountAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    BLOB_DATA?: true
    _all?: true
  }

  export type QRTZ_BLOB_TRIGGERSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_BLOB_TRIGGERS to aggregate.
     */
    where?: QRTZ_BLOB_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_BLOB_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_BLOB_TRIGGERSOrderByWithRelationInput | QRTZ_BLOB_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRTZ_BLOB_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_BLOB_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_BLOB_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRTZ_BLOB_TRIGGERS
    **/
    _count?: true | QRTZ_BLOB_TRIGGERSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRTZ_BLOB_TRIGGERSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRTZ_BLOB_TRIGGERSMaxAggregateInputType
  }

  export type GetQRTZ_BLOB_TRIGGERSAggregateType<T extends QRTZ_BLOB_TRIGGERSAggregateArgs> = {
        [P in keyof T & keyof AggregateQRTZ_BLOB_TRIGGERS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRTZ_BLOB_TRIGGERS[P]>
      : GetScalarType<T[P], AggregateQRTZ_BLOB_TRIGGERS[P]>
  }




  export type QRTZ_BLOB_TRIGGERSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRTZ_BLOB_TRIGGERSWhereInput
    orderBy?: QRTZ_BLOB_TRIGGERSOrderByWithAggregationInput | QRTZ_BLOB_TRIGGERSOrderByWithAggregationInput[]
    by: QRTZ_BLOB_TRIGGERSScalarFieldEnum[] | QRTZ_BLOB_TRIGGERSScalarFieldEnum
    having?: QRTZ_BLOB_TRIGGERSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRTZ_BLOB_TRIGGERSCountAggregateInputType | true
    _min?: QRTZ_BLOB_TRIGGERSMinAggregateInputType
    _max?: QRTZ_BLOB_TRIGGERSMaxAggregateInputType
  }

  export type QRTZ_BLOB_TRIGGERSGroupByOutputType = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    BLOB_DATA: Uint8Array | null
    _count: QRTZ_BLOB_TRIGGERSCountAggregateOutputType | null
    _min: QRTZ_BLOB_TRIGGERSMinAggregateOutputType | null
    _max: QRTZ_BLOB_TRIGGERSMaxAggregateOutputType | null
  }

  type GetQRTZ_BLOB_TRIGGERSGroupByPayload<T extends QRTZ_BLOB_TRIGGERSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRTZ_BLOB_TRIGGERSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRTZ_BLOB_TRIGGERSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRTZ_BLOB_TRIGGERSGroupByOutputType[P]>
            : GetScalarType<T[P], QRTZ_BLOB_TRIGGERSGroupByOutputType[P]>
        }
      >
    >


  export type QRTZ_BLOB_TRIGGERSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SCHED_NAME?: boolean
    TRIGGER_NAME?: boolean
    TRIGGER_GROUP?: boolean
    BLOB_DATA?: boolean
    QRTZ_TRIGGERS?: boolean | QRTZ_TRIGGERSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qRTZ_BLOB_TRIGGERS"]>



  export type QRTZ_BLOB_TRIGGERSSelectScalar = {
    SCHED_NAME?: boolean
    TRIGGER_NAME?: boolean
    TRIGGER_GROUP?: boolean
    BLOB_DATA?: boolean
  }

  export type QRTZ_BLOB_TRIGGERSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SCHED_NAME" | "TRIGGER_NAME" | "TRIGGER_GROUP" | "BLOB_DATA", ExtArgs["result"]["qRTZ_BLOB_TRIGGERS"]>
  export type QRTZ_BLOB_TRIGGERSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QRTZ_TRIGGERS?: boolean | QRTZ_TRIGGERSDefaultArgs<ExtArgs>
  }

  export type $QRTZ_BLOB_TRIGGERSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRTZ_BLOB_TRIGGERS"
    objects: {
      QRTZ_TRIGGERS: Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      SCHED_NAME: string
      TRIGGER_NAME: string
      TRIGGER_GROUP: string
      BLOB_DATA: Uint8Array | null
    }, ExtArgs["result"]["qRTZ_BLOB_TRIGGERS"]>
    composites: {}
  }

  type QRTZ_BLOB_TRIGGERSGetPayload<S extends boolean | null | undefined | QRTZ_BLOB_TRIGGERSDefaultArgs> = $Result.GetResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload, S>

  type QRTZ_BLOB_TRIGGERSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRTZ_BLOB_TRIGGERSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRTZ_BLOB_TRIGGERSCountAggregateInputType | true
    }

  export interface QRTZ_BLOB_TRIGGERSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRTZ_BLOB_TRIGGERS'], meta: { name: 'QRTZ_BLOB_TRIGGERS' } }
    /**
     * Find zero or one QRTZ_BLOB_TRIGGERS that matches the filter.
     * @param {QRTZ_BLOB_TRIGGERSFindUniqueArgs} args - Arguments to find a QRTZ_BLOB_TRIGGERS
     * @example
     * // Get one QRTZ_BLOB_TRIGGERS
     * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRTZ_BLOB_TRIGGERSFindUniqueArgs>(args: SelectSubset<T, QRTZ_BLOB_TRIGGERSFindUniqueArgs<ExtArgs>>): Prisma__QRTZ_BLOB_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRTZ_BLOB_TRIGGERS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRTZ_BLOB_TRIGGERSFindUniqueOrThrowArgs} args - Arguments to find a QRTZ_BLOB_TRIGGERS
     * @example
     * // Get one QRTZ_BLOB_TRIGGERS
     * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRTZ_BLOB_TRIGGERSFindUniqueOrThrowArgs>(args: SelectSubset<T, QRTZ_BLOB_TRIGGERSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRTZ_BLOB_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_BLOB_TRIGGERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_BLOB_TRIGGERSFindFirstArgs} args - Arguments to find a QRTZ_BLOB_TRIGGERS
     * @example
     * // Get one QRTZ_BLOB_TRIGGERS
     * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRTZ_BLOB_TRIGGERSFindFirstArgs>(args?: SelectSubset<T, QRTZ_BLOB_TRIGGERSFindFirstArgs<ExtArgs>>): Prisma__QRTZ_BLOB_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_BLOB_TRIGGERS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_BLOB_TRIGGERSFindFirstOrThrowArgs} args - Arguments to find a QRTZ_BLOB_TRIGGERS
     * @example
     * // Get one QRTZ_BLOB_TRIGGERS
     * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRTZ_BLOB_TRIGGERSFindFirstOrThrowArgs>(args?: SelectSubset<T, QRTZ_BLOB_TRIGGERSFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRTZ_BLOB_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRTZ_BLOB_TRIGGERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_BLOB_TRIGGERSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRTZ_BLOB_TRIGGERS
     * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.findMany()
     * 
     * // Get first 10 QRTZ_BLOB_TRIGGERS
     * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.findMany({ take: 10 })
     * 
     * // Only select the `SCHED_NAME`
     * const qRTZ_BLOB_TRIGGERSWithSCHED_NAMEOnly = await prisma.qRTZ_BLOB_TRIGGERS.findMany({ select: { SCHED_NAME: true } })
     * 
     */
    findMany<T extends QRTZ_BLOB_TRIGGERSFindManyArgs>(args?: SelectSubset<T, QRTZ_BLOB_TRIGGERSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRTZ_BLOB_TRIGGERS.
     * @param {QRTZ_BLOB_TRIGGERSCreateArgs} args - Arguments to create a QRTZ_BLOB_TRIGGERS.
     * @example
     * // Create one QRTZ_BLOB_TRIGGERS
     * const QRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.create({
     *   data: {
     *     // ... data to create a QRTZ_BLOB_TRIGGERS
     *   }
     * })
     * 
     */
    create<T extends QRTZ_BLOB_TRIGGERSCreateArgs>(args: SelectSubset<T, QRTZ_BLOB_TRIGGERSCreateArgs<ExtArgs>>): Prisma__QRTZ_BLOB_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRTZ_BLOB_TRIGGERS.
     * @param {QRTZ_BLOB_TRIGGERSCreateManyArgs} args - Arguments to create many QRTZ_BLOB_TRIGGERS.
     * @example
     * // Create many QRTZ_BLOB_TRIGGERS
     * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRTZ_BLOB_TRIGGERSCreateManyArgs>(args?: SelectSubset<T, QRTZ_BLOB_TRIGGERSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QRTZ_BLOB_TRIGGERS.
     * @param {QRTZ_BLOB_TRIGGERSDeleteArgs} args - Arguments to delete one QRTZ_BLOB_TRIGGERS.
     * @example
     * // Delete one QRTZ_BLOB_TRIGGERS
     * const QRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.delete({
     *   where: {
     *     // ... filter to delete one QRTZ_BLOB_TRIGGERS
     *   }
     * })
     * 
     */
    delete<T extends QRTZ_BLOB_TRIGGERSDeleteArgs>(args: SelectSubset<T, QRTZ_BLOB_TRIGGERSDeleteArgs<ExtArgs>>): Prisma__QRTZ_BLOB_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRTZ_BLOB_TRIGGERS.
     * @param {QRTZ_BLOB_TRIGGERSUpdateArgs} args - Arguments to update one QRTZ_BLOB_TRIGGERS.
     * @example
     * // Update one QRTZ_BLOB_TRIGGERS
     * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRTZ_BLOB_TRIGGERSUpdateArgs>(args: SelectSubset<T, QRTZ_BLOB_TRIGGERSUpdateArgs<ExtArgs>>): Prisma__QRTZ_BLOB_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRTZ_BLOB_TRIGGERS.
     * @param {QRTZ_BLOB_TRIGGERSDeleteManyArgs} args - Arguments to filter QRTZ_BLOB_TRIGGERS to delete.
     * @example
     * // Delete a few QRTZ_BLOB_TRIGGERS
     * const { count } = await prisma.qRTZ_BLOB_TRIGGERS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRTZ_BLOB_TRIGGERSDeleteManyArgs>(args?: SelectSubset<T, QRTZ_BLOB_TRIGGERSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRTZ_BLOB_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_BLOB_TRIGGERSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRTZ_BLOB_TRIGGERS
     * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRTZ_BLOB_TRIGGERSUpdateManyArgs>(args: SelectSubset<T, QRTZ_BLOB_TRIGGERSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QRTZ_BLOB_TRIGGERS.
     * @param {QRTZ_BLOB_TRIGGERSUpsertArgs} args - Arguments to update or create a QRTZ_BLOB_TRIGGERS.
     * @example
     * // Update or create a QRTZ_BLOB_TRIGGERS
     * const qRTZ_BLOB_TRIGGERS = await prisma.qRTZ_BLOB_TRIGGERS.upsert({
     *   create: {
     *     // ... data to create a QRTZ_BLOB_TRIGGERS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRTZ_BLOB_TRIGGERS we want to update
     *   }
     * })
     */
    upsert<T extends QRTZ_BLOB_TRIGGERSUpsertArgs>(args: SelectSubset<T, QRTZ_BLOB_TRIGGERSUpsertArgs<ExtArgs>>): Prisma__QRTZ_BLOB_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRTZ_BLOB_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_BLOB_TRIGGERSCountArgs} args - Arguments to filter QRTZ_BLOB_TRIGGERS to count.
     * @example
     * // Count the number of QRTZ_BLOB_TRIGGERS
     * const count = await prisma.qRTZ_BLOB_TRIGGERS.count({
     *   where: {
     *     // ... the filter for the QRTZ_BLOB_TRIGGERS we want to count
     *   }
     * })
    **/
    count<T extends QRTZ_BLOB_TRIGGERSCountArgs>(
      args?: Subset<T, QRTZ_BLOB_TRIGGERSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRTZ_BLOB_TRIGGERSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRTZ_BLOB_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_BLOB_TRIGGERSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRTZ_BLOB_TRIGGERSAggregateArgs>(args: Subset<T, QRTZ_BLOB_TRIGGERSAggregateArgs>): Prisma.PrismaPromise<GetQRTZ_BLOB_TRIGGERSAggregateType<T>>

    /**
     * Group by QRTZ_BLOB_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_BLOB_TRIGGERSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRTZ_BLOB_TRIGGERSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRTZ_BLOB_TRIGGERSGroupByArgs['orderBy'] }
        : { orderBy?: QRTZ_BLOB_TRIGGERSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRTZ_BLOB_TRIGGERSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRTZ_BLOB_TRIGGERSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRTZ_BLOB_TRIGGERS model
   */
  readonly fields: QRTZ_BLOB_TRIGGERSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRTZ_BLOB_TRIGGERS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRTZ_BLOB_TRIGGERSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    QRTZ_TRIGGERS<T extends QRTZ_TRIGGERSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QRTZ_TRIGGERSDefaultArgs<ExtArgs>>): Prisma__QRTZ_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRTZ_BLOB_TRIGGERS model
   */
  interface QRTZ_BLOB_TRIGGERSFieldRefs {
    readonly SCHED_NAME: FieldRef<"QRTZ_BLOB_TRIGGERS", 'String'>
    readonly TRIGGER_NAME: FieldRef<"QRTZ_BLOB_TRIGGERS", 'String'>
    readonly TRIGGER_GROUP: FieldRef<"QRTZ_BLOB_TRIGGERS", 'String'>
    readonly BLOB_DATA: FieldRef<"QRTZ_BLOB_TRIGGERS", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * QRTZ_BLOB_TRIGGERS findUnique
   */
  export type QRTZ_BLOB_TRIGGERSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_BLOB_TRIGGERS
     */
    select?: QRTZ_BLOB_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_BLOB_TRIGGERS
     */
    omit?: QRTZ_BLOB_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_BLOB_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_BLOB_TRIGGERS to fetch.
     */
    where: QRTZ_BLOB_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_BLOB_TRIGGERS findUniqueOrThrow
   */
  export type QRTZ_BLOB_TRIGGERSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_BLOB_TRIGGERS
     */
    select?: QRTZ_BLOB_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_BLOB_TRIGGERS
     */
    omit?: QRTZ_BLOB_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_BLOB_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_BLOB_TRIGGERS to fetch.
     */
    where: QRTZ_BLOB_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_BLOB_TRIGGERS findFirst
   */
  export type QRTZ_BLOB_TRIGGERSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_BLOB_TRIGGERS
     */
    select?: QRTZ_BLOB_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_BLOB_TRIGGERS
     */
    omit?: QRTZ_BLOB_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_BLOB_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_BLOB_TRIGGERS to fetch.
     */
    where?: QRTZ_BLOB_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_BLOB_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_BLOB_TRIGGERSOrderByWithRelationInput | QRTZ_BLOB_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_BLOB_TRIGGERS.
     */
    cursor?: QRTZ_BLOB_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_BLOB_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_BLOB_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_BLOB_TRIGGERS.
     */
    distinct?: QRTZ_BLOB_TRIGGERSScalarFieldEnum | QRTZ_BLOB_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_BLOB_TRIGGERS findFirstOrThrow
   */
  export type QRTZ_BLOB_TRIGGERSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_BLOB_TRIGGERS
     */
    select?: QRTZ_BLOB_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_BLOB_TRIGGERS
     */
    omit?: QRTZ_BLOB_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_BLOB_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_BLOB_TRIGGERS to fetch.
     */
    where?: QRTZ_BLOB_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_BLOB_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_BLOB_TRIGGERSOrderByWithRelationInput | QRTZ_BLOB_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_BLOB_TRIGGERS.
     */
    cursor?: QRTZ_BLOB_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_BLOB_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_BLOB_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_BLOB_TRIGGERS.
     */
    distinct?: QRTZ_BLOB_TRIGGERSScalarFieldEnum | QRTZ_BLOB_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_BLOB_TRIGGERS findMany
   */
  export type QRTZ_BLOB_TRIGGERSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_BLOB_TRIGGERS
     */
    select?: QRTZ_BLOB_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_BLOB_TRIGGERS
     */
    omit?: QRTZ_BLOB_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_BLOB_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_BLOB_TRIGGERS to fetch.
     */
    where?: QRTZ_BLOB_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_BLOB_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_BLOB_TRIGGERSOrderByWithRelationInput | QRTZ_BLOB_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRTZ_BLOB_TRIGGERS.
     */
    cursor?: QRTZ_BLOB_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_BLOB_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_BLOB_TRIGGERS.
     */
    skip?: number
    distinct?: QRTZ_BLOB_TRIGGERSScalarFieldEnum | QRTZ_BLOB_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_BLOB_TRIGGERS create
   */
  export type QRTZ_BLOB_TRIGGERSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_BLOB_TRIGGERS
     */
    select?: QRTZ_BLOB_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_BLOB_TRIGGERS
     */
    omit?: QRTZ_BLOB_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_BLOB_TRIGGERSInclude<ExtArgs> | null
    /**
     * The data needed to create a QRTZ_BLOB_TRIGGERS.
     */
    data: XOR<QRTZ_BLOB_TRIGGERSCreateInput, QRTZ_BLOB_TRIGGERSUncheckedCreateInput>
  }

  /**
   * QRTZ_BLOB_TRIGGERS createMany
   */
  export type QRTZ_BLOB_TRIGGERSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRTZ_BLOB_TRIGGERS.
     */
    data: QRTZ_BLOB_TRIGGERSCreateManyInput | QRTZ_BLOB_TRIGGERSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRTZ_BLOB_TRIGGERS update
   */
  export type QRTZ_BLOB_TRIGGERSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_BLOB_TRIGGERS
     */
    select?: QRTZ_BLOB_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_BLOB_TRIGGERS
     */
    omit?: QRTZ_BLOB_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_BLOB_TRIGGERSInclude<ExtArgs> | null
    /**
     * The data needed to update a QRTZ_BLOB_TRIGGERS.
     */
    data: XOR<QRTZ_BLOB_TRIGGERSUpdateInput, QRTZ_BLOB_TRIGGERSUncheckedUpdateInput>
    /**
     * Choose, which QRTZ_BLOB_TRIGGERS to update.
     */
    where: QRTZ_BLOB_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_BLOB_TRIGGERS updateMany
   */
  export type QRTZ_BLOB_TRIGGERSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRTZ_BLOB_TRIGGERS.
     */
    data: XOR<QRTZ_BLOB_TRIGGERSUpdateManyMutationInput, QRTZ_BLOB_TRIGGERSUncheckedUpdateManyInput>
    /**
     * Filter which QRTZ_BLOB_TRIGGERS to update
     */
    where?: QRTZ_BLOB_TRIGGERSWhereInput
    /**
     * Limit how many QRTZ_BLOB_TRIGGERS to update.
     */
    limit?: number
  }

  /**
   * QRTZ_BLOB_TRIGGERS upsert
   */
  export type QRTZ_BLOB_TRIGGERSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_BLOB_TRIGGERS
     */
    select?: QRTZ_BLOB_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_BLOB_TRIGGERS
     */
    omit?: QRTZ_BLOB_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_BLOB_TRIGGERSInclude<ExtArgs> | null
    /**
     * The filter to search for the QRTZ_BLOB_TRIGGERS to update in case it exists.
     */
    where: QRTZ_BLOB_TRIGGERSWhereUniqueInput
    /**
     * In case the QRTZ_BLOB_TRIGGERS found by the `where` argument doesn't exist, create a new QRTZ_BLOB_TRIGGERS with this data.
     */
    create: XOR<QRTZ_BLOB_TRIGGERSCreateInput, QRTZ_BLOB_TRIGGERSUncheckedCreateInput>
    /**
     * In case the QRTZ_BLOB_TRIGGERS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRTZ_BLOB_TRIGGERSUpdateInput, QRTZ_BLOB_TRIGGERSUncheckedUpdateInput>
  }

  /**
   * QRTZ_BLOB_TRIGGERS delete
   */
  export type QRTZ_BLOB_TRIGGERSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_BLOB_TRIGGERS
     */
    select?: QRTZ_BLOB_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_BLOB_TRIGGERS
     */
    omit?: QRTZ_BLOB_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_BLOB_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter which QRTZ_BLOB_TRIGGERS to delete.
     */
    where: QRTZ_BLOB_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_BLOB_TRIGGERS deleteMany
   */
  export type QRTZ_BLOB_TRIGGERSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_BLOB_TRIGGERS to delete
     */
    where?: QRTZ_BLOB_TRIGGERSWhereInput
    /**
     * Limit how many QRTZ_BLOB_TRIGGERS to delete.
     */
    limit?: number
  }

  /**
   * QRTZ_BLOB_TRIGGERS without action
   */
  export type QRTZ_BLOB_TRIGGERSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_BLOB_TRIGGERS
     */
    select?: QRTZ_BLOB_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_BLOB_TRIGGERS
     */
    omit?: QRTZ_BLOB_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_BLOB_TRIGGERSInclude<ExtArgs> | null
  }


  /**
   * Model QRTZ_CALENDARS
   */

  export type AggregateQRTZ_CALENDARS = {
    _count: QRTZ_CALENDARSCountAggregateOutputType | null
    _min: QRTZ_CALENDARSMinAggregateOutputType | null
    _max: QRTZ_CALENDARSMaxAggregateOutputType | null
  }

  export type QRTZ_CALENDARSMinAggregateOutputType = {
    SCHED_NAME: string | null
    CALENDAR_NAME: string | null
    CALENDAR: Uint8Array | null
  }

  export type QRTZ_CALENDARSMaxAggregateOutputType = {
    SCHED_NAME: string | null
    CALENDAR_NAME: string | null
    CALENDAR: Uint8Array | null
  }

  export type QRTZ_CALENDARSCountAggregateOutputType = {
    SCHED_NAME: number
    CALENDAR_NAME: number
    CALENDAR: number
    _all: number
  }


  export type QRTZ_CALENDARSMinAggregateInputType = {
    SCHED_NAME?: true
    CALENDAR_NAME?: true
    CALENDAR?: true
  }

  export type QRTZ_CALENDARSMaxAggregateInputType = {
    SCHED_NAME?: true
    CALENDAR_NAME?: true
    CALENDAR?: true
  }

  export type QRTZ_CALENDARSCountAggregateInputType = {
    SCHED_NAME?: true
    CALENDAR_NAME?: true
    CALENDAR?: true
    _all?: true
  }

  export type QRTZ_CALENDARSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_CALENDARS to aggregate.
     */
    where?: QRTZ_CALENDARSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_CALENDARS to fetch.
     */
    orderBy?: QRTZ_CALENDARSOrderByWithRelationInput | QRTZ_CALENDARSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRTZ_CALENDARSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_CALENDARS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_CALENDARS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRTZ_CALENDARS
    **/
    _count?: true | QRTZ_CALENDARSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRTZ_CALENDARSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRTZ_CALENDARSMaxAggregateInputType
  }

  export type GetQRTZ_CALENDARSAggregateType<T extends QRTZ_CALENDARSAggregateArgs> = {
        [P in keyof T & keyof AggregateQRTZ_CALENDARS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRTZ_CALENDARS[P]>
      : GetScalarType<T[P], AggregateQRTZ_CALENDARS[P]>
  }




  export type QRTZ_CALENDARSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRTZ_CALENDARSWhereInput
    orderBy?: QRTZ_CALENDARSOrderByWithAggregationInput | QRTZ_CALENDARSOrderByWithAggregationInput[]
    by: QRTZ_CALENDARSScalarFieldEnum[] | QRTZ_CALENDARSScalarFieldEnum
    having?: QRTZ_CALENDARSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRTZ_CALENDARSCountAggregateInputType | true
    _min?: QRTZ_CALENDARSMinAggregateInputType
    _max?: QRTZ_CALENDARSMaxAggregateInputType
  }

  export type QRTZ_CALENDARSGroupByOutputType = {
    SCHED_NAME: string
    CALENDAR_NAME: string
    CALENDAR: Uint8Array
    _count: QRTZ_CALENDARSCountAggregateOutputType | null
    _min: QRTZ_CALENDARSMinAggregateOutputType | null
    _max: QRTZ_CALENDARSMaxAggregateOutputType | null
  }

  type GetQRTZ_CALENDARSGroupByPayload<T extends QRTZ_CALENDARSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRTZ_CALENDARSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRTZ_CALENDARSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRTZ_CALENDARSGroupByOutputType[P]>
            : GetScalarType<T[P], QRTZ_CALENDARSGroupByOutputType[P]>
        }
      >
    >


  export type QRTZ_CALENDARSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SCHED_NAME?: boolean
    CALENDAR_NAME?: boolean
    CALENDAR?: boolean
  }, ExtArgs["result"]["qRTZ_CALENDARS"]>



  export type QRTZ_CALENDARSSelectScalar = {
    SCHED_NAME?: boolean
    CALENDAR_NAME?: boolean
    CALENDAR?: boolean
  }

  export type QRTZ_CALENDARSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SCHED_NAME" | "CALENDAR_NAME" | "CALENDAR", ExtArgs["result"]["qRTZ_CALENDARS"]>

  export type $QRTZ_CALENDARSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRTZ_CALENDARS"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SCHED_NAME: string
      CALENDAR_NAME: string
      CALENDAR: Uint8Array
    }, ExtArgs["result"]["qRTZ_CALENDARS"]>
    composites: {}
  }

  type QRTZ_CALENDARSGetPayload<S extends boolean | null | undefined | QRTZ_CALENDARSDefaultArgs> = $Result.GetResult<Prisma.$QRTZ_CALENDARSPayload, S>

  type QRTZ_CALENDARSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRTZ_CALENDARSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRTZ_CALENDARSCountAggregateInputType | true
    }

  export interface QRTZ_CALENDARSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRTZ_CALENDARS'], meta: { name: 'QRTZ_CALENDARS' } }
    /**
     * Find zero or one QRTZ_CALENDARS that matches the filter.
     * @param {QRTZ_CALENDARSFindUniqueArgs} args - Arguments to find a QRTZ_CALENDARS
     * @example
     * // Get one QRTZ_CALENDARS
     * const qRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRTZ_CALENDARSFindUniqueArgs>(args: SelectSubset<T, QRTZ_CALENDARSFindUniqueArgs<ExtArgs>>): Prisma__QRTZ_CALENDARSClient<$Result.GetResult<Prisma.$QRTZ_CALENDARSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRTZ_CALENDARS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRTZ_CALENDARSFindUniqueOrThrowArgs} args - Arguments to find a QRTZ_CALENDARS
     * @example
     * // Get one QRTZ_CALENDARS
     * const qRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRTZ_CALENDARSFindUniqueOrThrowArgs>(args: SelectSubset<T, QRTZ_CALENDARSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRTZ_CALENDARSClient<$Result.GetResult<Prisma.$QRTZ_CALENDARSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_CALENDARS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CALENDARSFindFirstArgs} args - Arguments to find a QRTZ_CALENDARS
     * @example
     * // Get one QRTZ_CALENDARS
     * const qRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRTZ_CALENDARSFindFirstArgs>(args?: SelectSubset<T, QRTZ_CALENDARSFindFirstArgs<ExtArgs>>): Prisma__QRTZ_CALENDARSClient<$Result.GetResult<Prisma.$QRTZ_CALENDARSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_CALENDARS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CALENDARSFindFirstOrThrowArgs} args - Arguments to find a QRTZ_CALENDARS
     * @example
     * // Get one QRTZ_CALENDARS
     * const qRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRTZ_CALENDARSFindFirstOrThrowArgs>(args?: SelectSubset<T, QRTZ_CALENDARSFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRTZ_CALENDARSClient<$Result.GetResult<Prisma.$QRTZ_CALENDARSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRTZ_CALENDARS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CALENDARSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRTZ_CALENDARS
     * const qRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.findMany()
     * 
     * // Get first 10 QRTZ_CALENDARS
     * const qRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.findMany({ take: 10 })
     * 
     * // Only select the `SCHED_NAME`
     * const qRTZ_CALENDARSWithSCHED_NAMEOnly = await prisma.qRTZ_CALENDARS.findMany({ select: { SCHED_NAME: true } })
     * 
     */
    findMany<T extends QRTZ_CALENDARSFindManyArgs>(args?: SelectSubset<T, QRTZ_CALENDARSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRTZ_CALENDARSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRTZ_CALENDARS.
     * @param {QRTZ_CALENDARSCreateArgs} args - Arguments to create a QRTZ_CALENDARS.
     * @example
     * // Create one QRTZ_CALENDARS
     * const QRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.create({
     *   data: {
     *     // ... data to create a QRTZ_CALENDARS
     *   }
     * })
     * 
     */
    create<T extends QRTZ_CALENDARSCreateArgs>(args: SelectSubset<T, QRTZ_CALENDARSCreateArgs<ExtArgs>>): Prisma__QRTZ_CALENDARSClient<$Result.GetResult<Prisma.$QRTZ_CALENDARSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRTZ_CALENDARS.
     * @param {QRTZ_CALENDARSCreateManyArgs} args - Arguments to create many QRTZ_CALENDARS.
     * @example
     * // Create many QRTZ_CALENDARS
     * const qRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRTZ_CALENDARSCreateManyArgs>(args?: SelectSubset<T, QRTZ_CALENDARSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QRTZ_CALENDARS.
     * @param {QRTZ_CALENDARSDeleteArgs} args - Arguments to delete one QRTZ_CALENDARS.
     * @example
     * // Delete one QRTZ_CALENDARS
     * const QRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.delete({
     *   where: {
     *     // ... filter to delete one QRTZ_CALENDARS
     *   }
     * })
     * 
     */
    delete<T extends QRTZ_CALENDARSDeleteArgs>(args: SelectSubset<T, QRTZ_CALENDARSDeleteArgs<ExtArgs>>): Prisma__QRTZ_CALENDARSClient<$Result.GetResult<Prisma.$QRTZ_CALENDARSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRTZ_CALENDARS.
     * @param {QRTZ_CALENDARSUpdateArgs} args - Arguments to update one QRTZ_CALENDARS.
     * @example
     * // Update one QRTZ_CALENDARS
     * const qRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRTZ_CALENDARSUpdateArgs>(args: SelectSubset<T, QRTZ_CALENDARSUpdateArgs<ExtArgs>>): Prisma__QRTZ_CALENDARSClient<$Result.GetResult<Prisma.$QRTZ_CALENDARSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRTZ_CALENDARS.
     * @param {QRTZ_CALENDARSDeleteManyArgs} args - Arguments to filter QRTZ_CALENDARS to delete.
     * @example
     * // Delete a few QRTZ_CALENDARS
     * const { count } = await prisma.qRTZ_CALENDARS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRTZ_CALENDARSDeleteManyArgs>(args?: SelectSubset<T, QRTZ_CALENDARSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRTZ_CALENDARS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CALENDARSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRTZ_CALENDARS
     * const qRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRTZ_CALENDARSUpdateManyArgs>(args: SelectSubset<T, QRTZ_CALENDARSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QRTZ_CALENDARS.
     * @param {QRTZ_CALENDARSUpsertArgs} args - Arguments to update or create a QRTZ_CALENDARS.
     * @example
     * // Update or create a QRTZ_CALENDARS
     * const qRTZ_CALENDARS = await prisma.qRTZ_CALENDARS.upsert({
     *   create: {
     *     // ... data to create a QRTZ_CALENDARS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRTZ_CALENDARS we want to update
     *   }
     * })
     */
    upsert<T extends QRTZ_CALENDARSUpsertArgs>(args: SelectSubset<T, QRTZ_CALENDARSUpsertArgs<ExtArgs>>): Prisma__QRTZ_CALENDARSClient<$Result.GetResult<Prisma.$QRTZ_CALENDARSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRTZ_CALENDARS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CALENDARSCountArgs} args - Arguments to filter QRTZ_CALENDARS to count.
     * @example
     * // Count the number of QRTZ_CALENDARS
     * const count = await prisma.qRTZ_CALENDARS.count({
     *   where: {
     *     // ... the filter for the QRTZ_CALENDARS we want to count
     *   }
     * })
    **/
    count<T extends QRTZ_CALENDARSCountArgs>(
      args?: Subset<T, QRTZ_CALENDARSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRTZ_CALENDARSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRTZ_CALENDARS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CALENDARSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRTZ_CALENDARSAggregateArgs>(args: Subset<T, QRTZ_CALENDARSAggregateArgs>): Prisma.PrismaPromise<GetQRTZ_CALENDARSAggregateType<T>>

    /**
     * Group by QRTZ_CALENDARS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CALENDARSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRTZ_CALENDARSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRTZ_CALENDARSGroupByArgs['orderBy'] }
        : { orderBy?: QRTZ_CALENDARSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRTZ_CALENDARSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRTZ_CALENDARSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRTZ_CALENDARS model
   */
  readonly fields: QRTZ_CALENDARSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRTZ_CALENDARS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRTZ_CALENDARSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRTZ_CALENDARS model
   */
  interface QRTZ_CALENDARSFieldRefs {
    readonly SCHED_NAME: FieldRef<"QRTZ_CALENDARS", 'String'>
    readonly CALENDAR_NAME: FieldRef<"QRTZ_CALENDARS", 'String'>
    readonly CALENDAR: FieldRef<"QRTZ_CALENDARS", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * QRTZ_CALENDARS findUnique
   */
  export type QRTZ_CALENDARSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CALENDARS
     */
    select?: QRTZ_CALENDARSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CALENDARS
     */
    omit?: QRTZ_CALENDARSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_CALENDARS to fetch.
     */
    where: QRTZ_CALENDARSWhereUniqueInput
  }

  /**
   * QRTZ_CALENDARS findUniqueOrThrow
   */
  export type QRTZ_CALENDARSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CALENDARS
     */
    select?: QRTZ_CALENDARSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CALENDARS
     */
    omit?: QRTZ_CALENDARSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_CALENDARS to fetch.
     */
    where: QRTZ_CALENDARSWhereUniqueInput
  }

  /**
   * QRTZ_CALENDARS findFirst
   */
  export type QRTZ_CALENDARSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CALENDARS
     */
    select?: QRTZ_CALENDARSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CALENDARS
     */
    omit?: QRTZ_CALENDARSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_CALENDARS to fetch.
     */
    where?: QRTZ_CALENDARSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_CALENDARS to fetch.
     */
    orderBy?: QRTZ_CALENDARSOrderByWithRelationInput | QRTZ_CALENDARSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_CALENDARS.
     */
    cursor?: QRTZ_CALENDARSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_CALENDARS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_CALENDARS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_CALENDARS.
     */
    distinct?: QRTZ_CALENDARSScalarFieldEnum | QRTZ_CALENDARSScalarFieldEnum[]
  }

  /**
   * QRTZ_CALENDARS findFirstOrThrow
   */
  export type QRTZ_CALENDARSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CALENDARS
     */
    select?: QRTZ_CALENDARSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CALENDARS
     */
    omit?: QRTZ_CALENDARSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_CALENDARS to fetch.
     */
    where?: QRTZ_CALENDARSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_CALENDARS to fetch.
     */
    orderBy?: QRTZ_CALENDARSOrderByWithRelationInput | QRTZ_CALENDARSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_CALENDARS.
     */
    cursor?: QRTZ_CALENDARSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_CALENDARS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_CALENDARS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_CALENDARS.
     */
    distinct?: QRTZ_CALENDARSScalarFieldEnum | QRTZ_CALENDARSScalarFieldEnum[]
  }

  /**
   * QRTZ_CALENDARS findMany
   */
  export type QRTZ_CALENDARSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CALENDARS
     */
    select?: QRTZ_CALENDARSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CALENDARS
     */
    omit?: QRTZ_CALENDARSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_CALENDARS to fetch.
     */
    where?: QRTZ_CALENDARSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_CALENDARS to fetch.
     */
    orderBy?: QRTZ_CALENDARSOrderByWithRelationInput | QRTZ_CALENDARSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRTZ_CALENDARS.
     */
    cursor?: QRTZ_CALENDARSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_CALENDARS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_CALENDARS.
     */
    skip?: number
    distinct?: QRTZ_CALENDARSScalarFieldEnum | QRTZ_CALENDARSScalarFieldEnum[]
  }

  /**
   * QRTZ_CALENDARS create
   */
  export type QRTZ_CALENDARSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CALENDARS
     */
    select?: QRTZ_CALENDARSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CALENDARS
     */
    omit?: QRTZ_CALENDARSOmit<ExtArgs> | null
    /**
     * The data needed to create a QRTZ_CALENDARS.
     */
    data: XOR<QRTZ_CALENDARSCreateInput, QRTZ_CALENDARSUncheckedCreateInput>
  }

  /**
   * QRTZ_CALENDARS createMany
   */
  export type QRTZ_CALENDARSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRTZ_CALENDARS.
     */
    data: QRTZ_CALENDARSCreateManyInput | QRTZ_CALENDARSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRTZ_CALENDARS update
   */
  export type QRTZ_CALENDARSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CALENDARS
     */
    select?: QRTZ_CALENDARSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CALENDARS
     */
    omit?: QRTZ_CALENDARSOmit<ExtArgs> | null
    /**
     * The data needed to update a QRTZ_CALENDARS.
     */
    data: XOR<QRTZ_CALENDARSUpdateInput, QRTZ_CALENDARSUncheckedUpdateInput>
    /**
     * Choose, which QRTZ_CALENDARS to update.
     */
    where: QRTZ_CALENDARSWhereUniqueInput
  }

  /**
   * QRTZ_CALENDARS updateMany
   */
  export type QRTZ_CALENDARSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRTZ_CALENDARS.
     */
    data: XOR<QRTZ_CALENDARSUpdateManyMutationInput, QRTZ_CALENDARSUncheckedUpdateManyInput>
    /**
     * Filter which QRTZ_CALENDARS to update
     */
    where?: QRTZ_CALENDARSWhereInput
    /**
     * Limit how many QRTZ_CALENDARS to update.
     */
    limit?: number
  }

  /**
   * QRTZ_CALENDARS upsert
   */
  export type QRTZ_CALENDARSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CALENDARS
     */
    select?: QRTZ_CALENDARSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CALENDARS
     */
    omit?: QRTZ_CALENDARSOmit<ExtArgs> | null
    /**
     * The filter to search for the QRTZ_CALENDARS to update in case it exists.
     */
    where: QRTZ_CALENDARSWhereUniqueInput
    /**
     * In case the QRTZ_CALENDARS found by the `where` argument doesn't exist, create a new QRTZ_CALENDARS with this data.
     */
    create: XOR<QRTZ_CALENDARSCreateInput, QRTZ_CALENDARSUncheckedCreateInput>
    /**
     * In case the QRTZ_CALENDARS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRTZ_CALENDARSUpdateInput, QRTZ_CALENDARSUncheckedUpdateInput>
  }

  /**
   * QRTZ_CALENDARS delete
   */
  export type QRTZ_CALENDARSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CALENDARS
     */
    select?: QRTZ_CALENDARSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CALENDARS
     */
    omit?: QRTZ_CALENDARSOmit<ExtArgs> | null
    /**
     * Filter which QRTZ_CALENDARS to delete.
     */
    where: QRTZ_CALENDARSWhereUniqueInput
  }

  /**
   * QRTZ_CALENDARS deleteMany
   */
  export type QRTZ_CALENDARSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_CALENDARS to delete
     */
    where?: QRTZ_CALENDARSWhereInput
    /**
     * Limit how many QRTZ_CALENDARS to delete.
     */
    limit?: number
  }

  /**
   * QRTZ_CALENDARS without action
   */
  export type QRTZ_CALENDARSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CALENDARS
     */
    select?: QRTZ_CALENDARSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CALENDARS
     */
    omit?: QRTZ_CALENDARSOmit<ExtArgs> | null
  }


  /**
   * Model QRTZ_CRON_TRIGGERS
   */

  export type AggregateQRTZ_CRON_TRIGGERS = {
    _count: QRTZ_CRON_TRIGGERSCountAggregateOutputType | null
    _min: QRTZ_CRON_TRIGGERSMinAggregateOutputType | null
    _max: QRTZ_CRON_TRIGGERSMaxAggregateOutputType | null
  }

  export type QRTZ_CRON_TRIGGERSMinAggregateOutputType = {
    SCHED_NAME: string | null
    TRIGGER_NAME: string | null
    TRIGGER_GROUP: string | null
    CRON_EXPRESSION: string | null
    TIME_ZONE_ID: string | null
  }

  export type QRTZ_CRON_TRIGGERSMaxAggregateOutputType = {
    SCHED_NAME: string | null
    TRIGGER_NAME: string | null
    TRIGGER_GROUP: string | null
    CRON_EXPRESSION: string | null
    TIME_ZONE_ID: string | null
  }

  export type QRTZ_CRON_TRIGGERSCountAggregateOutputType = {
    SCHED_NAME: number
    TRIGGER_NAME: number
    TRIGGER_GROUP: number
    CRON_EXPRESSION: number
    TIME_ZONE_ID: number
    _all: number
  }


  export type QRTZ_CRON_TRIGGERSMinAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    CRON_EXPRESSION?: true
    TIME_ZONE_ID?: true
  }

  export type QRTZ_CRON_TRIGGERSMaxAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    CRON_EXPRESSION?: true
    TIME_ZONE_ID?: true
  }

  export type QRTZ_CRON_TRIGGERSCountAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    CRON_EXPRESSION?: true
    TIME_ZONE_ID?: true
    _all?: true
  }

  export type QRTZ_CRON_TRIGGERSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_CRON_TRIGGERS to aggregate.
     */
    where?: QRTZ_CRON_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_CRON_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_CRON_TRIGGERSOrderByWithRelationInput | QRTZ_CRON_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRTZ_CRON_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_CRON_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_CRON_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRTZ_CRON_TRIGGERS
    **/
    _count?: true | QRTZ_CRON_TRIGGERSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRTZ_CRON_TRIGGERSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRTZ_CRON_TRIGGERSMaxAggregateInputType
  }

  export type GetQRTZ_CRON_TRIGGERSAggregateType<T extends QRTZ_CRON_TRIGGERSAggregateArgs> = {
        [P in keyof T & keyof AggregateQRTZ_CRON_TRIGGERS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRTZ_CRON_TRIGGERS[P]>
      : GetScalarType<T[P], AggregateQRTZ_CRON_TRIGGERS[P]>
  }




  export type QRTZ_CRON_TRIGGERSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRTZ_CRON_TRIGGERSWhereInput
    orderBy?: QRTZ_CRON_TRIGGERSOrderByWithAggregationInput | QRTZ_CRON_TRIGGERSOrderByWithAggregationInput[]
    by: QRTZ_CRON_TRIGGERSScalarFieldEnum[] | QRTZ_CRON_TRIGGERSScalarFieldEnum
    having?: QRTZ_CRON_TRIGGERSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRTZ_CRON_TRIGGERSCountAggregateInputType | true
    _min?: QRTZ_CRON_TRIGGERSMinAggregateInputType
    _max?: QRTZ_CRON_TRIGGERSMaxAggregateInputType
  }

  export type QRTZ_CRON_TRIGGERSGroupByOutputType = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    CRON_EXPRESSION: string
    TIME_ZONE_ID: string | null
    _count: QRTZ_CRON_TRIGGERSCountAggregateOutputType | null
    _min: QRTZ_CRON_TRIGGERSMinAggregateOutputType | null
    _max: QRTZ_CRON_TRIGGERSMaxAggregateOutputType | null
  }

  type GetQRTZ_CRON_TRIGGERSGroupByPayload<T extends QRTZ_CRON_TRIGGERSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRTZ_CRON_TRIGGERSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRTZ_CRON_TRIGGERSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRTZ_CRON_TRIGGERSGroupByOutputType[P]>
            : GetScalarType<T[P], QRTZ_CRON_TRIGGERSGroupByOutputType[P]>
        }
      >
    >


  export type QRTZ_CRON_TRIGGERSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SCHED_NAME?: boolean
    TRIGGER_NAME?: boolean
    TRIGGER_GROUP?: boolean
    CRON_EXPRESSION?: boolean
    TIME_ZONE_ID?: boolean
    QRTZ_TRIGGERS?: boolean | QRTZ_TRIGGERSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qRTZ_CRON_TRIGGERS"]>



  export type QRTZ_CRON_TRIGGERSSelectScalar = {
    SCHED_NAME?: boolean
    TRIGGER_NAME?: boolean
    TRIGGER_GROUP?: boolean
    CRON_EXPRESSION?: boolean
    TIME_ZONE_ID?: boolean
  }

  export type QRTZ_CRON_TRIGGERSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SCHED_NAME" | "TRIGGER_NAME" | "TRIGGER_GROUP" | "CRON_EXPRESSION" | "TIME_ZONE_ID", ExtArgs["result"]["qRTZ_CRON_TRIGGERS"]>
  export type QRTZ_CRON_TRIGGERSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QRTZ_TRIGGERS?: boolean | QRTZ_TRIGGERSDefaultArgs<ExtArgs>
  }

  export type $QRTZ_CRON_TRIGGERSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRTZ_CRON_TRIGGERS"
    objects: {
      QRTZ_TRIGGERS: Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      SCHED_NAME: string
      TRIGGER_NAME: string
      TRIGGER_GROUP: string
      CRON_EXPRESSION: string
      TIME_ZONE_ID: string | null
    }, ExtArgs["result"]["qRTZ_CRON_TRIGGERS"]>
    composites: {}
  }

  type QRTZ_CRON_TRIGGERSGetPayload<S extends boolean | null | undefined | QRTZ_CRON_TRIGGERSDefaultArgs> = $Result.GetResult<Prisma.$QRTZ_CRON_TRIGGERSPayload, S>

  type QRTZ_CRON_TRIGGERSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRTZ_CRON_TRIGGERSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRTZ_CRON_TRIGGERSCountAggregateInputType | true
    }

  export interface QRTZ_CRON_TRIGGERSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRTZ_CRON_TRIGGERS'], meta: { name: 'QRTZ_CRON_TRIGGERS' } }
    /**
     * Find zero or one QRTZ_CRON_TRIGGERS that matches the filter.
     * @param {QRTZ_CRON_TRIGGERSFindUniqueArgs} args - Arguments to find a QRTZ_CRON_TRIGGERS
     * @example
     * // Get one QRTZ_CRON_TRIGGERS
     * const qRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRTZ_CRON_TRIGGERSFindUniqueArgs>(args: SelectSubset<T, QRTZ_CRON_TRIGGERSFindUniqueArgs<ExtArgs>>): Prisma__QRTZ_CRON_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_CRON_TRIGGERSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRTZ_CRON_TRIGGERS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRTZ_CRON_TRIGGERSFindUniqueOrThrowArgs} args - Arguments to find a QRTZ_CRON_TRIGGERS
     * @example
     * // Get one QRTZ_CRON_TRIGGERS
     * const qRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRTZ_CRON_TRIGGERSFindUniqueOrThrowArgs>(args: SelectSubset<T, QRTZ_CRON_TRIGGERSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRTZ_CRON_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_CRON_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_CRON_TRIGGERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CRON_TRIGGERSFindFirstArgs} args - Arguments to find a QRTZ_CRON_TRIGGERS
     * @example
     * // Get one QRTZ_CRON_TRIGGERS
     * const qRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRTZ_CRON_TRIGGERSFindFirstArgs>(args?: SelectSubset<T, QRTZ_CRON_TRIGGERSFindFirstArgs<ExtArgs>>): Prisma__QRTZ_CRON_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_CRON_TRIGGERSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_CRON_TRIGGERS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CRON_TRIGGERSFindFirstOrThrowArgs} args - Arguments to find a QRTZ_CRON_TRIGGERS
     * @example
     * // Get one QRTZ_CRON_TRIGGERS
     * const qRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRTZ_CRON_TRIGGERSFindFirstOrThrowArgs>(args?: SelectSubset<T, QRTZ_CRON_TRIGGERSFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRTZ_CRON_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_CRON_TRIGGERSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRTZ_CRON_TRIGGERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CRON_TRIGGERSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRTZ_CRON_TRIGGERS
     * const qRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.findMany()
     * 
     * // Get first 10 QRTZ_CRON_TRIGGERS
     * const qRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.findMany({ take: 10 })
     * 
     * // Only select the `SCHED_NAME`
     * const qRTZ_CRON_TRIGGERSWithSCHED_NAMEOnly = await prisma.qRTZ_CRON_TRIGGERS.findMany({ select: { SCHED_NAME: true } })
     * 
     */
    findMany<T extends QRTZ_CRON_TRIGGERSFindManyArgs>(args?: SelectSubset<T, QRTZ_CRON_TRIGGERSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRTZ_CRON_TRIGGERSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRTZ_CRON_TRIGGERS.
     * @param {QRTZ_CRON_TRIGGERSCreateArgs} args - Arguments to create a QRTZ_CRON_TRIGGERS.
     * @example
     * // Create one QRTZ_CRON_TRIGGERS
     * const QRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.create({
     *   data: {
     *     // ... data to create a QRTZ_CRON_TRIGGERS
     *   }
     * })
     * 
     */
    create<T extends QRTZ_CRON_TRIGGERSCreateArgs>(args: SelectSubset<T, QRTZ_CRON_TRIGGERSCreateArgs<ExtArgs>>): Prisma__QRTZ_CRON_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_CRON_TRIGGERSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRTZ_CRON_TRIGGERS.
     * @param {QRTZ_CRON_TRIGGERSCreateManyArgs} args - Arguments to create many QRTZ_CRON_TRIGGERS.
     * @example
     * // Create many QRTZ_CRON_TRIGGERS
     * const qRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRTZ_CRON_TRIGGERSCreateManyArgs>(args?: SelectSubset<T, QRTZ_CRON_TRIGGERSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QRTZ_CRON_TRIGGERS.
     * @param {QRTZ_CRON_TRIGGERSDeleteArgs} args - Arguments to delete one QRTZ_CRON_TRIGGERS.
     * @example
     * // Delete one QRTZ_CRON_TRIGGERS
     * const QRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.delete({
     *   where: {
     *     // ... filter to delete one QRTZ_CRON_TRIGGERS
     *   }
     * })
     * 
     */
    delete<T extends QRTZ_CRON_TRIGGERSDeleteArgs>(args: SelectSubset<T, QRTZ_CRON_TRIGGERSDeleteArgs<ExtArgs>>): Prisma__QRTZ_CRON_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_CRON_TRIGGERSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRTZ_CRON_TRIGGERS.
     * @param {QRTZ_CRON_TRIGGERSUpdateArgs} args - Arguments to update one QRTZ_CRON_TRIGGERS.
     * @example
     * // Update one QRTZ_CRON_TRIGGERS
     * const qRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRTZ_CRON_TRIGGERSUpdateArgs>(args: SelectSubset<T, QRTZ_CRON_TRIGGERSUpdateArgs<ExtArgs>>): Prisma__QRTZ_CRON_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_CRON_TRIGGERSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRTZ_CRON_TRIGGERS.
     * @param {QRTZ_CRON_TRIGGERSDeleteManyArgs} args - Arguments to filter QRTZ_CRON_TRIGGERS to delete.
     * @example
     * // Delete a few QRTZ_CRON_TRIGGERS
     * const { count } = await prisma.qRTZ_CRON_TRIGGERS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRTZ_CRON_TRIGGERSDeleteManyArgs>(args?: SelectSubset<T, QRTZ_CRON_TRIGGERSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRTZ_CRON_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CRON_TRIGGERSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRTZ_CRON_TRIGGERS
     * const qRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRTZ_CRON_TRIGGERSUpdateManyArgs>(args: SelectSubset<T, QRTZ_CRON_TRIGGERSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QRTZ_CRON_TRIGGERS.
     * @param {QRTZ_CRON_TRIGGERSUpsertArgs} args - Arguments to update or create a QRTZ_CRON_TRIGGERS.
     * @example
     * // Update or create a QRTZ_CRON_TRIGGERS
     * const qRTZ_CRON_TRIGGERS = await prisma.qRTZ_CRON_TRIGGERS.upsert({
     *   create: {
     *     // ... data to create a QRTZ_CRON_TRIGGERS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRTZ_CRON_TRIGGERS we want to update
     *   }
     * })
     */
    upsert<T extends QRTZ_CRON_TRIGGERSUpsertArgs>(args: SelectSubset<T, QRTZ_CRON_TRIGGERSUpsertArgs<ExtArgs>>): Prisma__QRTZ_CRON_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_CRON_TRIGGERSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRTZ_CRON_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CRON_TRIGGERSCountArgs} args - Arguments to filter QRTZ_CRON_TRIGGERS to count.
     * @example
     * // Count the number of QRTZ_CRON_TRIGGERS
     * const count = await prisma.qRTZ_CRON_TRIGGERS.count({
     *   where: {
     *     // ... the filter for the QRTZ_CRON_TRIGGERS we want to count
     *   }
     * })
    **/
    count<T extends QRTZ_CRON_TRIGGERSCountArgs>(
      args?: Subset<T, QRTZ_CRON_TRIGGERSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRTZ_CRON_TRIGGERSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRTZ_CRON_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CRON_TRIGGERSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRTZ_CRON_TRIGGERSAggregateArgs>(args: Subset<T, QRTZ_CRON_TRIGGERSAggregateArgs>): Prisma.PrismaPromise<GetQRTZ_CRON_TRIGGERSAggregateType<T>>

    /**
     * Group by QRTZ_CRON_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_CRON_TRIGGERSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRTZ_CRON_TRIGGERSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRTZ_CRON_TRIGGERSGroupByArgs['orderBy'] }
        : { orderBy?: QRTZ_CRON_TRIGGERSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRTZ_CRON_TRIGGERSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRTZ_CRON_TRIGGERSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRTZ_CRON_TRIGGERS model
   */
  readonly fields: QRTZ_CRON_TRIGGERSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRTZ_CRON_TRIGGERS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRTZ_CRON_TRIGGERSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    QRTZ_TRIGGERS<T extends QRTZ_TRIGGERSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QRTZ_TRIGGERSDefaultArgs<ExtArgs>>): Prisma__QRTZ_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRTZ_CRON_TRIGGERS model
   */
  interface QRTZ_CRON_TRIGGERSFieldRefs {
    readonly SCHED_NAME: FieldRef<"QRTZ_CRON_TRIGGERS", 'String'>
    readonly TRIGGER_NAME: FieldRef<"QRTZ_CRON_TRIGGERS", 'String'>
    readonly TRIGGER_GROUP: FieldRef<"QRTZ_CRON_TRIGGERS", 'String'>
    readonly CRON_EXPRESSION: FieldRef<"QRTZ_CRON_TRIGGERS", 'String'>
    readonly TIME_ZONE_ID: FieldRef<"QRTZ_CRON_TRIGGERS", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QRTZ_CRON_TRIGGERS findUnique
   */
  export type QRTZ_CRON_TRIGGERSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CRON_TRIGGERS
     */
    select?: QRTZ_CRON_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CRON_TRIGGERS
     */
    omit?: QRTZ_CRON_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_CRON_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_CRON_TRIGGERS to fetch.
     */
    where: QRTZ_CRON_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_CRON_TRIGGERS findUniqueOrThrow
   */
  export type QRTZ_CRON_TRIGGERSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CRON_TRIGGERS
     */
    select?: QRTZ_CRON_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CRON_TRIGGERS
     */
    omit?: QRTZ_CRON_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_CRON_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_CRON_TRIGGERS to fetch.
     */
    where: QRTZ_CRON_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_CRON_TRIGGERS findFirst
   */
  export type QRTZ_CRON_TRIGGERSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CRON_TRIGGERS
     */
    select?: QRTZ_CRON_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CRON_TRIGGERS
     */
    omit?: QRTZ_CRON_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_CRON_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_CRON_TRIGGERS to fetch.
     */
    where?: QRTZ_CRON_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_CRON_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_CRON_TRIGGERSOrderByWithRelationInput | QRTZ_CRON_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_CRON_TRIGGERS.
     */
    cursor?: QRTZ_CRON_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_CRON_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_CRON_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_CRON_TRIGGERS.
     */
    distinct?: QRTZ_CRON_TRIGGERSScalarFieldEnum | QRTZ_CRON_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_CRON_TRIGGERS findFirstOrThrow
   */
  export type QRTZ_CRON_TRIGGERSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CRON_TRIGGERS
     */
    select?: QRTZ_CRON_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CRON_TRIGGERS
     */
    omit?: QRTZ_CRON_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_CRON_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_CRON_TRIGGERS to fetch.
     */
    where?: QRTZ_CRON_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_CRON_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_CRON_TRIGGERSOrderByWithRelationInput | QRTZ_CRON_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_CRON_TRIGGERS.
     */
    cursor?: QRTZ_CRON_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_CRON_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_CRON_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_CRON_TRIGGERS.
     */
    distinct?: QRTZ_CRON_TRIGGERSScalarFieldEnum | QRTZ_CRON_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_CRON_TRIGGERS findMany
   */
  export type QRTZ_CRON_TRIGGERSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CRON_TRIGGERS
     */
    select?: QRTZ_CRON_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CRON_TRIGGERS
     */
    omit?: QRTZ_CRON_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_CRON_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_CRON_TRIGGERS to fetch.
     */
    where?: QRTZ_CRON_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_CRON_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_CRON_TRIGGERSOrderByWithRelationInput | QRTZ_CRON_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRTZ_CRON_TRIGGERS.
     */
    cursor?: QRTZ_CRON_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_CRON_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_CRON_TRIGGERS.
     */
    skip?: number
    distinct?: QRTZ_CRON_TRIGGERSScalarFieldEnum | QRTZ_CRON_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_CRON_TRIGGERS create
   */
  export type QRTZ_CRON_TRIGGERSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CRON_TRIGGERS
     */
    select?: QRTZ_CRON_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CRON_TRIGGERS
     */
    omit?: QRTZ_CRON_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_CRON_TRIGGERSInclude<ExtArgs> | null
    /**
     * The data needed to create a QRTZ_CRON_TRIGGERS.
     */
    data: XOR<QRTZ_CRON_TRIGGERSCreateInput, QRTZ_CRON_TRIGGERSUncheckedCreateInput>
  }

  /**
   * QRTZ_CRON_TRIGGERS createMany
   */
  export type QRTZ_CRON_TRIGGERSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRTZ_CRON_TRIGGERS.
     */
    data: QRTZ_CRON_TRIGGERSCreateManyInput | QRTZ_CRON_TRIGGERSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRTZ_CRON_TRIGGERS update
   */
  export type QRTZ_CRON_TRIGGERSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CRON_TRIGGERS
     */
    select?: QRTZ_CRON_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CRON_TRIGGERS
     */
    omit?: QRTZ_CRON_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_CRON_TRIGGERSInclude<ExtArgs> | null
    /**
     * The data needed to update a QRTZ_CRON_TRIGGERS.
     */
    data: XOR<QRTZ_CRON_TRIGGERSUpdateInput, QRTZ_CRON_TRIGGERSUncheckedUpdateInput>
    /**
     * Choose, which QRTZ_CRON_TRIGGERS to update.
     */
    where: QRTZ_CRON_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_CRON_TRIGGERS updateMany
   */
  export type QRTZ_CRON_TRIGGERSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRTZ_CRON_TRIGGERS.
     */
    data: XOR<QRTZ_CRON_TRIGGERSUpdateManyMutationInput, QRTZ_CRON_TRIGGERSUncheckedUpdateManyInput>
    /**
     * Filter which QRTZ_CRON_TRIGGERS to update
     */
    where?: QRTZ_CRON_TRIGGERSWhereInput
    /**
     * Limit how many QRTZ_CRON_TRIGGERS to update.
     */
    limit?: number
  }

  /**
   * QRTZ_CRON_TRIGGERS upsert
   */
  export type QRTZ_CRON_TRIGGERSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CRON_TRIGGERS
     */
    select?: QRTZ_CRON_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CRON_TRIGGERS
     */
    omit?: QRTZ_CRON_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_CRON_TRIGGERSInclude<ExtArgs> | null
    /**
     * The filter to search for the QRTZ_CRON_TRIGGERS to update in case it exists.
     */
    where: QRTZ_CRON_TRIGGERSWhereUniqueInput
    /**
     * In case the QRTZ_CRON_TRIGGERS found by the `where` argument doesn't exist, create a new QRTZ_CRON_TRIGGERS with this data.
     */
    create: XOR<QRTZ_CRON_TRIGGERSCreateInput, QRTZ_CRON_TRIGGERSUncheckedCreateInput>
    /**
     * In case the QRTZ_CRON_TRIGGERS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRTZ_CRON_TRIGGERSUpdateInput, QRTZ_CRON_TRIGGERSUncheckedUpdateInput>
  }

  /**
   * QRTZ_CRON_TRIGGERS delete
   */
  export type QRTZ_CRON_TRIGGERSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CRON_TRIGGERS
     */
    select?: QRTZ_CRON_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CRON_TRIGGERS
     */
    omit?: QRTZ_CRON_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_CRON_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter which QRTZ_CRON_TRIGGERS to delete.
     */
    where: QRTZ_CRON_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_CRON_TRIGGERS deleteMany
   */
  export type QRTZ_CRON_TRIGGERSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_CRON_TRIGGERS to delete
     */
    where?: QRTZ_CRON_TRIGGERSWhereInput
    /**
     * Limit how many QRTZ_CRON_TRIGGERS to delete.
     */
    limit?: number
  }

  /**
   * QRTZ_CRON_TRIGGERS without action
   */
  export type QRTZ_CRON_TRIGGERSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CRON_TRIGGERS
     */
    select?: QRTZ_CRON_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CRON_TRIGGERS
     */
    omit?: QRTZ_CRON_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_CRON_TRIGGERSInclude<ExtArgs> | null
  }


  /**
   * Model QRTZ_FIRED_TRIGGERS
   */

  export type AggregateQRTZ_FIRED_TRIGGERS = {
    _count: QRTZ_FIRED_TRIGGERSCountAggregateOutputType | null
    _avg: QRTZ_FIRED_TRIGGERSAvgAggregateOutputType | null
    _sum: QRTZ_FIRED_TRIGGERSSumAggregateOutputType | null
    _min: QRTZ_FIRED_TRIGGERSMinAggregateOutputType | null
    _max: QRTZ_FIRED_TRIGGERSMaxAggregateOutputType | null
  }

  export type QRTZ_FIRED_TRIGGERSAvgAggregateOutputType = {
    FIRED_TIME: number | null
    SCHED_TIME: number | null
    PRIORITY: number | null
  }

  export type QRTZ_FIRED_TRIGGERSSumAggregateOutputType = {
    FIRED_TIME: bigint | null
    SCHED_TIME: bigint | null
    PRIORITY: number | null
  }

  export type QRTZ_FIRED_TRIGGERSMinAggregateOutputType = {
    SCHED_NAME: string | null
    ENTRY_ID: string | null
    TRIGGER_NAME: string | null
    TRIGGER_GROUP: string | null
    INSTANCE_NAME: string | null
    FIRED_TIME: bigint | null
    SCHED_TIME: bigint | null
    PRIORITY: number | null
    STATE: string | null
    JOB_NAME: string | null
    JOB_GROUP: string | null
    IS_NONCONCURRENT: string | null
    REQUESTS_RECOVERY: string | null
  }

  export type QRTZ_FIRED_TRIGGERSMaxAggregateOutputType = {
    SCHED_NAME: string | null
    ENTRY_ID: string | null
    TRIGGER_NAME: string | null
    TRIGGER_GROUP: string | null
    INSTANCE_NAME: string | null
    FIRED_TIME: bigint | null
    SCHED_TIME: bigint | null
    PRIORITY: number | null
    STATE: string | null
    JOB_NAME: string | null
    JOB_GROUP: string | null
    IS_NONCONCURRENT: string | null
    REQUESTS_RECOVERY: string | null
  }

  export type QRTZ_FIRED_TRIGGERSCountAggregateOutputType = {
    SCHED_NAME: number
    ENTRY_ID: number
    TRIGGER_NAME: number
    TRIGGER_GROUP: number
    INSTANCE_NAME: number
    FIRED_TIME: number
    SCHED_TIME: number
    PRIORITY: number
    STATE: number
    JOB_NAME: number
    JOB_GROUP: number
    IS_NONCONCURRENT: number
    REQUESTS_RECOVERY: number
    _all: number
  }


  export type QRTZ_FIRED_TRIGGERSAvgAggregateInputType = {
    FIRED_TIME?: true
    SCHED_TIME?: true
    PRIORITY?: true
  }

  export type QRTZ_FIRED_TRIGGERSSumAggregateInputType = {
    FIRED_TIME?: true
    SCHED_TIME?: true
    PRIORITY?: true
  }

  export type QRTZ_FIRED_TRIGGERSMinAggregateInputType = {
    SCHED_NAME?: true
    ENTRY_ID?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    INSTANCE_NAME?: true
    FIRED_TIME?: true
    SCHED_TIME?: true
    PRIORITY?: true
    STATE?: true
    JOB_NAME?: true
    JOB_GROUP?: true
    IS_NONCONCURRENT?: true
    REQUESTS_RECOVERY?: true
  }

  export type QRTZ_FIRED_TRIGGERSMaxAggregateInputType = {
    SCHED_NAME?: true
    ENTRY_ID?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    INSTANCE_NAME?: true
    FIRED_TIME?: true
    SCHED_TIME?: true
    PRIORITY?: true
    STATE?: true
    JOB_NAME?: true
    JOB_GROUP?: true
    IS_NONCONCURRENT?: true
    REQUESTS_RECOVERY?: true
  }

  export type QRTZ_FIRED_TRIGGERSCountAggregateInputType = {
    SCHED_NAME?: true
    ENTRY_ID?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    INSTANCE_NAME?: true
    FIRED_TIME?: true
    SCHED_TIME?: true
    PRIORITY?: true
    STATE?: true
    JOB_NAME?: true
    JOB_GROUP?: true
    IS_NONCONCURRENT?: true
    REQUESTS_RECOVERY?: true
    _all?: true
  }

  export type QRTZ_FIRED_TRIGGERSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_FIRED_TRIGGERS to aggregate.
     */
    where?: QRTZ_FIRED_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_FIRED_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_FIRED_TRIGGERSOrderByWithRelationInput | QRTZ_FIRED_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRTZ_FIRED_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_FIRED_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_FIRED_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRTZ_FIRED_TRIGGERS
    **/
    _count?: true | QRTZ_FIRED_TRIGGERSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QRTZ_FIRED_TRIGGERSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QRTZ_FIRED_TRIGGERSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRTZ_FIRED_TRIGGERSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRTZ_FIRED_TRIGGERSMaxAggregateInputType
  }

  export type GetQRTZ_FIRED_TRIGGERSAggregateType<T extends QRTZ_FIRED_TRIGGERSAggregateArgs> = {
        [P in keyof T & keyof AggregateQRTZ_FIRED_TRIGGERS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRTZ_FIRED_TRIGGERS[P]>
      : GetScalarType<T[P], AggregateQRTZ_FIRED_TRIGGERS[P]>
  }




  export type QRTZ_FIRED_TRIGGERSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRTZ_FIRED_TRIGGERSWhereInput
    orderBy?: QRTZ_FIRED_TRIGGERSOrderByWithAggregationInput | QRTZ_FIRED_TRIGGERSOrderByWithAggregationInput[]
    by: QRTZ_FIRED_TRIGGERSScalarFieldEnum[] | QRTZ_FIRED_TRIGGERSScalarFieldEnum
    having?: QRTZ_FIRED_TRIGGERSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRTZ_FIRED_TRIGGERSCountAggregateInputType | true
    _avg?: QRTZ_FIRED_TRIGGERSAvgAggregateInputType
    _sum?: QRTZ_FIRED_TRIGGERSSumAggregateInputType
    _min?: QRTZ_FIRED_TRIGGERSMinAggregateInputType
    _max?: QRTZ_FIRED_TRIGGERSMaxAggregateInputType
  }

  export type QRTZ_FIRED_TRIGGERSGroupByOutputType = {
    SCHED_NAME: string
    ENTRY_ID: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    INSTANCE_NAME: string
    FIRED_TIME: bigint
    SCHED_TIME: bigint
    PRIORITY: number
    STATE: string
    JOB_NAME: string | null
    JOB_GROUP: string | null
    IS_NONCONCURRENT: string | null
    REQUESTS_RECOVERY: string | null
    _count: QRTZ_FIRED_TRIGGERSCountAggregateOutputType | null
    _avg: QRTZ_FIRED_TRIGGERSAvgAggregateOutputType | null
    _sum: QRTZ_FIRED_TRIGGERSSumAggregateOutputType | null
    _min: QRTZ_FIRED_TRIGGERSMinAggregateOutputType | null
    _max: QRTZ_FIRED_TRIGGERSMaxAggregateOutputType | null
  }

  type GetQRTZ_FIRED_TRIGGERSGroupByPayload<T extends QRTZ_FIRED_TRIGGERSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRTZ_FIRED_TRIGGERSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRTZ_FIRED_TRIGGERSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRTZ_FIRED_TRIGGERSGroupByOutputType[P]>
            : GetScalarType<T[P], QRTZ_FIRED_TRIGGERSGroupByOutputType[P]>
        }
      >
    >


  export type QRTZ_FIRED_TRIGGERSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SCHED_NAME?: boolean
    ENTRY_ID?: boolean
    TRIGGER_NAME?: boolean
    TRIGGER_GROUP?: boolean
    INSTANCE_NAME?: boolean
    FIRED_TIME?: boolean
    SCHED_TIME?: boolean
    PRIORITY?: boolean
    STATE?: boolean
    JOB_NAME?: boolean
    JOB_GROUP?: boolean
    IS_NONCONCURRENT?: boolean
    REQUESTS_RECOVERY?: boolean
  }, ExtArgs["result"]["qRTZ_FIRED_TRIGGERS"]>



  export type QRTZ_FIRED_TRIGGERSSelectScalar = {
    SCHED_NAME?: boolean
    ENTRY_ID?: boolean
    TRIGGER_NAME?: boolean
    TRIGGER_GROUP?: boolean
    INSTANCE_NAME?: boolean
    FIRED_TIME?: boolean
    SCHED_TIME?: boolean
    PRIORITY?: boolean
    STATE?: boolean
    JOB_NAME?: boolean
    JOB_GROUP?: boolean
    IS_NONCONCURRENT?: boolean
    REQUESTS_RECOVERY?: boolean
  }

  export type QRTZ_FIRED_TRIGGERSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SCHED_NAME" | "ENTRY_ID" | "TRIGGER_NAME" | "TRIGGER_GROUP" | "INSTANCE_NAME" | "FIRED_TIME" | "SCHED_TIME" | "PRIORITY" | "STATE" | "JOB_NAME" | "JOB_GROUP" | "IS_NONCONCURRENT" | "REQUESTS_RECOVERY", ExtArgs["result"]["qRTZ_FIRED_TRIGGERS"]>

  export type $QRTZ_FIRED_TRIGGERSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRTZ_FIRED_TRIGGERS"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SCHED_NAME: string
      ENTRY_ID: string
      TRIGGER_NAME: string
      TRIGGER_GROUP: string
      INSTANCE_NAME: string
      FIRED_TIME: bigint
      SCHED_TIME: bigint
      PRIORITY: number
      STATE: string
      JOB_NAME: string | null
      JOB_GROUP: string | null
      IS_NONCONCURRENT: string | null
      REQUESTS_RECOVERY: string | null
    }, ExtArgs["result"]["qRTZ_FIRED_TRIGGERS"]>
    composites: {}
  }

  type QRTZ_FIRED_TRIGGERSGetPayload<S extends boolean | null | undefined | QRTZ_FIRED_TRIGGERSDefaultArgs> = $Result.GetResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload, S>

  type QRTZ_FIRED_TRIGGERSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRTZ_FIRED_TRIGGERSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRTZ_FIRED_TRIGGERSCountAggregateInputType | true
    }

  export interface QRTZ_FIRED_TRIGGERSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRTZ_FIRED_TRIGGERS'], meta: { name: 'QRTZ_FIRED_TRIGGERS' } }
    /**
     * Find zero or one QRTZ_FIRED_TRIGGERS that matches the filter.
     * @param {QRTZ_FIRED_TRIGGERSFindUniqueArgs} args - Arguments to find a QRTZ_FIRED_TRIGGERS
     * @example
     * // Get one QRTZ_FIRED_TRIGGERS
     * const qRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRTZ_FIRED_TRIGGERSFindUniqueArgs>(args: SelectSubset<T, QRTZ_FIRED_TRIGGERSFindUniqueArgs<ExtArgs>>): Prisma__QRTZ_FIRED_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRTZ_FIRED_TRIGGERS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRTZ_FIRED_TRIGGERSFindUniqueOrThrowArgs} args - Arguments to find a QRTZ_FIRED_TRIGGERS
     * @example
     * // Get one QRTZ_FIRED_TRIGGERS
     * const qRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRTZ_FIRED_TRIGGERSFindUniqueOrThrowArgs>(args: SelectSubset<T, QRTZ_FIRED_TRIGGERSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRTZ_FIRED_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_FIRED_TRIGGERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_FIRED_TRIGGERSFindFirstArgs} args - Arguments to find a QRTZ_FIRED_TRIGGERS
     * @example
     * // Get one QRTZ_FIRED_TRIGGERS
     * const qRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRTZ_FIRED_TRIGGERSFindFirstArgs>(args?: SelectSubset<T, QRTZ_FIRED_TRIGGERSFindFirstArgs<ExtArgs>>): Prisma__QRTZ_FIRED_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_FIRED_TRIGGERS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_FIRED_TRIGGERSFindFirstOrThrowArgs} args - Arguments to find a QRTZ_FIRED_TRIGGERS
     * @example
     * // Get one QRTZ_FIRED_TRIGGERS
     * const qRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRTZ_FIRED_TRIGGERSFindFirstOrThrowArgs>(args?: SelectSubset<T, QRTZ_FIRED_TRIGGERSFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRTZ_FIRED_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRTZ_FIRED_TRIGGERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_FIRED_TRIGGERSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRTZ_FIRED_TRIGGERS
     * const qRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.findMany()
     * 
     * // Get first 10 QRTZ_FIRED_TRIGGERS
     * const qRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.findMany({ take: 10 })
     * 
     * // Only select the `SCHED_NAME`
     * const qRTZ_FIRED_TRIGGERSWithSCHED_NAMEOnly = await prisma.qRTZ_FIRED_TRIGGERS.findMany({ select: { SCHED_NAME: true } })
     * 
     */
    findMany<T extends QRTZ_FIRED_TRIGGERSFindManyArgs>(args?: SelectSubset<T, QRTZ_FIRED_TRIGGERSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRTZ_FIRED_TRIGGERS.
     * @param {QRTZ_FIRED_TRIGGERSCreateArgs} args - Arguments to create a QRTZ_FIRED_TRIGGERS.
     * @example
     * // Create one QRTZ_FIRED_TRIGGERS
     * const QRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.create({
     *   data: {
     *     // ... data to create a QRTZ_FIRED_TRIGGERS
     *   }
     * })
     * 
     */
    create<T extends QRTZ_FIRED_TRIGGERSCreateArgs>(args: SelectSubset<T, QRTZ_FIRED_TRIGGERSCreateArgs<ExtArgs>>): Prisma__QRTZ_FIRED_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRTZ_FIRED_TRIGGERS.
     * @param {QRTZ_FIRED_TRIGGERSCreateManyArgs} args - Arguments to create many QRTZ_FIRED_TRIGGERS.
     * @example
     * // Create many QRTZ_FIRED_TRIGGERS
     * const qRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRTZ_FIRED_TRIGGERSCreateManyArgs>(args?: SelectSubset<T, QRTZ_FIRED_TRIGGERSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QRTZ_FIRED_TRIGGERS.
     * @param {QRTZ_FIRED_TRIGGERSDeleteArgs} args - Arguments to delete one QRTZ_FIRED_TRIGGERS.
     * @example
     * // Delete one QRTZ_FIRED_TRIGGERS
     * const QRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.delete({
     *   where: {
     *     // ... filter to delete one QRTZ_FIRED_TRIGGERS
     *   }
     * })
     * 
     */
    delete<T extends QRTZ_FIRED_TRIGGERSDeleteArgs>(args: SelectSubset<T, QRTZ_FIRED_TRIGGERSDeleteArgs<ExtArgs>>): Prisma__QRTZ_FIRED_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRTZ_FIRED_TRIGGERS.
     * @param {QRTZ_FIRED_TRIGGERSUpdateArgs} args - Arguments to update one QRTZ_FIRED_TRIGGERS.
     * @example
     * // Update one QRTZ_FIRED_TRIGGERS
     * const qRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRTZ_FIRED_TRIGGERSUpdateArgs>(args: SelectSubset<T, QRTZ_FIRED_TRIGGERSUpdateArgs<ExtArgs>>): Prisma__QRTZ_FIRED_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRTZ_FIRED_TRIGGERS.
     * @param {QRTZ_FIRED_TRIGGERSDeleteManyArgs} args - Arguments to filter QRTZ_FIRED_TRIGGERS to delete.
     * @example
     * // Delete a few QRTZ_FIRED_TRIGGERS
     * const { count } = await prisma.qRTZ_FIRED_TRIGGERS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRTZ_FIRED_TRIGGERSDeleteManyArgs>(args?: SelectSubset<T, QRTZ_FIRED_TRIGGERSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRTZ_FIRED_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_FIRED_TRIGGERSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRTZ_FIRED_TRIGGERS
     * const qRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRTZ_FIRED_TRIGGERSUpdateManyArgs>(args: SelectSubset<T, QRTZ_FIRED_TRIGGERSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QRTZ_FIRED_TRIGGERS.
     * @param {QRTZ_FIRED_TRIGGERSUpsertArgs} args - Arguments to update or create a QRTZ_FIRED_TRIGGERS.
     * @example
     * // Update or create a QRTZ_FIRED_TRIGGERS
     * const qRTZ_FIRED_TRIGGERS = await prisma.qRTZ_FIRED_TRIGGERS.upsert({
     *   create: {
     *     // ... data to create a QRTZ_FIRED_TRIGGERS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRTZ_FIRED_TRIGGERS we want to update
     *   }
     * })
     */
    upsert<T extends QRTZ_FIRED_TRIGGERSUpsertArgs>(args: SelectSubset<T, QRTZ_FIRED_TRIGGERSUpsertArgs<ExtArgs>>): Prisma__QRTZ_FIRED_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_FIRED_TRIGGERSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRTZ_FIRED_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_FIRED_TRIGGERSCountArgs} args - Arguments to filter QRTZ_FIRED_TRIGGERS to count.
     * @example
     * // Count the number of QRTZ_FIRED_TRIGGERS
     * const count = await prisma.qRTZ_FIRED_TRIGGERS.count({
     *   where: {
     *     // ... the filter for the QRTZ_FIRED_TRIGGERS we want to count
     *   }
     * })
    **/
    count<T extends QRTZ_FIRED_TRIGGERSCountArgs>(
      args?: Subset<T, QRTZ_FIRED_TRIGGERSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRTZ_FIRED_TRIGGERSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRTZ_FIRED_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_FIRED_TRIGGERSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRTZ_FIRED_TRIGGERSAggregateArgs>(args: Subset<T, QRTZ_FIRED_TRIGGERSAggregateArgs>): Prisma.PrismaPromise<GetQRTZ_FIRED_TRIGGERSAggregateType<T>>

    /**
     * Group by QRTZ_FIRED_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_FIRED_TRIGGERSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRTZ_FIRED_TRIGGERSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRTZ_FIRED_TRIGGERSGroupByArgs['orderBy'] }
        : { orderBy?: QRTZ_FIRED_TRIGGERSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRTZ_FIRED_TRIGGERSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRTZ_FIRED_TRIGGERSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRTZ_FIRED_TRIGGERS model
   */
  readonly fields: QRTZ_FIRED_TRIGGERSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRTZ_FIRED_TRIGGERS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRTZ_FIRED_TRIGGERSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRTZ_FIRED_TRIGGERS model
   */
  interface QRTZ_FIRED_TRIGGERSFieldRefs {
    readonly SCHED_NAME: FieldRef<"QRTZ_FIRED_TRIGGERS", 'String'>
    readonly ENTRY_ID: FieldRef<"QRTZ_FIRED_TRIGGERS", 'String'>
    readonly TRIGGER_NAME: FieldRef<"QRTZ_FIRED_TRIGGERS", 'String'>
    readonly TRIGGER_GROUP: FieldRef<"QRTZ_FIRED_TRIGGERS", 'String'>
    readonly INSTANCE_NAME: FieldRef<"QRTZ_FIRED_TRIGGERS", 'String'>
    readonly FIRED_TIME: FieldRef<"QRTZ_FIRED_TRIGGERS", 'BigInt'>
    readonly SCHED_TIME: FieldRef<"QRTZ_FIRED_TRIGGERS", 'BigInt'>
    readonly PRIORITY: FieldRef<"QRTZ_FIRED_TRIGGERS", 'Int'>
    readonly STATE: FieldRef<"QRTZ_FIRED_TRIGGERS", 'String'>
    readonly JOB_NAME: FieldRef<"QRTZ_FIRED_TRIGGERS", 'String'>
    readonly JOB_GROUP: FieldRef<"QRTZ_FIRED_TRIGGERS", 'String'>
    readonly IS_NONCONCURRENT: FieldRef<"QRTZ_FIRED_TRIGGERS", 'String'>
    readonly REQUESTS_RECOVERY: FieldRef<"QRTZ_FIRED_TRIGGERS", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QRTZ_FIRED_TRIGGERS findUnique
   */
  export type QRTZ_FIRED_TRIGGERSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_FIRED_TRIGGERS
     */
    select?: QRTZ_FIRED_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_FIRED_TRIGGERS
     */
    omit?: QRTZ_FIRED_TRIGGERSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_FIRED_TRIGGERS to fetch.
     */
    where: QRTZ_FIRED_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_FIRED_TRIGGERS findUniqueOrThrow
   */
  export type QRTZ_FIRED_TRIGGERSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_FIRED_TRIGGERS
     */
    select?: QRTZ_FIRED_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_FIRED_TRIGGERS
     */
    omit?: QRTZ_FIRED_TRIGGERSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_FIRED_TRIGGERS to fetch.
     */
    where: QRTZ_FIRED_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_FIRED_TRIGGERS findFirst
   */
  export type QRTZ_FIRED_TRIGGERSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_FIRED_TRIGGERS
     */
    select?: QRTZ_FIRED_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_FIRED_TRIGGERS
     */
    omit?: QRTZ_FIRED_TRIGGERSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_FIRED_TRIGGERS to fetch.
     */
    where?: QRTZ_FIRED_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_FIRED_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_FIRED_TRIGGERSOrderByWithRelationInput | QRTZ_FIRED_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_FIRED_TRIGGERS.
     */
    cursor?: QRTZ_FIRED_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_FIRED_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_FIRED_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_FIRED_TRIGGERS.
     */
    distinct?: QRTZ_FIRED_TRIGGERSScalarFieldEnum | QRTZ_FIRED_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_FIRED_TRIGGERS findFirstOrThrow
   */
  export type QRTZ_FIRED_TRIGGERSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_FIRED_TRIGGERS
     */
    select?: QRTZ_FIRED_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_FIRED_TRIGGERS
     */
    omit?: QRTZ_FIRED_TRIGGERSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_FIRED_TRIGGERS to fetch.
     */
    where?: QRTZ_FIRED_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_FIRED_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_FIRED_TRIGGERSOrderByWithRelationInput | QRTZ_FIRED_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_FIRED_TRIGGERS.
     */
    cursor?: QRTZ_FIRED_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_FIRED_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_FIRED_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_FIRED_TRIGGERS.
     */
    distinct?: QRTZ_FIRED_TRIGGERSScalarFieldEnum | QRTZ_FIRED_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_FIRED_TRIGGERS findMany
   */
  export type QRTZ_FIRED_TRIGGERSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_FIRED_TRIGGERS
     */
    select?: QRTZ_FIRED_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_FIRED_TRIGGERS
     */
    omit?: QRTZ_FIRED_TRIGGERSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_FIRED_TRIGGERS to fetch.
     */
    where?: QRTZ_FIRED_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_FIRED_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_FIRED_TRIGGERSOrderByWithRelationInput | QRTZ_FIRED_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRTZ_FIRED_TRIGGERS.
     */
    cursor?: QRTZ_FIRED_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_FIRED_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_FIRED_TRIGGERS.
     */
    skip?: number
    distinct?: QRTZ_FIRED_TRIGGERSScalarFieldEnum | QRTZ_FIRED_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_FIRED_TRIGGERS create
   */
  export type QRTZ_FIRED_TRIGGERSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_FIRED_TRIGGERS
     */
    select?: QRTZ_FIRED_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_FIRED_TRIGGERS
     */
    omit?: QRTZ_FIRED_TRIGGERSOmit<ExtArgs> | null
    /**
     * The data needed to create a QRTZ_FIRED_TRIGGERS.
     */
    data: XOR<QRTZ_FIRED_TRIGGERSCreateInput, QRTZ_FIRED_TRIGGERSUncheckedCreateInput>
  }

  /**
   * QRTZ_FIRED_TRIGGERS createMany
   */
  export type QRTZ_FIRED_TRIGGERSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRTZ_FIRED_TRIGGERS.
     */
    data: QRTZ_FIRED_TRIGGERSCreateManyInput | QRTZ_FIRED_TRIGGERSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRTZ_FIRED_TRIGGERS update
   */
  export type QRTZ_FIRED_TRIGGERSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_FIRED_TRIGGERS
     */
    select?: QRTZ_FIRED_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_FIRED_TRIGGERS
     */
    omit?: QRTZ_FIRED_TRIGGERSOmit<ExtArgs> | null
    /**
     * The data needed to update a QRTZ_FIRED_TRIGGERS.
     */
    data: XOR<QRTZ_FIRED_TRIGGERSUpdateInput, QRTZ_FIRED_TRIGGERSUncheckedUpdateInput>
    /**
     * Choose, which QRTZ_FIRED_TRIGGERS to update.
     */
    where: QRTZ_FIRED_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_FIRED_TRIGGERS updateMany
   */
  export type QRTZ_FIRED_TRIGGERSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRTZ_FIRED_TRIGGERS.
     */
    data: XOR<QRTZ_FIRED_TRIGGERSUpdateManyMutationInput, QRTZ_FIRED_TRIGGERSUncheckedUpdateManyInput>
    /**
     * Filter which QRTZ_FIRED_TRIGGERS to update
     */
    where?: QRTZ_FIRED_TRIGGERSWhereInput
    /**
     * Limit how many QRTZ_FIRED_TRIGGERS to update.
     */
    limit?: number
  }

  /**
   * QRTZ_FIRED_TRIGGERS upsert
   */
  export type QRTZ_FIRED_TRIGGERSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_FIRED_TRIGGERS
     */
    select?: QRTZ_FIRED_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_FIRED_TRIGGERS
     */
    omit?: QRTZ_FIRED_TRIGGERSOmit<ExtArgs> | null
    /**
     * The filter to search for the QRTZ_FIRED_TRIGGERS to update in case it exists.
     */
    where: QRTZ_FIRED_TRIGGERSWhereUniqueInput
    /**
     * In case the QRTZ_FIRED_TRIGGERS found by the `where` argument doesn't exist, create a new QRTZ_FIRED_TRIGGERS with this data.
     */
    create: XOR<QRTZ_FIRED_TRIGGERSCreateInput, QRTZ_FIRED_TRIGGERSUncheckedCreateInput>
    /**
     * In case the QRTZ_FIRED_TRIGGERS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRTZ_FIRED_TRIGGERSUpdateInput, QRTZ_FIRED_TRIGGERSUncheckedUpdateInput>
  }

  /**
   * QRTZ_FIRED_TRIGGERS delete
   */
  export type QRTZ_FIRED_TRIGGERSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_FIRED_TRIGGERS
     */
    select?: QRTZ_FIRED_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_FIRED_TRIGGERS
     */
    omit?: QRTZ_FIRED_TRIGGERSOmit<ExtArgs> | null
    /**
     * Filter which QRTZ_FIRED_TRIGGERS to delete.
     */
    where: QRTZ_FIRED_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_FIRED_TRIGGERS deleteMany
   */
  export type QRTZ_FIRED_TRIGGERSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_FIRED_TRIGGERS to delete
     */
    where?: QRTZ_FIRED_TRIGGERSWhereInput
    /**
     * Limit how many QRTZ_FIRED_TRIGGERS to delete.
     */
    limit?: number
  }

  /**
   * QRTZ_FIRED_TRIGGERS without action
   */
  export type QRTZ_FIRED_TRIGGERSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_FIRED_TRIGGERS
     */
    select?: QRTZ_FIRED_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_FIRED_TRIGGERS
     */
    omit?: QRTZ_FIRED_TRIGGERSOmit<ExtArgs> | null
  }


  /**
   * Model QRTZ_JOB_DETAILS
   */

  export type AggregateQRTZ_JOB_DETAILS = {
    _count: QRTZ_JOB_DETAILSCountAggregateOutputType | null
    _min: QRTZ_JOB_DETAILSMinAggregateOutputType | null
    _max: QRTZ_JOB_DETAILSMaxAggregateOutputType | null
  }

  export type QRTZ_JOB_DETAILSMinAggregateOutputType = {
    SCHED_NAME: string | null
    JOB_NAME: string | null
    JOB_GROUP: string | null
    DESCRIPTION: string | null
    JOB_CLASS_NAME: string | null
    IS_DURABLE: string | null
    IS_NONCONCURRENT: string | null
    IS_UPDATE_DATA: string | null
    REQUESTS_RECOVERY: string | null
    JOB_DATA: Uint8Array | null
  }

  export type QRTZ_JOB_DETAILSMaxAggregateOutputType = {
    SCHED_NAME: string | null
    JOB_NAME: string | null
    JOB_GROUP: string | null
    DESCRIPTION: string | null
    JOB_CLASS_NAME: string | null
    IS_DURABLE: string | null
    IS_NONCONCURRENT: string | null
    IS_UPDATE_DATA: string | null
    REQUESTS_RECOVERY: string | null
    JOB_DATA: Uint8Array | null
  }

  export type QRTZ_JOB_DETAILSCountAggregateOutputType = {
    SCHED_NAME: number
    JOB_NAME: number
    JOB_GROUP: number
    DESCRIPTION: number
    JOB_CLASS_NAME: number
    IS_DURABLE: number
    IS_NONCONCURRENT: number
    IS_UPDATE_DATA: number
    REQUESTS_RECOVERY: number
    JOB_DATA: number
    _all: number
  }


  export type QRTZ_JOB_DETAILSMinAggregateInputType = {
    SCHED_NAME?: true
    JOB_NAME?: true
    JOB_GROUP?: true
    DESCRIPTION?: true
    JOB_CLASS_NAME?: true
    IS_DURABLE?: true
    IS_NONCONCURRENT?: true
    IS_UPDATE_DATA?: true
    REQUESTS_RECOVERY?: true
    JOB_DATA?: true
  }

  export type QRTZ_JOB_DETAILSMaxAggregateInputType = {
    SCHED_NAME?: true
    JOB_NAME?: true
    JOB_GROUP?: true
    DESCRIPTION?: true
    JOB_CLASS_NAME?: true
    IS_DURABLE?: true
    IS_NONCONCURRENT?: true
    IS_UPDATE_DATA?: true
    REQUESTS_RECOVERY?: true
    JOB_DATA?: true
  }

  export type QRTZ_JOB_DETAILSCountAggregateInputType = {
    SCHED_NAME?: true
    JOB_NAME?: true
    JOB_GROUP?: true
    DESCRIPTION?: true
    JOB_CLASS_NAME?: true
    IS_DURABLE?: true
    IS_NONCONCURRENT?: true
    IS_UPDATE_DATA?: true
    REQUESTS_RECOVERY?: true
    JOB_DATA?: true
    _all?: true
  }

  export type QRTZ_JOB_DETAILSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_JOB_DETAILS to aggregate.
     */
    where?: QRTZ_JOB_DETAILSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_JOB_DETAILS to fetch.
     */
    orderBy?: QRTZ_JOB_DETAILSOrderByWithRelationInput | QRTZ_JOB_DETAILSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRTZ_JOB_DETAILSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_JOB_DETAILS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_JOB_DETAILS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRTZ_JOB_DETAILS
    **/
    _count?: true | QRTZ_JOB_DETAILSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRTZ_JOB_DETAILSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRTZ_JOB_DETAILSMaxAggregateInputType
  }

  export type GetQRTZ_JOB_DETAILSAggregateType<T extends QRTZ_JOB_DETAILSAggregateArgs> = {
        [P in keyof T & keyof AggregateQRTZ_JOB_DETAILS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRTZ_JOB_DETAILS[P]>
      : GetScalarType<T[P], AggregateQRTZ_JOB_DETAILS[P]>
  }




  export type QRTZ_JOB_DETAILSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRTZ_JOB_DETAILSWhereInput
    orderBy?: QRTZ_JOB_DETAILSOrderByWithAggregationInput | QRTZ_JOB_DETAILSOrderByWithAggregationInput[]
    by: QRTZ_JOB_DETAILSScalarFieldEnum[] | QRTZ_JOB_DETAILSScalarFieldEnum
    having?: QRTZ_JOB_DETAILSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRTZ_JOB_DETAILSCountAggregateInputType | true
    _min?: QRTZ_JOB_DETAILSMinAggregateInputType
    _max?: QRTZ_JOB_DETAILSMaxAggregateInputType
  }

  export type QRTZ_JOB_DETAILSGroupByOutputType = {
    SCHED_NAME: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION: string | null
    JOB_CLASS_NAME: string
    IS_DURABLE: string
    IS_NONCONCURRENT: string
    IS_UPDATE_DATA: string
    REQUESTS_RECOVERY: string
    JOB_DATA: Uint8Array | null
    _count: QRTZ_JOB_DETAILSCountAggregateOutputType | null
    _min: QRTZ_JOB_DETAILSMinAggregateOutputType | null
    _max: QRTZ_JOB_DETAILSMaxAggregateOutputType | null
  }

  type GetQRTZ_JOB_DETAILSGroupByPayload<T extends QRTZ_JOB_DETAILSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRTZ_JOB_DETAILSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRTZ_JOB_DETAILSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRTZ_JOB_DETAILSGroupByOutputType[P]>
            : GetScalarType<T[P], QRTZ_JOB_DETAILSGroupByOutputType[P]>
        }
      >
    >


  export type QRTZ_JOB_DETAILSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SCHED_NAME?: boolean
    JOB_NAME?: boolean
    JOB_GROUP?: boolean
    DESCRIPTION?: boolean
    JOB_CLASS_NAME?: boolean
    IS_DURABLE?: boolean
    IS_NONCONCURRENT?: boolean
    IS_UPDATE_DATA?: boolean
    REQUESTS_RECOVERY?: boolean
    JOB_DATA?: boolean
    QRTZ_TRIGGERS?: boolean | QRTZ_JOB_DETAILS$QRTZ_TRIGGERSArgs<ExtArgs>
    _count?: boolean | QRTZ_JOB_DETAILSCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qRTZ_JOB_DETAILS"]>



  export type QRTZ_JOB_DETAILSSelectScalar = {
    SCHED_NAME?: boolean
    JOB_NAME?: boolean
    JOB_GROUP?: boolean
    DESCRIPTION?: boolean
    JOB_CLASS_NAME?: boolean
    IS_DURABLE?: boolean
    IS_NONCONCURRENT?: boolean
    IS_UPDATE_DATA?: boolean
    REQUESTS_RECOVERY?: boolean
    JOB_DATA?: boolean
  }

  export type QRTZ_JOB_DETAILSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SCHED_NAME" | "JOB_NAME" | "JOB_GROUP" | "DESCRIPTION" | "JOB_CLASS_NAME" | "IS_DURABLE" | "IS_NONCONCURRENT" | "IS_UPDATE_DATA" | "REQUESTS_RECOVERY" | "JOB_DATA", ExtArgs["result"]["qRTZ_JOB_DETAILS"]>
  export type QRTZ_JOB_DETAILSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QRTZ_TRIGGERS?: boolean | QRTZ_JOB_DETAILS$QRTZ_TRIGGERSArgs<ExtArgs>
    _count?: boolean | QRTZ_JOB_DETAILSCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $QRTZ_JOB_DETAILSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRTZ_JOB_DETAILS"
    objects: {
      QRTZ_TRIGGERS: Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      SCHED_NAME: string
      JOB_NAME: string
      JOB_GROUP: string
      DESCRIPTION: string | null
      JOB_CLASS_NAME: string
      IS_DURABLE: string
      IS_NONCONCURRENT: string
      IS_UPDATE_DATA: string
      REQUESTS_RECOVERY: string
      JOB_DATA: Uint8Array | null
    }, ExtArgs["result"]["qRTZ_JOB_DETAILS"]>
    composites: {}
  }

  type QRTZ_JOB_DETAILSGetPayload<S extends boolean | null | undefined | QRTZ_JOB_DETAILSDefaultArgs> = $Result.GetResult<Prisma.$QRTZ_JOB_DETAILSPayload, S>

  type QRTZ_JOB_DETAILSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRTZ_JOB_DETAILSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRTZ_JOB_DETAILSCountAggregateInputType | true
    }

  export interface QRTZ_JOB_DETAILSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRTZ_JOB_DETAILS'], meta: { name: 'QRTZ_JOB_DETAILS' } }
    /**
     * Find zero or one QRTZ_JOB_DETAILS that matches the filter.
     * @param {QRTZ_JOB_DETAILSFindUniqueArgs} args - Arguments to find a QRTZ_JOB_DETAILS
     * @example
     * // Get one QRTZ_JOB_DETAILS
     * const qRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRTZ_JOB_DETAILSFindUniqueArgs>(args: SelectSubset<T, QRTZ_JOB_DETAILSFindUniqueArgs<ExtArgs>>): Prisma__QRTZ_JOB_DETAILSClient<$Result.GetResult<Prisma.$QRTZ_JOB_DETAILSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRTZ_JOB_DETAILS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRTZ_JOB_DETAILSFindUniqueOrThrowArgs} args - Arguments to find a QRTZ_JOB_DETAILS
     * @example
     * // Get one QRTZ_JOB_DETAILS
     * const qRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRTZ_JOB_DETAILSFindUniqueOrThrowArgs>(args: SelectSubset<T, QRTZ_JOB_DETAILSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRTZ_JOB_DETAILSClient<$Result.GetResult<Prisma.$QRTZ_JOB_DETAILSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_JOB_DETAILS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_JOB_DETAILSFindFirstArgs} args - Arguments to find a QRTZ_JOB_DETAILS
     * @example
     * // Get one QRTZ_JOB_DETAILS
     * const qRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRTZ_JOB_DETAILSFindFirstArgs>(args?: SelectSubset<T, QRTZ_JOB_DETAILSFindFirstArgs<ExtArgs>>): Prisma__QRTZ_JOB_DETAILSClient<$Result.GetResult<Prisma.$QRTZ_JOB_DETAILSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_JOB_DETAILS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_JOB_DETAILSFindFirstOrThrowArgs} args - Arguments to find a QRTZ_JOB_DETAILS
     * @example
     * // Get one QRTZ_JOB_DETAILS
     * const qRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRTZ_JOB_DETAILSFindFirstOrThrowArgs>(args?: SelectSubset<T, QRTZ_JOB_DETAILSFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRTZ_JOB_DETAILSClient<$Result.GetResult<Prisma.$QRTZ_JOB_DETAILSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRTZ_JOB_DETAILS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_JOB_DETAILSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRTZ_JOB_DETAILS
     * const qRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.findMany()
     * 
     * // Get first 10 QRTZ_JOB_DETAILS
     * const qRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.findMany({ take: 10 })
     * 
     * // Only select the `SCHED_NAME`
     * const qRTZ_JOB_DETAILSWithSCHED_NAMEOnly = await prisma.qRTZ_JOB_DETAILS.findMany({ select: { SCHED_NAME: true } })
     * 
     */
    findMany<T extends QRTZ_JOB_DETAILSFindManyArgs>(args?: SelectSubset<T, QRTZ_JOB_DETAILSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRTZ_JOB_DETAILSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRTZ_JOB_DETAILS.
     * @param {QRTZ_JOB_DETAILSCreateArgs} args - Arguments to create a QRTZ_JOB_DETAILS.
     * @example
     * // Create one QRTZ_JOB_DETAILS
     * const QRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.create({
     *   data: {
     *     // ... data to create a QRTZ_JOB_DETAILS
     *   }
     * })
     * 
     */
    create<T extends QRTZ_JOB_DETAILSCreateArgs>(args: SelectSubset<T, QRTZ_JOB_DETAILSCreateArgs<ExtArgs>>): Prisma__QRTZ_JOB_DETAILSClient<$Result.GetResult<Prisma.$QRTZ_JOB_DETAILSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRTZ_JOB_DETAILS.
     * @param {QRTZ_JOB_DETAILSCreateManyArgs} args - Arguments to create many QRTZ_JOB_DETAILS.
     * @example
     * // Create many QRTZ_JOB_DETAILS
     * const qRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRTZ_JOB_DETAILSCreateManyArgs>(args?: SelectSubset<T, QRTZ_JOB_DETAILSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QRTZ_JOB_DETAILS.
     * @param {QRTZ_JOB_DETAILSDeleteArgs} args - Arguments to delete one QRTZ_JOB_DETAILS.
     * @example
     * // Delete one QRTZ_JOB_DETAILS
     * const QRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.delete({
     *   where: {
     *     // ... filter to delete one QRTZ_JOB_DETAILS
     *   }
     * })
     * 
     */
    delete<T extends QRTZ_JOB_DETAILSDeleteArgs>(args: SelectSubset<T, QRTZ_JOB_DETAILSDeleteArgs<ExtArgs>>): Prisma__QRTZ_JOB_DETAILSClient<$Result.GetResult<Prisma.$QRTZ_JOB_DETAILSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRTZ_JOB_DETAILS.
     * @param {QRTZ_JOB_DETAILSUpdateArgs} args - Arguments to update one QRTZ_JOB_DETAILS.
     * @example
     * // Update one QRTZ_JOB_DETAILS
     * const qRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRTZ_JOB_DETAILSUpdateArgs>(args: SelectSubset<T, QRTZ_JOB_DETAILSUpdateArgs<ExtArgs>>): Prisma__QRTZ_JOB_DETAILSClient<$Result.GetResult<Prisma.$QRTZ_JOB_DETAILSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRTZ_JOB_DETAILS.
     * @param {QRTZ_JOB_DETAILSDeleteManyArgs} args - Arguments to filter QRTZ_JOB_DETAILS to delete.
     * @example
     * // Delete a few QRTZ_JOB_DETAILS
     * const { count } = await prisma.qRTZ_JOB_DETAILS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRTZ_JOB_DETAILSDeleteManyArgs>(args?: SelectSubset<T, QRTZ_JOB_DETAILSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRTZ_JOB_DETAILS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_JOB_DETAILSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRTZ_JOB_DETAILS
     * const qRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRTZ_JOB_DETAILSUpdateManyArgs>(args: SelectSubset<T, QRTZ_JOB_DETAILSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QRTZ_JOB_DETAILS.
     * @param {QRTZ_JOB_DETAILSUpsertArgs} args - Arguments to update or create a QRTZ_JOB_DETAILS.
     * @example
     * // Update or create a QRTZ_JOB_DETAILS
     * const qRTZ_JOB_DETAILS = await prisma.qRTZ_JOB_DETAILS.upsert({
     *   create: {
     *     // ... data to create a QRTZ_JOB_DETAILS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRTZ_JOB_DETAILS we want to update
     *   }
     * })
     */
    upsert<T extends QRTZ_JOB_DETAILSUpsertArgs>(args: SelectSubset<T, QRTZ_JOB_DETAILSUpsertArgs<ExtArgs>>): Prisma__QRTZ_JOB_DETAILSClient<$Result.GetResult<Prisma.$QRTZ_JOB_DETAILSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRTZ_JOB_DETAILS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_JOB_DETAILSCountArgs} args - Arguments to filter QRTZ_JOB_DETAILS to count.
     * @example
     * // Count the number of QRTZ_JOB_DETAILS
     * const count = await prisma.qRTZ_JOB_DETAILS.count({
     *   where: {
     *     // ... the filter for the QRTZ_JOB_DETAILS we want to count
     *   }
     * })
    **/
    count<T extends QRTZ_JOB_DETAILSCountArgs>(
      args?: Subset<T, QRTZ_JOB_DETAILSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRTZ_JOB_DETAILSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRTZ_JOB_DETAILS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_JOB_DETAILSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRTZ_JOB_DETAILSAggregateArgs>(args: Subset<T, QRTZ_JOB_DETAILSAggregateArgs>): Prisma.PrismaPromise<GetQRTZ_JOB_DETAILSAggregateType<T>>

    /**
     * Group by QRTZ_JOB_DETAILS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_JOB_DETAILSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRTZ_JOB_DETAILSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRTZ_JOB_DETAILSGroupByArgs['orderBy'] }
        : { orderBy?: QRTZ_JOB_DETAILSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRTZ_JOB_DETAILSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRTZ_JOB_DETAILSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRTZ_JOB_DETAILS model
   */
  readonly fields: QRTZ_JOB_DETAILSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRTZ_JOB_DETAILS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRTZ_JOB_DETAILSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    QRTZ_TRIGGERS<T extends QRTZ_JOB_DETAILS$QRTZ_TRIGGERSArgs<ExtArgs> = {}>(args?: Subset<T, QRTZ_JOB_DETAILS$QRTZ_TRIGGERSArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRTZ_JOB_DETAILS model
   */
  interface QRTZ_JOB_DETAILSFieldRefs {
    readonly SCHED_NAME: FieldRef<"QRTZ_JOB_DETAILS", 'String'>
    readonly JOB_NAME: FieldRef<"QRTZ_JOB_DETAILS", 'String'>
    readonly JOB_GROUP: FieldRef<"QRTZ_JOB_DETAILS", 'String'>
    readonly DESCRIPTION: FieldRef<"QRTZ_JOB_DETAILS", 'String'>
    readonly JOB_CLASS_NAME: FieldRef<"QRTZ_JOB_DETAILS", 'String'>
    readonly IS_DURABLE: FieldRef<"QRTZ_JOB_DETAILS", 'String'>
    readonly IS_NONCONCURRENT: FieldRef<"QRTZ_JOB_DETAILS", 'String'>
    readonly IS_UPDATE_DATA: FieldRef<"QRTZ_JOB_DETAILS", 'String'>
    readonly REQUESTS_RECOVERY: FieldRef<"QRTZ_JOB_DETAILS", 'String'>
    readonly JOB_DATA: FieldRef<"QRTZ_JOB_DETAILS", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * QRTZ_JOB_DETAILS findUnique
   */
  export type QRTZ_JOB_DETAILSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_JOB_DETAILS
     */
    select?: QRTZ_JOB_DETAILSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_JOB_DETAILS
     */
    omit?: QRTZ_JOB_DETAILSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_JOB_DETAILSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_JOB_DETAILS to fetch.
     */
    where: QRTZ_JOB_DETAILSWhereUniqueInput
  }

  /**
   * QRTZ_JOB_DETAILS findUniqueOrThrow
   */
  export type QRTZ_JOB_DETAILSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_JOB_DETAILS
     */
    select?: QRTZ_JOB_DETAILSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_JOB_DETAILS
     */
    omit?: QRTZ_JOB_DETAILSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_JOB_DETAILSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_JOB_DETAILS to fetch.
     */
    where: QRTZ_JOB_DETAILSWhereUniqueInput
  }

  /**
   * QRTZ_JOB_DETAILS findFirst
   */
  export type QRTZ_JOB_DETAILSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_JOB_DETAILS
     */
    select?: QRTZ_JOB_DETAILSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_JOB_DETAILS
     */
    omit?: QRTZ_JOB_DETAILSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_JOB_DETAILSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_JOB_DETAILS to fetch.
     */
    where?: QRTZ_JOB_DETAILSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_JOB_DETAILS to fetch.
     */
    orderBy?: QRTZ_JOB_DETAILSOrderByWithRelationInput | QRTZ_JOB_DETAILSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_JOB_DETAILS.
     */
    cursor?: QRTZ_JOB_DETAILSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_JOB_DETAILS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_JOB_DETAILS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_JOB_DETAILS.
     */
    distinct?: QRTZ_JOB_DETAILSScalarFieldEnum | QRTZ_JOB_DETAILSScalarFieldEnum[]
  }

  /**
   * QRTZ_JOB_DETAILS findFirstOrThrow
   */
  export type QRTZ_JOB_DETAILSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_JOB_DETAILS
     */
    select?: QRTZ_JOB_DETAILSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_JOB_DETAILS
     */
    omit?: QRTZ_JOB_DETAILSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_JOB_DETAILSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_JOB_DETAILS to fetch.
     */
    where?: QRTZ_JOB_DETAILSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_JOB_DETAILS to fetch.
     */
    orderBy?: QRTZ_JOB_DETAILSOrderByWithRelationInput | QRTZ_JOB_DETAILSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_JOB_DETAILS.
     */
    cursor?: QRTZ_JOB_DETAILSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_JOB_DETAILS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_JOB_DETAILS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_JOB_DETAILS.
     */
    distinct?: QRTZ_JOB_DETAILSScalarFieldEnum | QRTZ_JOB_DETAILSScalarFieldEnum[]
  }

  /**
   * QRTZ_JOB_DETAILS findMany
   */
  export type QRTZ_JOB_DETAILSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_JOB_DETAILS
     */
    select?: QRTZ_JOB_DETAILSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_JOB_DETAILS
     */
    omit?: QRTZ_JOB_DETAILSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_JOB_DETAILSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_JOB_DETAILS to fetch.
     */
    where?: QRTZ_JOB_DETAILSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_JOB_DETAILS to fetch.
     */
    orderBy?: QRTZ_JOB_DETAILSOrderByWithRelationInput | QRTZ_JOB_DETAILSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRTZ_JOB_DETAILS.
     */
    cursor?: QRTZ_JOB_DETAILSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_JOB_DETAILS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_JOB_DETAILS.
     */
    skip?: number
    distinct?: QRTZ_JOB_DETAILSScalarFieldEnum | QRTZ_JOB_DETAILSScalarFieldEnum[]
  }

  /**
   * QRTZ_JOB_DETAILS create
   */
  export type QRTZ_JOB_DETAILSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_JOB_DETAILS
     */
    select?: QRTZ_JOB_DETAILSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_JOB_DETAILS
     */
    omit?: QRTZ_JOB_DETAILSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_JOB_DETAILSInclude<ExtArgs> | null
    /**
     * The data needed to create a QRTZ_JOB_DETAILS.
     */
    data: XOR<QRTZ_JOB_DETAILSCreateInput, QRTZ_JOB_DETAILSUncheckedCreateInput>
  }

  /**
   * QRTZ_JOB_DETAILS createMany
   */
  export type QRTZ_JOB_DETAILSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRTZ_JOB_DETAILS.
     */
    data: QRTZ_JOB_DETAILSCreateManyInput | QRTZ_JOB_DETAILSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRTZ_JOB_DETAILS update
   */
  export type QRTZ_JOB_DETAILSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_JOB_DETAILS
     */
    select?: QRTZ_JOB_DETAILSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_JOB_DETAILS
     */
    omit?: QRTZ_JOB_DETAILSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_JOB_DETAILSInclude<ExtArgs> | null
    /**
     * The data needed to update a QRTZ_JOB_DETAILS.
     */
    data: XOR<QRTZ_JOB_DETAILSUpdateInput, QRTZ_JOB_DETAILSUncheckedUpdateInput>
    /**
     * Choose, which QRTZ_JOB_DETAILS to update.
     */
    where: QRTZ_JOB_DETAILSWhereUniqueInput
  }

  /**
   * QRTZ_JOB_DETAILS updateMany
   */
  export type QRTZ_JOB_DETAILSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRTZ_JOB_DETAILS.
     */
    data: XOR<QRTZ_JOB_DETAILSUpdateManyMutationInput, QRTZ_JOB_DETAILSUncheckedUpdateManyInput>
    /**
     * Filter which QRTZ_JOB_DETAILS to update
     */
    where?: QRTZ_JOB_DETAILSWhereInput
    /**
     * Limit how many QRTZ_JOB_DETAILS to update.
     */
    limit?: number
  }

  /**
   * QRTZ_JOB_DETAILS upsert
   */
  export type QRTZ_JOB_DETAILSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_JOB_DETAILS
     */
    select?: QRTZ_JOB_DETAILSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_JOB_DETAILS
     */
    omit?: QRTZ_JOB_DETAILSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_JOB_DETAILSInclude<ExtArgs> | null
    /**
     * The filter to search for the QRTZ_JOB_DETAILS to update in case it exists.
     */
    where: QRTZ_JOB_DETAILSWhereUniqueInput
    /**
     * In case the QRTZ_JOB_DETAILS found by the `where` argument doesn't exist, create a new QRTZ_JOB_DETAILS with this data.
     */
    create: XOR<QRTZ_JOB_DETAILSCreateInput, QRTZ_JOB_DETAILSUncheckedCreateInput>
    /**
     * In case the QRTZ_JOB_DETAILS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRTZ_JOB_DETAILSUpdateInput, QRTZ_JOB_DETAILSUncheckedUpdateInput>
  }

  /**
   * QRTZ_JOB_DETAILS delete
   */
  export type QRTZ_JOB_DETAILSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_JOB_DETAILS
     */
    select?: QRTZ_JOB_DETAILSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_JOB_DETAILS
     */
    omit?: QRTZ_JOB_DETAILSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_JOB_DETAILSInclude<ExtArgs> | null
    /**
     * Filter which QRTZ_JOB_DETAILS to delete.
     */
    where: QRTZ_JOB_DETAILSWhereUniqueInput
  }

  /**
   * QRTZ_JOB_DETAILS deleteMany
   */
  export type QRTZ_JOB_DETAILSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_JOB_DETAILS to delete
     */
    where?: QRTZ_JOB_DETAILSWhereInput
    /**
     * Limit how many QRTZ_JOB_DETAILS to delete.
     */
    limit?: number
  }

  /**
   * QRTZ_JOB_DETAILS.QRTZ_TRIGGERS
   */
  export type QRTZ_JOB_DETAILS$QRTZ_TRIGGERSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_TRIGGERS
     */
    select?: QRTZ_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_TRIGGERS
     */
    omit?: QRTZ_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_TRIGGERSInclude<ExtArgs> | null
    where?: QRTZ_TRIGGERSWhereInput
    orderBy?: QRTZ_TRIGGERSOrderByWithRelationInput | QRTZ_TRIGGERSOrderByWithRelationInput[]
    cursor?: QRTZ_TRIGGERSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QRTZ_TRIGGERSScalarFieldEnum | QRTZ_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_JOB_DETAILS without action
   */
  export type QRTZ_JOB_DETAILSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_JOB_DETAILS
     */
    select?: QRTZ_JOB_DETAILSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_JOB_DETAILS
     */
    omit?: QRTZ_JOB_DETAILSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_JOB_DETAILSInclude<ExtArgs> | null
  }


  /**
   * Model QRTZ_LOCKS
   */

  export type AggregateQRTZ_LOCKS = {
    _count: QRTZ_LOCKSCountAggregateOutputType | null
    _min: QRTZ_LOCKSMinAggregateOutputType | null
    _max: QRTZ_LOCKSMaxAggregateOutputType | null
  }

  export type QRTZ_LOCKSMinAggregateOutputType = {
    SCHED_NAME: string | null
    LOCK_NAME: string | null
  }

  export type QRTZ_LOCKSMaxAggregateOutputType = {
    SCHED_NAME: string | null
    LOCK_NAME: string | null
  }

  export type QRTZ_LOCKSCountAggregateOutputType = {
    SCHED_NAME: number
    LOCK_NAME: number
    _all: number
  }


  export type QRTZ_LOCKSMinAggregateInputType = {
    SCHED_NAME?: true
    LOCK_NAME?: true
  }

  export type QRTZ_LOCKSMaxAggregateInputType = {
    SCHED_NAME?: true
    LOCK_NAME?: true
  }

  export type QRTZ_LOCKSCountAggregateInputType = {
    SCHED_NAME?: true
    LOCK_NAME?: true
    _all?: true
  }

  export type QRTZ_LOCKSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_LOCKS to aggregate.
     */
    where?: QRTZ_LOCKSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_LOCKS to fetch.
     */
    orderBy?: QRTZ_LOCKSOrderByWithRelationInput | QRTZ_LOCKSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRTZ_LOCKSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_LOCKS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_LOCKS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRTZ_LOCKS
    **/
    _count?: true | QRTZ_LOCKSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRTZ_LOCKSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRTZ_LOCKSMaxAggregateInputType
  }

  export type GetQRTZ_LOCKSAggregateType<T extends QRTZ_LOCKSAggregateArgs> = {
        [P in keyof T & keyof AggregateQRTZ_LOCKS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRTZ_LOCKS[P]>
      : GetScalarType<T[P], AggregateQRTZ_LOCKS[P]>
  }




  export type QRTZ_LOCKSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRTZ_LOCKSWhereInput
    orderBy?: QRTZ_LOCKSOrderByWithAggregationInput | QRTZ_LOCKSOrderByWithAggregationInput[]
    by: QRTZ_LOCKSScalarFieldEnum[] | QRTZ_LOCKSScalarFieldEnum
    having?: QRTZ_LOCKSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRTZ_LOCKSCountAggregateInputType | true
    _min?: QRTZ_LOCKSMinAggregateInputType
    _max?: QRTZ_LOCKSMaxAggregateInputType
  }

  export type QRTZ_LOCKSGroupByOutputType = {
    SCHED_NAME: string
    LOCK_NAME: string
    _count: QRTZ_LOCKSCountAggregateOutputType | null
    _min: QRTZ_LOCKSMinAggregateOutputType | null
    _max: QRTZ_LOCKSMaxAggregateOutputType | null
  }

  type GetQRTZ_LOCKSGroupByPayload<T extends QRTZ_LOCKSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRTZ_LOCKSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRTZ_LOCKSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRTZ_LOCKSGroupByOutputType[P]>
            : GetScalarType<T[P], QRTZ_LOCKSGroupByOutputType[P]>
        }
      >
    >


  export type QRTZ_LOCKSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SCHED_NAME?: boolean
    LOCK_NAME?: boolean
  }, ExtArgs["result"]["qRTZ_LOCKS"]>



  export type QRTZ_LOCKSSelectScalar = {
    SCHED_NAME?: boolean
    LOCK_NAME?: boolean
  }

  export type QRTZ_LOCKSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SCHED_NAME" | "LOCK_NAME", ExtArgs["result"]["qRTZ_LOCKS"]>

  export type $QRTZ_LOCKSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRTZ_LOCKS"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SCHED_NAME: string
      LOCK_NAME: string
    }, ExtArgs["result"]["qRTZ_LOCKS"]>
    composites: {}
  }

  type QRTZ_LOCKSGetPayload<S extends boolean | null | undefined | QRTZ_LOCKSDefaultArgs> = $Result.GetResult<Prisma.$QRTZ_LOCKSPayload, S>

  type QRTZ_LOCKSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRTZ_LOCKSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRTZ_LOCKSCountAggregateInputType | true
    }

  export interface QRTZ_LOCKSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRTZ_LOCKS'], meta: { name: 'QRTZ_LOCKS' } }
    /**
     * Find zero or one QRTZ_LOCKS that matches the filter.
     * @param {QRTZ_LOCKSFindUniqueArgs} args - Arguments to find a QRTZ_LOCKS
     * @example
     * // Get one QRTZ_LOCKS
     * const qRTZ_LOCKS = await prisma.qRTZ_LOCKS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRTZ_LOCKSFindUniqueArgs>(args: SelectSubset<T, QRTZ_LOCKSFindUniqueArgs<ExtArgs>>): Prisma__QRTZ_LOCKSClient<$Result.GetResult<Prisma.$QRTZ_LOCKSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRTZ_LOCKS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRTZ_LOCKSFindUniqueOrThrowArgs} args - Arguments to find a QRTZ_LOCKS
     * @example
     * // Get one QRTZ_LOCKS
     * const qRTZ_LOCKS = await prisma.qRTZ_LOCKS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRTZ_LOCKSFindUniqueOrThrowArgs>(args: SelectSubset<T, QRTZ_LOCKSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRTZ_LOCKSClient<$Result.GetResult<Prisma.$QRTZ_LOCKSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_LOCKS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_LOCKSFindFirstArgs} args - Arguments to find a QRTZ_LOCKS
     * @example
     * // Get one QRTZ_LOCKS
     * const qRTZ_LOCKS = await prisma.qRTZ_LOCKS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRTZ_LOCKSFindFirstArgs>(args?: SelectSubset<T, QRTZ_LOCKSFindFirstArgs<ExtArgs>>): Prisma__QRTZ_LOCKSClient<$Result.GetResult<Prisma.$QRTZ_LOCKSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_LOCKS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_LOCKSFindFirstOrThrowArgs} args - Arguments to find a QRTZ_LOCKS
     * @example
     * // Get one QRTZ_LOCKS
     * const qRTZ_LOCKS = await prisma.qRTZ_LOCKS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRTZ_LOCKSFindFirstOrThrowArgs>(args?: SelectSubset<T, QRTZ_LOCKSFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRTZ_LOCKSClient<$Result.GetResult<Prisma.$QRTZ_LOCKSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRTZ_LOCKS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_LOCKSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRTZ_LOCKS
     * const qRTZ_LOCKS = await prisma.qRTZ_LOCKS.findMany()
     * 
     * // Get first 10 QRTZ_LOCKS
     * const qRTZ_LOCKS = await prisma.qRTZ_LOCKS.findMany({ take: 10 })
     * 
     * // Only select the `SCHED_NAME`
     * const qRTZ_LOCKSWithSCHED_NAMEOnly = await prisma.qRTZ_LOCKS.findMany({ select: { SCHED_NAME: true } })
     * 
     */
    findMany<T extends QRTZ_LOCKSFindManyArgs>(args?: SelectSubset<T, QRTZ_LOCKSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRTZ_LOCKSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRTZ_LOCKS.
     * @param {QRTZ_LOCKSCreateArgs} args - Arguments to create a QRTZ_LOCKS.
     * @example
     * // Create one QRTZ_LOCKS
     * const QRTZ_LOCKS = await prisma.qRTZ_LOCKS.create({
     *   data: {
     *     // ... data to create a QRTZ_LOCKS
     *   }
     * })
     * 
     */
    create<T extends QRTZ_LOCKSCreateArgs>(args: SelectSubset<T, QRTZ_LOCKSCreateArgs<ExtArgs>>): Prisma__QRTZ_LOCKSClient<$Result.GetResult<Prisma.$QRTZ_LOCKSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRTZ_LOCKS.
     * @param {QRTZ_LOCKSCreateManyArgs} args - Arguments to create many QRTZ_LOCKS.
     * @example
     * // Create many QRTZ_LOCKS
     * const qRTZ_LOCKS = await prisma.qRTZ_LOCKS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRTZ_LOCKSCreateManyArgs>(args?: SelectSubset<T, QRTZ_LOCKSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QRTZ_LOCKS.
     * @param {QRTZ_LOCKSDeleteArgs} args - Arguments to delete one QRTZ_LOCKS.
     * @example
     * // Delete one QRTZ_LOCKS
     * const QRTZ_LOCKS = await prisma.qRTZ_LOCKS.delete({
     *   where: {
     *     // ... filter to delete one QRTZ_LOCKS
     *   }
     * })
     * 
     */
    delete<T extends QRTZ_LOCKSDeleteArgs>(args: SelectSubset<T, QRTZ_LOCKSDeleteArgs<ExtArgs>>): Prisma__QRTZ_LOCKSClient<$Result.GetResult<Prisma.$QRTZ_LOCKSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRTZ_LOCKS.
     * @param {QRTZ_LOCKSUpdateArgs} args - Arguments to update one QRTZ_LOCKS.
     * @example
     * // Update one QRTZ_LOCKS
     * const qRTZ_LOCKS = await prisma.qRTZ_LOCKS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRTZ_LOCKSUpdateArgs>(args: SelectSubset<T, QRTZ_LOCKSUpdateArgs<ExtArgs>>): Prisma__QRTZ_LOCKSClient<$Result.GetResult<Prisma.$QRTZ_LOCKSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRTZ_LOCKS.
     * @param {QRTZ_LOCKSDeleteManyArgs} args - Arguments to filter QRTZ_LOCKS to delete.
     * @example
     * // Delete a few QRTZ_LOCKS
     * const { count } = await prisma.qRTZ_LOCKS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRTZ_LOCKSDeleteManyArgs>(args?: SelectSubset<T, QRTZ_LOCKSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRTZ_LOCKS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_LOCKSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRTZ_LOCKS
     * const qRTZ_LOCKS = await prisma.qRTZ_LOCKS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRTZ_LOCKSUpdateManyArgs>(args: SelectSubset<T, QRTZ_LOCKSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QRTZ_LOCKS.
     * @param {QRTZ_LOCKSUpsertArgs} args - Arguments to update or create a QRTZ_LOCKS.
     * @example
     * // Update or create a QRTZ_LOCKS
     * const qRTZ_LOCKS = await prisma.qRTZ_LOCKS.upsert({
     *   create: {
     *     // ... data to create a QRTZ_LOCKS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRTZ_LOCKS we want to update
     *   }
     * })
     */
    upsert<T extends QRTZ_LOCKSUpsertArgs>(args: SelectSubset<T, QRTZ_LOCKSUpsertArgs<ExtArgs>>): Prisma__QRTZ_LOCKSClient<$Result.GetResult<Prisma.$QRTZ_LOCKSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRTZ_LOCKS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_LOCKSCountArgs} args - Arguments to filter QRTZ_LOCKS to count.
     * @example
     * // Count the number of QRTZ_LOCKS
     * const count = await prisma.qRTZ_LOCKS.count({
     *   where: {
     *     // ... the filter for the QRTZ_LOCKS we want to count
     *   }
     * })
    **/
    count<T extends QRTZ_LOCKSCountArgs>(
      args?: Subset<T, QRTZ_LOCKSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRTZ_LOCKSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRTZ_LOCKS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_LOCKSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRTZ_LOCKSAggregateArgs>(args: Subset<T, QRTZ_LOCKSAggregateArgs>): Prisma.PrismaPromise<GetQRTZ_LOCKSAggregateType<T>>

    /**
     * Group by QRTZ_LOCKS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_LOCKSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRTZ_LOCKSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRTZ_LOCKSGroupByArgs['orderBy'] }
        : { orderBy?: QRTZ_LOCKSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRTZ_LOCKSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRTZ_LOCKSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRTZ_LOCKS model
   */
  readonly fields: QRTZ_LOCKSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRTZ_LOCKS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRTZ_LOCKSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRTZ_LOCKS model
   */
  interface QRTZ_LOCKSFieldRefs {
    readonly SCHED_NAME: FieldRef<"QRTZ_LOCKS", 'String'>
    readonly LOCK_NAME: FieldRef<"QRTZ_LOCKS", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QRTZ_LOCKS findUnique
   */
  export type QRTZ_LOCKSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_LOCKS
     */
    select?: QRTZ_LOCKSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_LOCKS
     */
    omit?: QRTZ_LOCKSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_LOCKS to fetch.
     */
    where: QRTZ_LOCKSWhereUniqueInput
  }

  /**
   * QRTZ_LOCKS findUniqueOrThrow
   */
  export type QRTZ_LOCKSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_LOCKS
     */
    select?: QRTZ_LOCKSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_LOCKS
     */
    omit?: QRTZ_LOCKSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_LOCKS to fetch.
     */
    where: QRTZ_LOCKSWhereUniqueInput
  }

  /**
   * QRTZ_LOCKS findFirst
   */
  export type QRTZ_LOCKSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_LOCKS
     */
    select?: QRTZ_LOCKSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_LOCKS
     */
    omit?: QRTZ_LOCKSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_LOCKS to fetch.
     */
    where?: QRTZ_LOCKSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_LOCKS to fetch.
     */
    orderBy?: QRTZ_LOCKSOrderByWithRelationInput | QRTZ_LOCKSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_LOCKS.
     */
    cursor?: QRTZ_LOCKSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_LOCKS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_LOCKS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_LOCKS.
     */
    distinct?: QRTZ_LOCKSScalarFieldEnum | QRTZ_LOCKSScalarFieldEnum[]
  }

  /**
   * QRTZ_LOCKS findFirstOrThrow
   */
  export type QRTZ_LOCKSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_LOCKS
     */
    select?: QRTZ_LOCKSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_LOCKS
     */
    omit?: QRTZ_LOCKSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_LOCKS to fetch.
     */
    where?: QRTZ_LOCKSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_LOCKS to fetch.
     */
    orderBy?: QRTZ_LOCKSOrderByWithRelationInput | QRTZ_LOCKSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_LOCKS.
     */
    cursor?: QRTZ_LOCKSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_LOCKS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_LOCKS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_LOCKS.
     */
    distinct?: QRTZ_LOCKSScalarFieldEnum | QRTZ_LOCKSScalarFieldEnum[]
  }

  /**
   * QRTZ_LOCKS findMany
   */
  export type QRTZ_LOCKSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_LOCKS
     */
    select?: QRTZ_LOCKSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_LOCKS
     */
    omit?: QRTZ_LOCKSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_LOCKS to fetch.
     */
    where?: QRTZ_LOCKSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_LOCKS to fetch.
     */
    orderBy?: QRTZ_LOCKSOrderByWithRelationInput | QRTZ_LOCKSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRTZ_LOCKS.
     */
    cursor?: QRTZ_LOCKSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_LOCKS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_LOCKS.
     */
    skip?: number
    distinct?: QRTZ_LOCKSScalarFieldEnum | QRTZ_LOCKSScalarFieldEnum[]
  }

  /**
   * QRTZ_LOCKS create
   */
  export type QRTZ_LOCKSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_LOCKS
     */
    select?: QRTZ_LOCKSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_LOCKS
     */
    omit?: QRTZ_LOCKSOmit<ExtArgs> | null
    /**
     * The data needed to create a QRTZ_LOCKS.
     */
    data: XOR<QRTZ_LOCKSCreateInput, QRTZ_LOCKSUncheckedCreateInput>
  }

  /**
   * QRTZ_LOCKS createMany
   */
  export type QRTZ_LOCKSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRTZ_LOCKS.
     */
    data: QRTZ_LOCKSCreateManyInput | QRTZ_LOCKSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRTZ_LOCKS update
   */
  export type QRTZ_LOCKSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_LOCKS
     */
    select?: QRTZ_LOCKSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_LOCKS
     */
    omit?: QRTZ_LOCKSOmit<ExtArgs> | null
    /**
     * The data needed to update a QRTZ_LOCKS.
     */
    data: XOR<QRTZ_LOCKSUpdateInput, QRTZ_LOCKSUncheckedUpdateInput>
    /**
     * Choose, which QRTZ_LOCKS to update.
     */
    where: QRTZ_LOCKSWhereUniqueInput
  }

  /**
   * QRTZ_LOCKS updateMany
   */
  export type QRTZ_LOCKSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRTZ_LOCKS.
     */
    data: XOR<QRTZ_LOCKSUpdateManyMutationInput, QRTZ_LOCKSUncheckedUpdateManyInput>
    /**
     * Filter which QRTZ_LOCKS to update
     */
    where?: QRTZ_LOCKSWhereInput
    /**
     * Limit how many QRTZ_LOCKS to update.
     */
    limit?: number
  }

  /**
   * QRTZ_LOCKS upsert
   */
  export type QRTZ_LOCKSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_LOCKS
     */
    select?: QRTZ_LOCKSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_LOCKS
     */
    omit?: QRTZ_LOCKSOmit<ExtArgs> | null
    /**
     * The filter to search for the QRTZ_LOCKS to update in case it exists.
     */
    where: QRTZ_LOCKSWhereUniqueInput
    /**
     * In case the QRTZ_LOCKS found by the `where` argument doesn't exist, create a new QRTZ_LOCKS with this data.
     */
    create: XOR<QRTZ_LOCKSCreateInput, QRTZ_LOCKSUncheckedCreateInput>
    /**
     * In case the QRTZ_LOCKS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRTZ_LOCKSUpdateInput, QRTZ_LOCKSUncheckedUpdateInput>
  }

  /**
   * QRTZ_LOCKS delete
   */
  export type QRTZ_LOCKSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_LOCKS
     */
    select?: QRTZ_LOCKSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_LOCKS
     */
    omit?: QRTZ_LOCKSOmit<ExtArgs> | null
    /**
     * Filter which QRTZ_LOCKS to delete.
     */
    where: QRTZ_LOCKSWhereUniqueInput
  }

  /**
   * QRTZ_LOCKS deleteMany
   */
  export type QRTZ_LOCKSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_LOCKS to delete
     */
    where?: QRTZ_LOCKSWhereInput
    /**
     * Limit how many QRTZ_LOCKS to delete.
     */
    limit?: number
  }

  /**
   * QRTZ_LOCKS without action
   */
  export type QRTZ_LOCKSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_LOCKS
     */
    select?: QRTZ_LOCKSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_LOCKS
     */
    omit?: QRTZ_LOCKSOmit<ExtArgs> | null
  }


  /**
   * Model QRTZ_PAUSED_TRIGGER_GRPS
   */

  export type AggregateQRTZ_PAUSED_TRIGGER_GRPS = {
    _count: QRTZ_PAUSED_TRIGGER_GRPSCountAggregateOutputType | null
    _min: QRTZ_PAUSED_TRIGGER_GRPSMinAggregateOutputType | null
    _max: QRTZ_PAUSED_TRIGGER_GRPSMaxAggregateOutputType | null
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSMinAggregateOutputType = {
    SCHED_NAME: string | null
    TRIGGER_GROUP: string | null
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSMaxAggregateOutputType = {
    SCHED_NAME: string | null
    TRIGGER_GROUP: string | null
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSCountAggregateOutputType = {
    SCHED_NAME: number
    TRIGGER_GROUP: number
    _all: number
  }


  export type QRTZ_PAUSED_TRIGGER_GRPSMinAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_GROUP?: true
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSMaxAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_GROUP?: true
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSCountAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_GROUP?: true
    _all?: true
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_PAUSED_TRIGGER_GRPS to aggregate.
     */
    where?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_PAUSED_TRIGGER_GRPS to fetch.
     */
    orderBy?: QRTZ_PAUSED_TRIGGER_GRPSOrderByWithRelationInput | QRTZ_PAUSED_TRIGGER_GRPSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRTZ_PAUSED_TRIGGER_GRPSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_PAUSED_TRIGGER_GRPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_PAUSED_TRIGGER_GRPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRTZ_PAUSED_TRIGGER_GRPS
    **/
    _count?: true | QRTZ_PAUSED_TRIGGER_GRPSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRTZ_PAUSED_TRIGGER_GRPSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRTZ_PAUSED_TRIGGER_GRPSMaxAggregateInputType
  }

  export type GetQRTZ_PAUSED_TRIGGER_GRPSAggregateType<T extends QRTZ_PAUSED_TRIGGER_GRPSAggregateArgs> = {
        [P in keyof T & keyof AggregateQRTZ_PAUSED_TRIGGER_GRPS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRTZ_PAUSED_TRIGGER_GRPS[P]>
      : GetScalarType<T[P], AggregateQRTZ_PAUSED_TRIGGER_GRPS[P]>
  }




  export type QRTZ_PAUSED_TRIGGER_GRPSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput
    orderBy?: QRTZ_PAUSED_TRIGGER_GRPSOrderByWithAggregationInput | QRTZ_PAUSED_TRIGGER_GRPSOrderByWithAggregationInput[]
    by: QRTZ_PAUSED_TRIGGER_GRPSScalarFieldEnum[] | QRTZ_PAUSED_TRIGGER_GRPSScalarFieldEnum
    having?: QRTZ_PAUSED_TRIGGER_GRPSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRTZ_PAUSED_TRIGGER_GRPSCountAggregateInputType | true
    _min?: QRTZ_PAUSED_TRIGGER_GRPSMinAggregateInputType
    _max?: QRTZ_PAUSED_TRIGGER_GRPSMaxAggregateInputType
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSGroupByOutputType = {
    SCHED_NAME: string
    TRIGGER_GROUP: string
    _count: QRTZ_PAUSED_TRIGGER_GRPSCountAggregateOutputType | null
    _min: QRTZ_PAUSED_TRIGGER_GRPSMinAggregateOutputType | null
    _max: QRTZ_PAUSED_TRIGGER_GRPSMaxAggregateOutputType | null
  }

  type GetQRTZ_PAUSED_TRIGGER_GRPSGroupByPayload<T extends QRTZ_PAUSED_TRIGGER_GRPSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRTZ_PAUSED_TRIGGER_GRPSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRTZ_PAUSED_TRIGGER_GRPSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRTZ_PAUSED_TRIGGER_GRPSGroupByOutputType[P]>
            : GetScalarType<T[P], QRTZ_PAUSED_TRIGGER_GRPSGroupByOutputType[P]>
        }
      >
    >


  export type QRTZ_PAUSED_TRIGGER_GRPSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SCHED_NAME?: boolean
    TRIGGER_GROUP?: boolean
  }, ExtArgs["result"]["qRTZ_PAUSED_TRIGGER_GRPS"]>



  export type QRTZ_PAUSED_TRIGGER_GRPSSelectScalar = {
    SCHED_NAME?: boolean
    TRIGGER_GROUP?: boolean
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SCHED_NAME" | "TRIGGER_GROUP", ExtArgs["result"]["qRTZ_PAUSED_TRIGGER_GRPS"]>

  export type $QRTZ_PAUSED_TRIGGER_GRPSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRTZ_PAUSED_TRIGGER_GRPS"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SCHED_NAME: string
      TRIGGER_GROUP: string
    }, ExtArgs["result"]["qRTZ_PAUSED_TRIGGER_GRPS"]>
    composites: {}
  }

  type QRTZ_PAUSED_TRIGGER_GRPSGetPayload<S extends boolean | null | undefined | QRTZ_PAUSED_TRIGGER_GRPSDefaultArgs> = $Result.GetResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload, S>

  type QRTZ_PAUSED_TRIGGER_GRPSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRTZ_PAUSED_TRIGGER_GRPSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRTZ_PAUSED_TRIGGER_GRPSCountAggregateInputType | true
    }

  export interface QRTZ_PAUSED_TRIGGER_GRPSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRTZ_PAUSED_TRIGGER_GRPS'], meta: { name: 'QRTZ_PAUSED_TRIGGER_GRPS' } }
    /**
     * Find zero or one QRTZ_PAUSED_TRIGGER_GRPS that matches the filter.
     * @param {QRTZ_PAUSED_TRIGGER_GRPSFindUniqueArgs} args - Arguments to find a QRTZ_PAUSED_TRIGGER_GRPS
     * @example
     * // Get one QRTZ_PAUSED_TRIGGER_GRPS
     * const qRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRTZ_PAUSED_TRIGGER_GRPSFindUniqueArgs>(args: SelectSubset<T, QRTZ_PAUSED_TRIGGER_GRPSFindUniqueArgs<ExtArgs>>): Prisma__QRTZ_PAUSED_TRIGGER_GRPSClient<$Result.GetResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRTZ_PAUSED_TRIGGER_GRPS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRTZ_PAUSED_TRIGGER_GRPSFindUniqueOrThrowArgs} args - Arguments to find a QRTZ_PAUSED_TRIGGER_GRPS
     * @example
     * // Get one QRTZ_PAUSED_TRIGGER_GRPS
     * const qRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRTZ_PAUSED_TRIGGER_GRPSFindUniqueOrThrowArgs>(args: SelectSubset<T, QRTZ_PAUSED_TRIGGER_GRPSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRTZ_PAUSED_TRIGGER_GRPSClient<$Result.GetResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_PAUSED_TRIGGER_GRPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_PAUSED_TRIGGER_GRPSFindFirstArgs} args - Arguments to find a QRTZ_PAUSED_TRIGGER_GRPS
     * @example
     * // Get one QRTZ_PAUSED_TRIGGER_GRPS
     * const qRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRTZ_PAUSED_TRIGGER_GRPSFindFirstArgs>(args?: SelectSubset<T, QRTZ_PAUSED_TRIGGER_GRPSFindFirstArgs<ExtArgs>>): Prisma__QRTZ_PAUSED_TRIGGER_GRPSClient<$Result.GetResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_PAUSED_TRIGGER_GRPS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_PAUSED_TRIGGER_GRPSFindFirstOrThrowArgs} args - Arguments to find a QRTZ_PAUSED_TRIGGER_GRPS
     * @example
     * // Get one QRTZ_PAUSED_TRIGGER_GRPS
     * const qRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRTZ_PAUSED_TRIGGER_GRPSFindFirstOrThrowArgs>(args?: SelectSubset<T, QRTZ_PAUSED_TRIGGER_GRPSFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRTZ_PAUSED_TRIGGER_GRPSClient<$Result.GetResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRTZ_PAUSED_TRIGGER_GRPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_PAUSED_TRIGGER_GRPSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRTZ_PAUSED_TRIGGER_GRPS
     * const qRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.findMany()
     * 
     * // Get first 10 QRTZ_PAUSED_TRIGGER_GRPS
     * const qRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.findMany({ take: 10 })
     * 
     * // Only select the `SCHED_NAME`
     * const qRTZ_PAUSED_TRIGGER_GRPSWithSCHED_NAMEOnly = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.findMany({ select: { SCHED_NAME: true } })
     * 
     */
    findMany<T extends QRTZ_PAUSED_TRIGGER_GRPSFindManyArgs>(args?: SelectSubset<T, QRTZ_PAUSED_TRIGGER_GRPSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRTZ_PAUSED_TRIGGER_GRPS.
     * @param {QRTZ_PAUSED_TRIGGER_GRPSCreateArgs} args - Arguments to create a QRTZ_PAUSED_TRIGGER_GRPS.
     * @example
     * // Create one QRTZ_PAUSED_TRIGGER_GRPS
     * const QRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.create({
     *   data: {
     *     // ... data to create a QRTZ_PAUSED_TRIGGER_GRPS
     *   }
     * })
     * 
     */
    create<T extends QRTZ_PAUSED_TRIGGER_GRPSCreateArgs>(args: SelectSubset<T, QRTZ_PAUSED_TRIGGER_GRPSCreateArgs<ExtArgs>>): Prisma__QRTZ_PAUSED_TRIGGER_GRPSClient<$Result.GetResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRTZ_PAUSED_TRIGGER_GRPS.
     * @param {QRTZ_PAUSED_TRIGGER_GRPSCreateManyArgs} args - Arguments to create many QRTZ_PAUSED_TRIGGER_GRPS.
     * @example
     * // Create many QRTZ_PAUSED_TRIGGER_GRPS
     * const qRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRTZ_PAUSED_TRIGGER_GRPSCreateManyArgs>(args?: SelectSubset<T, QRTZ_PAUSED_TRIGGER_GRPSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QRTZ_PAUSED_TRIGGER_GRPS.
     * @param {QRTZ_PAUSED_TRIGGER_GRPSDeleteArgs} args - Arguments to delete one QRTZ_PAUSED_TRIGGER_GRPS.
     * @example
     * // Delete one QRTZ_PAUSED_TRIGGER_GRPS
     * const QRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.delete({
     *   where: {
     *     // ... filter to delete one QRTZ_PAUSED_TRIGGER_GRPS
     *   }
     * })
     * 
     */
    delete<T extends QRTZ_PAUSED_TRIGGER_GRPSDeleteArgs>(args: SelectSubset<T, QRTZ_PAUSED_TRIGGER_GRPSDeleteArgs<ExtArgs>>): Prisma__QRTZ_PAUSED_TRIGGER_GRPSClient<$Result.GetResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRTZ_PAUSED_TRIGGER_GRPS.
     * @param {QRTZ_PAUSED_TRIGGER_GRPSUpdateArgs} args - Arguments to update one QRTZ_PAUSED_TRIGGER_GRPS.
     * @example
     * // Update one QRTZ_PAUSED_TRIGGER_GRPS
     * const qRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRTZ_PAUSED_TRIGGER_GRPSUpdateArgs>(args: SelectSubset<T, QRTZ_PAUSED_TRIGGER_GRPSUpdateArgs<ExtArgs>>): Prisma__QRTZ_PAUSED_TRIGGER_GRPSClient<$Result.GetResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRTZ_PAUSED_TRIGGER_GRPS.
     * @param {QRTZ_PAUSED_TRIGGER_GRPSDeleteManyArgs} args - Arguments to filter QRTZ_PAUSED_TRIGGER_GRPS to delete.
     * @example
     * // Delete a few QRTZ_PAUSED_TRIGGER_GRPS
     * const { count } = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRTZ_PAUSED_TRIGGER_GRPSDeleteManyArgs>(args?: SelectSubset<T, QRTZ_PAUSED_TRIGGER_GRPSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRTZ_PAUSED_TRIGGER_GRPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_PAUSED_TRIGGER_GRPSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRTZ_PAUSED_TRIGGER_GRPS
     * const qRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRTZ_PAUSED_TRIGGER_GRPSUpdateManyArgs>(args: SelectSubset<T, QRTZ_PAUSED_TRIGGER_GRPSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QRTZ_PAUSED_TRIGGER_GRPS.
     * @param {QRTZ_PAUSED_TRIGGER_GRPSUpsertArgs} args - Arguments to update or create a QRTZ_PAUSED_TRIGGER_GRPS.
     * @example
     * // Update or create a QRTZ_PAUSED_TRIGGER_GRPS
     * const qRTZ_PAUSED_TRIGGER_GRPS = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.upsert({
     *   create: {
     *     // ... data to create a QRTZ_PAUSED_TRIGGER_GRPS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRTZ_PAUSED_TRIGGER_GRPS we want to update
     *   }
     * })
     */
    upsert<T extends QRTZ_PAUSED_TRIGGER_GRPSUpsertArgs>(args: SelectSubset<T, QRTZ_PAUSED_TRIGGER_GRPSUpsertArgs<ExtArgs>>): Prisma__QRTZ_PAUSED_TRIGGER_GRPSClient<$Result.GetResult<Prisma.$QRTZ_PAUSED_TRIGGER_GRPSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRTZ_PAUSED_TRIGGER_GRPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_PAUSED_TRIGGER_GRPSCountArgs} args - Arguments to filter QRTZ_PAUSED_TRIGGER_GRPS to count.
     * @example
     * // Count the number of QRTZ_PAUSED_TRIGGER_GRPS
     * const count = await prisma.qRTZ_PAUSED_TRIGGER_GRPS.count({
     *   where: {
     *     // ... the filter for the QRTZ_PAUSED_TRIGGER_GRPS we want to count
     *   }
     * })
    **/
    count<T extends QRTZ_PAUSED_TRIGGER_GRPSCountArgs>(
      args?: Subset<T, QRTZ_PAUSED_TRIGGER_GRPSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRTZ_PAUSED_TRIGGER_GRPSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRTZ_PAUSED_TRIGGER_GRPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_PAUSED_TRIGGER_GRPSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRTZ_PAUSED_TRIGGER_GRPSAggregateArgs>(args: Subset<T, QRTZ_PAUSED_TRIGGER_GRPSAggregateArgs>): Prisma.PrismaPromise<GetQRTZ_PAUSED_TRIGGER_GRPSAggregateType<T>>

    /**
     * Group by QRTZ_PAUSED_TRIGGER_GRPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_PAUSED_TRIGGER_GRPSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRTZ_PAUSED_TRIGGER_GRPSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRTZ_PAUSED_TRIGGER_GRPSGroupByArgs['orderBy'] }
        : { orderBy?: QRTZ_PAUSED_TRIGGER_GRPSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRTZ_PAUSED_TRIGGER_GRPSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRTZ_PAUSED_TRIGGER_GRPSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRTZ_PAUSED_TRIGGER_GRPS model
   */
  readonly fields: QRTZ_PAUSED_TRIGGER_GRPSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRTZ_PAUSED_TRIGGER_GRPS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRTZ_PAUSED_TRIGGER_GRPSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRTZ_PAUSED_TRIGGER_GRPS model
   */
  interface QRTZ_PAUSED_TRIGGER_GRPSFieldRefs {
    readonly SCHED_NAME: FieldRef<"QRTZ_PAUSED_TRIGGER_GRPS", 'String'>
    readonly TRIGGER_GROUP: FieldRef<"QRTZ_PAUSED_TRIGGER_GRPS", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QRTZ_PAUSED_TRIGGER_GRPS findUnique
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    select?: QRTZ_PAUSED_TRIGGER_GRPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    omit?: QRTZ_PAUSED_TRIGGER_GRPSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_PAUSED_TRIGGER_GRPS to fetch.
     */
    where: QRTZ_PAUSED_TRIGGER_GRPSWhereUniqueInput
  }

  /**
   * QRTZ_PAUSED_TRIGGER_GRPS findUniqueOrThrow
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    select?: QRTZ_PAUSED_TRIGGER_GRPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    omit?: QRTZ_PAUSED_TRIGGER_GRPSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_PAUSED_TRIGGER_GRPS to fetch.
     */
    where: QRTZ_PAUSED_TRIGGER_GRPSWhereUniqueInput
  }

  /**
   * QRTZ_PAUSED_TRIGGER_GRPS findFirst
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    select?: QRTZ_PAUSED_TRIGGER_GRPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    omit?: QRTZ_PAUSED_TRIGGER_GRPSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_PAUSED_TRIGGER_GRPS to fetch.
     */
    where?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_PAUSED_TRIGGER_GRPS to fetch.
     */
    orderBy?: QRTZ_PAUSED_TRIGGER_GRPSOrderByWithRelationInput | QRTZ_PAUSED_TRIGGER_GRPSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_PAUSED_TRIGGER_GRPS.
     */
    cursor?: QRTZ_PAUSED_TRIGGER_GRPSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_PAUSED_TRIGGER_GRPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_PAUSED_TRIGGER_GRPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_PAUSED_TRIGGER_GRPS.
     */
    distinct?: QRTZ_PAUSED_TRIGGER_GRPSScalarFieldEnum | QRTZ_PAUSED_TRIGGER_GRPSScalarFieldEnum[]
  }

  /**
   * QRTZ_PAUSED_TRIGGER_GRPS findFirstOrThrow
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    select?: QRTZ_PAUSED_TRIGGER_GRPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    omit?: QRTZ_PAUSED_TRIGGER_GRPSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_PAUSED_TRIGGER_GRPS to fetch.
     */
    where?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_PAUSED_TRIGGER_GRPS to fetch.
     */
    orderBy?: QRTZ_PAUSED_TRIGGER_GRPSOrderByWithRelationInput | QRTZ_PAUSED_TRIGGER_GRPSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_PAUSED_TRIGGER_GRPS.
     */
    cursor?: QRTZ_PAUSED_TRIGGER_GRPSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_PAUSED_TRIGGER_GRPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_PAUSED_TRIGGER_GRPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_PAUSED_TRIGGER_GRPS.
     */
    distinct?: QRTZ_PAUSED_TRIGGER_GRPSScalarFieldEnum | QRTZ_PAUSED_TRIGGER_GRPSScalarFieldEnum[]
  }

  /**
   * QRTZ_PAUSED_TRIGGER_GRPS findMany
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    select?: QRTZ_PAUSED_TRIGGER_GRPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    omit?: QRTZ_PAUSED_TRIGGER_GRPSOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_PAUSED_TRIGGER_GRPS to fetch.
     */
    where?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_PAUSED_TRIGGER_GRPS to fetch.
     */
    orderBy?: QRTZ_PAUSED_TRIGGER_GRPSOrderByWithRelationInput | QRTZ_PAUSED_TRIGGER_GRPSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRTZ_PAUSED_TRIGGER_GRPS.
     */
    cursor?: QRTZ_PAUSED_TRIGGER_GRPSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_PAUSED_TRIGGER_GRPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_PAUSED_TRIGGER_GRPS.
     */
    skip?: number
    distinct?: QRTZ_PAUSED_TRIGGER_GRPSScalarFieldEnum | QRTZ_PAUSED_TRIGGER_GRPSScalarFieldEnum[]
  }

  /**
   * QRTZ_PAUSED_TRIGGER_GRPS create
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    select?: QRTZ_PAUSED_TRIGGER_GRPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    omit?: QRTZ_PAUSED_TRIGGER_GRPSOmit<ExtArgs> | null
    /**
     * The data needed to create a QRTZ_PAUSED_TRIGGER_GRPS.
     */
    data: XOR<QRTZ_PAUSED_TRIGGER_GRPSCreateInput, QRTZ_PAUSED_TRIGGER_GRPSUncheckedCreateInput>
  }

  /**
   * QRTZ_PAUSED_TRIGGER_GRPS createMany
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRTZ_PAUSED_TRIGGER_GRPS.
     */
    data: QRTZ_PAUSED_TRIGGER_GRPSCreateManyInput | QRTZ_PAUSED_TRIGGER_GRPSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRTZ_PAUSED_TRIGGER_GRPS update
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    select?: QRTZ_PAUSED_TRIGGER_GRPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    omit?: QRTZ_PAUSED_TRIGGER_GRPSOmit<ExtArgs> | null
    /**
     * The data needed to update a QRTZ_PAUSED_TRIGGER_GRPS.
     */
    data: XOR<QRTZ_PAUSED_TRIGGER_GRPSUpdateInput, QRTZ_PAUSED_TRIGGER_GRPSUncheckedUpdateInput>
    /**
     * Choose, which QRTZ_PAUSED_TRIGGER_GRPS to update.
     */
    where: QRTZ_PAUSED_TRIGGER_GRPSWhereUniqueInput
  }

  /**
   * QRTZ_PAUSED_TRIGGER_GRPS updateMany
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRTZ_PAUSED_TRIGGER_GRPS.
     */
    data: XOR<QRTZ_PAUSED_TRIGGER_GRPSUpdateManyMutationInput, QRTZ_PAUSED_TRIGGER_GRPSUncheckedUpdateManyInput>
    /**
     * Filter which QRTZ_PAUSED_TRIGGER_GRPS to update
     */
    where?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput
    /**
     * Limit how many QRTZ_PAUSED_TRIGGER_GRPS to update.
     */
    limit?: number
  }

  /**
   * QRTZ_PAUSED_TRIGGER_GRPS upsert
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    select?: QRTZ_PAUSED_TRIGGER_GRPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    omit?: QRTZ_PAUSED_TRIGGER_GRPSOmit<ExtArgs> | null
    /**
     * The filter to search for the QRTZ_PAUSED_TRIGGER_GRPS to update in case it exists.
     */
    where: QRTZ_PAUSED_TRIGGER_GRPSWhereUniqueInput
    /**
     * In case the QRTZ_PAUSED_TRIGGER_GRPS found by the `where` argument doesn't exist, create a new QRTZ_PAUSED_TRIGGER_GRPS with this data.
     */
    create: XOR<QRTZ_PAUSED_TRIGGER_GRPSCreateInput, QRTZ_PAUSED_TRIGGER_GRPSUncheckedCreateInput>
    /**
     * In case the QRTZ_PAUSED_TRIGGER_GRPS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRTZ_PAUSED_TRIGGER_GRPSUpdateInput, QRTZ_PAUSED_TRIGGER_GRPSUncheckedUpdateInput>
  }

  /**
   * QRTZ_PAUSED_TRIGGER_GRPS delete
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    select?: QRTZ_PAUSED_TRIGGER_GRPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    omit?: QRTZ_PAUSED_TRIGGER_GRPSOmit<ExtArgs> | null
    /**
     * Filter which QRTZ_PAUSED_TRIGGER_GRPS to delete.
     */
    where: QRTZ_PAUSED_TRIGGER_GRPSWhereUniqueInput
  }

  /**
   * QRTZ_PAUSED_TRIGGER_GRPS deleteMany
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_PAUSED_TRIGGER_GRPS to delete
     */
    where?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput
    /**
     * Limit how many QRTZ_PAUSED_TRIGGER_GRPS to delete.
     */
    limit?: number
  }

  /**
   * QRTZ_PAUSED_TRIGGER_GRPS without action
   */
  export type QRTZ_PAUSED_TRIGGER_GRPSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    select?: QRTZ_PAUSED_TRIGGER_GRPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_PAUSED_TRIGGER_GRPS
     */
    omit?: QRTZ_PAUSED_TRIGGER_GRPSOmit<ExtArgs> | null
  }


  /**
   * Model QRTZ_SCHEDULER_STATE
   */

  export type AggregateQRTZ_SCHEDULER_STATE = {
    _count: QRTZ_SCHEDULER_STATECountAggregateOutputType | null
    _avg: QRTZ_SCHEDULER_STATEAvgAggregateOutputType | null
    _sum: QRTZ_SCHEDULER_STATESumAggregateOutputType | null
    _min: QRTZ_SCHEDULER_STATEMinAggregateOutputType | null
    _max: QRTZ_SCHEDULER_STATEMaxAggregateOutputType | null
  }

  export type QRTZ_SCHEDULER_STATEAvgAggregateOutputType = {
    LAST_CHECKIN_TIME: number | null
    CHECKIN_INTERVAL: number | null
  }

  export type QRTZ_SCHEDULER_STATESumAggregateOutputType = {
    LAST_CHECKIN_TIME: bigint | null
    CHECKIN_INTERVAL: bigint | null
  }

  export type QRTZ_SCHEDULER_STATEMinAggregateOutputType = {
    SCHED_NAME: string | null
    INSTANCE_NAME: string | null
    LAST_CHECKIN_TIME: bigint | null
    CHECKIN_INTERVAL: bigint | null
  }

  export type QRTZ_SCHEDULER_STATEMaxAggregateOutputType = {
    SCHED_NAME: string | null
    INSTANCE_NAME: string | null
    LAST_CHECKIN_TIME: bigint | null
    CHECKIN_INTERVAL: bigint | null
  }

  export type QRTZ_SCHEDULER_STATECountAggregateOutputType = {
    SCHED_NAME: number
    INSTANCE_NAME: number
    LAST_CHECKIN_TIME: number
    CHECKIN_INTERVAL: number
    _all: number
  }


  export type QRTZ_SCHEDULER_STATEAvgAggregateInputType = {
    LAST_CHECKIN_TIME?: true
    CHECKIN_INTERVAL?: true
  }

  export type QRTZ_SCHEDULER_STATESumAggregateInputType = {
    LAST_CHECKIN_TIME?: true
    CHECKIN_INTERVAL?: true
  }

  export type QRTZ_SCHEDULER_STATEMinAggregateInputType = {
    SCHED_NAME?: true
    INSTANCE_NAME?: true
    LAST_CHECKIN_TIME?: true
    CHECKIN_INTERVAL?: true
  }

  export type QRTZ_SCHEDULER_STATEMaxAggregateInputType = {
    SCHED_NAME?: true
    INSTANCE_NAME?: true
    LAST_CHECKIN_TIME?: true
    CHECKIN_INTERVAL?: true
  }

  export type QRTZ_SCHEDULER_STATECountAggregateInputType = {
    SCHED_NAME?: true
    INSTANCE_NAME?: true
    LAST_CHECKIN_TIME?: true
    CHECKIN_INTERVAL?: true
    _all?: true
  }

  export type QRTZ_SCHEDULER_STATEAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_SCHEDULER_STATE to aggregate.
     */
    where?: QRTZ_SCHEDULER_STATEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_SCHEDULER_STATES to fetch.
     */
    orderBy?: QRTZ_SCHEDULER_STATEOrderByWithRelationInput | QRTZ_SCHEDULER_STATEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRTZ_SCHEDULER_STATEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_SCHEDULER_STATES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_SCHEDULER_STATES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRTZ_SCHEDULER_STATES
    **/
    _count?: true | QRTZ_SCHEDULER_STATECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QRTZ_SCHEDULER_STATEAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QRTZ_SCHEDULER_STATESumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRTZ_SCHEDULER_STATEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRTZ_SCHEDULER_STATEMaxAggregateInputType
  }

  export type GetQRTZ_SCHEDULER_STATEAggregateType<T extends QRTZ_SCHEDULER_STATEAggregateArgs> = {
        [P in keyof T & keyof AggregateQRTZ_SCHEDULER_STATE]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRTZ_SCHEDULER_STATE[P]>
      : GetScalarType<T[P], AggregateQRTZ_SCHEDULER_STATE[P]>
  }




  export type QRTZ_SCHEDULER_STATEGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRTZ_SCHEDULER_STATEWhereInput
    orderBy?: QRTZ_SCHEDULER_STATEOrderByWithAggregationInput | QRTZ_SCHEDULER_STATEOrderByWithAggregationInput[]
    by: QRTZ_SCHEDULER_STATEScalarFieldEnum[] | QRTZ_SCHEDULER_STATEScalarFieldEnum
    having?: QRTZ_SCHEDULER_STATEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRTZ_SCHEDULER_STATECountAggregateInputType | true
    _avg?: QRTZ_SCHEDULER_STATEAvgAggregateInputType
    _sum?: QRTZ_SCHEDULER_STATESumAggregateInputType
    _min?: QRTZ_SCHEDULER_STATEMinAggregateInputType
    _max?: QRTZ_SCHEDULER_STATEMaxAggregateInputType
  }

  export type QRTZ_SCHEDULER_STATEGroupByOutputType = {
    SCHED_NAME: string
    INSTANCE_NAME: string
    LAST_CHECKIN_TIME: bigint
    CHECKIN_INTERVAL: bigint
    _count: QRTZ_SCHEDULER_STATECountAggregateOutputType | null
    _avg: QRTZ_SCHEDULER_STATEAvgAggregateOutputType | null
    _sum: QRTZ_SCHEDULER_STATESumAggregateOutputType | null
    _min: QRTZ_SCHEDULER_STATEMinAggregateOutputType | null
    _max: QRTZ_SCHEDULER_STATEMaxAggregateOutputType | null
  }

  type GetQRTZ_SCHEDULER_STATEGroupByPayload<T extends QRTZ_SCHEDULER_STATEGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRTZ_SCHEDULER_STATEGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRTZ_SCHEDULER_STATEGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRTZ_SCHEDULER_STATEGroupByOutputType[P]>
            : GetScalarType<T[P], QRTZ_SCHEDULER_STATEGroupByOutputType[P]>
        }
      >
    >


  export type QRTZ_SCHEDULER_STATESelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SCHED_NAME?: boolean
    INSTANCE_NAME?: boolean
    LAST_CHECKIN_TIME?: boolean
    CHECKIN_INTERVAL?: boolean
  }, ExtArgs["result"]["qRTZ_SCHEDULER_STATE"]>



  export type QRTZ_SCHEDULER_STATESelectScalar = {
    SCHED_NAME?: boolean
    INSTANCE_NAME?: boolean
    LAST_CHECKIN_TIME?: boolean
    CHECKIN_INTERVAL?: boolean
  }

  export type QRTZ_SCHEDULER_STATEOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SCHED_NAME" | "INSTANCE_NAME" | "LAST_CHECKIN_TIME" | "CHECKIN_INTERVAL", ExtArgs["result"]["qRTZ_SCHEDULER_STATE"]>

  export type $QRTZ_SCHEDULER_STATEPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRTZ_SCHEDULER_STATE"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SCHED_NAME: string
      INSTANCE_NAME: string
      LAST_CHECKIN_TIME: bigint
      CHECKIN_INTERVAL: bigint
    }, ExtArgs["result"]["qRTZ_SCHEDULER_STATE"]>
    composites: {}
  }

  type QRTZ_SCHEDULER_STATEGetPayload<S extends boolean | null | undefined | QRTZ_SCHEDULER_STATEDefaultArgs> = $Result.GetResult<Prisma.$QRTZ_SCHEDULER_STATEPayload, S>

  type QRTZ_SCHEDULER_STATECountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRTZ_SCHEDULER_STATEFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRTZ_SCHEDULER_STATECountAggregateInputType | true
    }

  export interface QRTZ_SCHEDULER_STATEDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRTZ_SCHEDULER_STATE'], meta: { name: 'QRTZ_SCHEDULER_STATE' } }
    /**
     * Find zero or one QRTZ_SCHEDULER_STATE that matches the filter.
     * @param {QRTZ_SCHEDULER_STATEFindUniqueArgs} args - Arguments to find a QRTZ_SCHEDULER_STATE
     * @example
     * // Get one QRTZ_SCHEDULER_STATE
     * const qRTZ_SCHEDULER_STATE = await prisma.qRTZ_SCHEDULER_STATE.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRTZ_SCHEDULER_STATEFindUniqueArgs>(args: SelectSubset<T, QRTZ_SCHEDULER_STATEFindUniqueArgs<ExtArgs>>): Prisma__QRTZ_SCHEDULER_STATEClient<$Result.GetResult<Prisma.$QRTZ_SCHEDULER_STATEPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRTZ_SCHEDULER_STATE that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRTZ_SCHEDULER_STATEFindUniqueOrThrowArgs} args - Arguments to find a QRTZ_SCHEDULER_STATE
     * @example
     * // Get one QRTZ_SCHEDULER_STATE
     * const qRTZ_SCHEDULER_STATE = await prisma.qRTZ_SCHEDULER_STATE.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRTZ_SCHEDULER_STATEFindUniqueOrThrowArgs>(args: SelectSubset<T, QRTZ_SCHEDULER_STATEFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRTZ_SCHEDULER_STATEClient<$Result.GetResult<Prisma.$QRTZ_SCHEDULER_STATEPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_SCHEDULER_STATE that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SCHEDULER_STATEFindFirstArgs} args - Arguments to find a QRTZ_SCHEDULER_STATE
     * @example
     * // Get one QRTZ_SCHEDULER_STATE
     * const qRTZ_SCHEDULER_STATE = await prisma.qRTZ_SCHEDULER_STATE.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRTZ_SCHEDULER_STATEFindFirstArgs>(args?: SelectSubset<T, QRTZ_SCHEDULER_STATEFindFirstArgs<ExtArgs>>): Prisma__QRTZ_SCHEDULER_STATEClient<$Result.GetResult<Prisma.$QRTZ_SCHEDULER_STATEPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_SCHEDULER_STATE that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SCHEDULER_STATEFindFirstOrThrowArgs} args - Arguments to find a QRTZ_SCHEDULER_STATE
     * @example
     * // Get one QRTZ_SCHEDULER_STATE
     * const qRTZ_SCHEDULER_STATE = await prisma.qRTZ_SCHEDULER_STATE.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRTZ_SCHEDULER_STATEFindFirstOrThrowArgs>(args?: SelectSubset<T, QRTZ_SCHEDULER_STATEFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRTZ_SCHEDULER_STATEClient<$Result.GetResult<Prisma.$QRTZ_SCHEDULER_STATEPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRTZ_SCHEDULER_STATES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SCHEDULER_STATEFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRTZ_SCHEDULER_STATES
     * const qRTZ_SCHEDULER_STATES = await prisma.qRTZ_SCHEDULER_STATE.findMany()
     * 
     * // Get first 10 QRTZ_SCHEDULER_STATES
     * const qRTZ_SCHEDULER_STATES = await prisma.qRTZ_SCHEDULER_STATE.findMany({ take: 10 })
     * 
     * // Only select the `SCHED_NAME`
     * const qRTZ_SCHEDULER_STATEWithSCHED_NAMEOnly = await prisma.qRTZ_SCHEDULER_STATE.findMany({ select: { SCHED_NAME: true } })
     * 
     */
    findMany<T extends QRTZ_SCHEDULER_STATEFindManyArgs>(args?: SelectSubset<T, QRTZ_SCHEDULER_STATEFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRTZ_SCHEDULER_STATEPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRTZ_SCHEDULER_STATE.
     * @param {QRTZ_SCHEDULER_STATECreateArgs} args - Arguments to create a QRTZ_SCHEDULER_STATE.
     * @example
     * // Create one QRTZ_SCHEDULER_STATE
     * const QRTZ_SCHEDULER_STATE = await prisma.qRTZ_SCHEDULER_STATE.create({
     *   data: {
     *     // ... data to create a QRTZ_SCHEDULER_STATE
     *   }
     * })
     * 
     */
    create<T extends QRTZ_SCHEDULER_STATECreateArgs>(args: SelectSubset<T, QRTZ_SCHEDULER_STATECreateArgs<ExtArgs>>): Prisma__QRTZ_SCHEDULER_STATEClient<$Result.GetResult<Prisma.$QRTZ_SCHEDULER_STATEPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRTZ_SCHEDULER_STATES.
     * @param {QRTZ_SCHEDULER_STATECreateManyArgs} args - Arguments to create many QRTZ_SCHEDULER_STATES.
     * @example
     * // Create many QRTZ_SCHEDULER_STATES
     * const qRTZ_SCHEDULER_STATE = await prisma.qRTZ_SCHEDULER_STATE.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRTZ_SCHEDULER_STATECreateManyArgs>(args?: SelectSubset<T, QRTZ_SCHEDULER_STATECreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QRTZ_SCHEDULER_STATE.
     * @param {QRTZ_SCHEDULER_STATEDeleteArgs} args - Arguments to delete one QRTZ_SCHEDULER_STATE.
     * @example
     * // Delete one QRTZ_SCHEDULER_STATE
     * const QRTZ_SCHEDULER_STATE = await prisma.qRTZ_SCHEDULER_STATE.delete({
     *   where: {
     *     // ... filter to delete one QRTZ_SCHEDULER_STATE
     *   }
     * })
     * 
     */
    delete<T extends QRTZ_SCHEDULER_STATEDeleteArgs>(args: SelectSubset<T, QRTZ_SCHEDULER_STATEDeleteArgs<ExtArgs>>): Prisma__QRTZ_SCHEDULER_STATEClient<$Result.GetResult<Prisma.$QRTZ_SCHEDULER_STATEPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRTZ_SCHEDULER_STATE.
     * @param {QRTZ_SCHEDULER_STATEUpdateArgs} args - Arguments to update one QRTZ_SCHEDULER_STATE.
     * @example
     * // Update one QRTZ_SCHEDULER_STATE
     * const qRTZ_SCHEDULER_STATE = await prisma.qRTZ_SCHEDULER_STATE.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRTZ_SCHEDULER_STATEUpdateArgs>(args: SelectSubset<T, QRTZ_SCHEDULER_STATEUpdateArgs<ExtArgs>>): Prisma__QRTZ_SCHEDULER_STATEClient<$Result.GetResult<Prisma.$QRTZ_SCHEDULER_STATEPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRTZ_SCHEDULER_STATES.
     * @param {QRTZ_SCHEDULER_STATEDeleteManyArgs} args - Arguments to filter QRTZ_SCHEDULER_STATES to delete.
     * @example
     * // Delete a few QRTZ_SCHEDULER_STATES
     * const { count } = await prisma.qRTZ_SCHEDULER_STATE.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRTZ_SCHEDULER_STATEDeleteManyArgs>(args?: SelectSubset<T, QRTZ_SCHEDULER_STATEDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRTZ_SCHEDULER_STATES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SCHEDULER_STATEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRTZ_SCHEDULER_STATES
     * const qRTZ_SCHEDULER_STATE = await prisma.qRTZ_SCHEDULER_STATE.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRTZ_SCHEDULER_STATEUpdateManyArgs>(args: SelectSubset<T, QRTZ_SCHEDULER_STATEUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QRTZ_SCHEDULER_STATE.
     * @param {QRTZ_SCHEDULER_STATEUpsertArgs} args - Arguments to update or create a QRTZ_SCHEDULER_STATE.
     * @example
     * // Update or create a QRTZ_SCHEDULER_STATE
     * const qRTZ_SCHEDULER_STATE = await prisma.qRTZ_SCHEDULER_STATE.upsert({
     *   create: {
     *     // ... data to create a QRTZ_SCHEDULER_STATE
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRTZ_SCHEDULER_STATE we want to update
     *   }
     * })
     */
    upsert<T extends QRTZ_SCHEDULER_STATEUpsertArgs>(args: SelectSubset<T, QRTZ_SCHEDULER_STATEUpsertArgs<ExtArgs>>): Prisma__QRTZ_SCHEDULER_STATEClient<$Result.GetResult<Prisma.$QRTZ_SCHEDULER_STATEPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRTZ_SCHEDULER_STATES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SCHEDULER_STATECountArgs} args - Arguments to filter QRTZ_SCHEDULER_STATES to count.
     * @example
     * // Count the number of QRTZ_SCHEDULER_STATES
     * const count = await prisma.qRTZ_SCHEDULER_STATE.count({
     *   where: {
     *     // ... the filter for the QRTZ_SCHEDULER_STATES we want to count
     *   }
     * })
    **/
    count<T extends QRTZ_SCHEDULER_STATECountArgs>(
      args?: Subset<T, QRTZ_SCHEDULER_STATECountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRTZ_SCHEDULER_STATECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRTZ_SCHEDULER_STATE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SCHEDULER_STATEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRTZ_SCHEDULER_STATEAggregateArgs>(args: Subset<T, QRTZ_SCHEDULER_STATEAggregateArgs>): Prisma.PrismaPromise<GetQRTZ_SCHEDULER_STATEAggregateType<T>>

    /**
     * Group by QRTZ_SCHEDULER_STATE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SCHEDULER_STATEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRTZ_SCHEDULER_STATEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRTZ_SCHEDULER_STATEGroupByArgs['orderBy'] }
        : { orderBy?: QRTZ_SCHEDULER_STATEGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRTZ_SCHEDULER_STATEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRTZ_SCHEDULER_STATEGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRTZ_SCHEDULER_STATE model
   */
  readonly fields: QRTZ_SCHEDULER_STATEFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRTZ_SCHEDULER_STATE.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRTZ_SCHEDULER_STATEClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRTZ_SCHEDULER_STATE model
   */
  interface QRTZ_SCHEDULER_STATEFieldRefs {
    readonly SCHED_NAME: FieldRef<"QRTZ_SCHEDULER_STATE", 'String'>
    readonly INSTANCE_NAME: FieldRef<"QRTZ_SCHEDULER_STATE", 'String'>
    readonly LAST_CHECKIN_TIME: FieldRef<"QRTZ_SCHEDULER_STATE", 'BigInt'>
    readonly CHECKIN_INTERVAL: FieldRef<"QRTZ_SCHEDULER_STATE", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * QRTZ_SCHEDULER_STATE findUnique
   */
  export type QRTZ_SCHEDULER_STATEFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SCHEDULER_STATE
     */
    select?: QRTZ_SCHEDULER_STATESelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SCHEDULER_STATE
     */
    omit?: QRTZ_SCHEDULER_STATEOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_SCHEDULER_STATE to fetch.
     */
    where: QRTZ_SCHEDULER_STATEWhereUniqueInput
  }

  /**
   * QRTZ_SCHEDULER_STATE findUniqueOrThrow
   */
  export type QRTZ_SCHEDULER_STATEFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SCHEDULER_STATE
     */
    select?: QRTZ_SCHEDULER_STATESelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SCHEDULER_STATE
     */
    omit?: QRTZ_SCHEDULER_STATEOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_SCHEDULER_STATE to fetch.
     */
    where: QRTZ_SCHEDULER_STATEWhereUniqueInput
  }

  /**
   * QRTZ_SCHEDULER_STATE findFirst
   */
  export type QRTZ_SCHEDULER_STATEFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SCHEDULER_STATE
     */
    select?: QRTZ_SCHEDULER_STATESelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SCHEDULER_STATE
     */
    omit?: QRTZ_SCHEDULER_STATEOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_SCHEDULER_STATE to fetch.
     */
    where?: QRTZ_SCHEDULER_STATEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_SCHEDULER_STATES to fetch.
     */
    orderBy?: QRTZ_SCHEDULER_STATEOrderByWithRelationInput | QRTZ_SCHEDULER_STATEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_SCHEDULER_STATES.
     */
    cursor?: QRTZ_SCHEDULER_STATEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_SCHEDULER_STATES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_SCHEDULER_STATES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_SCHEDULER_STATES.
     */
    distinct?: QRTZ_SCHEDULER_STATEScalarFieldEnum | QRTZ_SCHEDULER_STATEScalarFieldEnum[]
  }

  /**
   * QRTZ_SCHEDULER_STATE findFirstOrThrow
   */
  export type QRTZ_SCHEDULER_STATEFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SCHEDULER_STATE
     */
    select?: QRTZ_SCHEDULER_STATESelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SCHEDULER_STATE
     */
    omit?: QRTZ_SCHEDULER_STATEOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_SCHEDULER_STATE to fetch.
     */
    where?: QRTZ_SCHEDULER_STATEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_SCHEDULER_STATES to fetch.
     */
    orderBy?: QRTZ_SCHEDULER_STATEOrderByWithRelationInput | QRTZ_SCHEDULER_STATEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_SCHEDULER_STATES.
     */
    cursor?: QRTZ_SCHEDULER_STATEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_SCHEDULER_STATES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_SCHEDULER_STATES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_SCHEDULER_STATES.
     */
    distinct?: QRTZ_SCHEDULER_STATEScalarFieldEnum | QRTZ_SCHEDULER_STATEScalarFieldEnum[]
  }

  /**
   * QRTZ_SCHEDULER_STATE findMany
   */
  export type QRTZ_SCHEDULER_STATEFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SCHEDULER_STATE
     */
    select?: QRTZ_SCHEDULER_STATESelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SCHEDULER_STATE
     */
    omit?: QRTZ_SCHEDULER_STATEOmit<ExtArgs> | null
    /**
     * Filter, which QRTZ_SCHEDULER_STATES to fetch.
     */
    where?: QRTZ_SCHEDULER_STATEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_SCHEDULER_STATES to fetch.
     */
    orderBy?: QRTZ_SCHEDULER_STATEOrderByWithRelationInput | QRTZ_SCHEDULER_STATEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRTZ_SCHEDULER_STATES.
     */
    cursor?: QRTZ_SCHEDULER_STATEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_SCHEDULER_STATES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_SCHEDULER_STATES.
     */
    skip?: number
    distinct?: QRTZ_SCHEDULER_STATEScalarFieldEnum | QRTZ_SCHEDULER_STATEScalarFieldEnum[]
  }

  /**
   * QRTZ_SCHEDULER_STATE create
   */
  export type QRTZ_SCHEDULER_STATECreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SCHEDULER_STATE
     */
    select?: QRTZ_SCHEDULER_STATESelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SCHEDULER_STATE
     */
    omit?: QRTZ_SCHEDULER_STATEOmit<ExtArgs> | null
    /**
     * The data needed to create a QRTZ_SCHEDULER_STATE.
     */
    data: XOR<QRTZ_SCHEDULER_STATECreateInput, QRTZ_SCHEDULER_STATEUncheckedCreateInput>
  }

  /**
   * QRTZ_SCHEDULER_STATE createMany
   */
  export type QRTZ_SCHEDULER_STATECreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRTZ_SCHEDULER_STATES.
     */
    data: QRTZ_SCHEDULER_STATECreateManyInput | QRTZ_SCHEDULER_STATECreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRTZ_SCHEDULER_STATE update
   */
  export type QRTZ_SCHEDULER_STATEUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SCHEDULER_STATE
     */
    select?: QRTZ_SCHEDULER_STATESelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SCHEDULER_STATE
     */
    omit?: QRTZ_SCHEDULER_STATEOmit<ExtArgs> | null
    /**
     * The data needed to update a QRTZ_SCHEDULER_STATE.
     */
    data: XOR<QRTZ_SCHEDULER_STATEUpdateInput, QRTZ_SCHEDULER_STATEUncheckedUpdateInput>
    /**
     * Choose, which QRTZ_SCHEDULER_STATE to update.
     */
    where: QRTZ_SCHEDULER_STATEWhereUniqueInput
  }

  /**
   * QRTZ_SCHEDULER_STATE updateMany
   */
  export type QRTZ_SCHEDULER_STATEUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRTZ_SCHEDULER_STATES.
     */
    data: XOR<QRTZ_SCHEDULER_STATEUpdateManyMutationInput, QRTZ_SCHEDULER_STATEUncheckedUpdateManyInput>
    /**
     * Filter which QRTZ_SCHEDULER_STATES to update
     */
    where?: QRTZ_SCHEDULER_STATEWhereInput
    /**
     * Limit how many QRTZ_SCHEDULER_STATES to update.
     */
    limit?: number
  }

  /**
   * QRTZ_SCHEDULER_STATE upsert
   */
  export type QRTZ_SCHEDULER_STATEUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SCHEDULER_STATE
     */
    select?: QRTZ_SCHEDULER_STATESelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SCHEDULER_STATE
     */
    omit?: QRTZ_SCHEDULER_STATEOmit<ExtArgs> | null
    /**
     * The filter to search for the QRTZ_SCHEDULER_STATE to update in case it exists.
     */
    where: QRTZ_SCHEDULER_STATEWhereUniqueInput
    /**
     * In case the QRTZ_SCHEDULER_STATE found by the `where` argument doesn't exist, create a new QRTZ_SCHEDULER_STATE with this data.
     */
    create: XOR<QRTZ_SCHEDULER_STATECreateInput, QRTZ_SCHEDULER_STATEUncheckedCreateInput>
    /**
     * In case the QRTZ_SCHEDULER_STATE was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRTZ_SCHEDULER_STATEUpdateInput, QRTZ_SCHEDULER_STATEUncheckedUpdateInput>
  }

  /**
   * QRTZ_SCHEDULER_STATE delete
   */
  export type QRTZ_SCHEDULER_STATEDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SCHEDULER_STATE
     */
    select?: QRTZ_SCHEDULER_STATESelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SCHEDULER_STATE
     */
    omit?: QRTZ_SCHEDULER_STATEOmit<ExtArgs> | null
    /**
     * Filter which QRTZ_SCHEDULER_STATE to delete.
     */
    where: QRTZ_SCHEDULER_STATEWhereUniqueInput
  }

  /**
   * QRTZ_SCHEDULER_STATE deleteMany
   */
  export type QRTZ_SCHEDULER_STATEDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_SCHEDULER_STATES to delete
     */
    where?: QRTZ_SCHEDULER_STATEWhereInput
    /**
     * Limit how many QRTZ_SCHEDULER_STATES to delete.
     */
    limit?: number
  }

  /**
   * QRTZ_SCHEDULER_STATE without action
   */
  export type QRTZ_SCHEDULER_STATEDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SCHEDULER_STATE
     */
    select?: QRTZ_SCHEDULER_STATESelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SCHEDULER_STATE
     */
    omit?: QRTZ_SCHEDULER_STATEOmit<ExtArgs> | null
  }


  /**
   * Model QRTZ_SIMPLE_TRIGGERS
   */

  export type AggregateQRTZ_SIMPLE_TRIGGERS = {
    _count: QRTZ_SIMPLE_TRIGGERSCountAggregateOutputType | null
    _avg: QRTZ_SIMPLE_TRIGGERSAvgAggregateOutputType | null
    _sum: QRTZ_SIMPLE_TRIGGERSSumAggregateOutputType | null
    _min: QRTZ_SIMPLE_TRIGGERSMinAggregateOutputType | null
    _max: QRTZ_SIMPLE_TRIGGERSMaxAggregateOutputType | null
  }

  export type QRTZ_SIMPLE_TRIGGERSAvgAggregateOutputType = {
    REPEAT_COUNT: number | null
    REPEAT_INTERVAL: number | null
    TIMES_TRIGGERED: number | null
  }

  export type QRTZ_SIMPLE_TRIGGERSSumAggregateOutputType = {
    REPEAT_COUNT: bigint | null
    REPEAT_INTERVAL: bigint | null
    TIMES_TRIGGERED: bigint | null
  }

  export type QRTZ_SIMPLE_TRIGGERSMinAggregateOutputType = {
    SCHED_NAME: string | null
    TRIGGER_NAME: string | null
    TRIGGER_GROUP: string | null
    REPEAT_COUNT: bigint | null
    REPEAT_INTERVAL: bigint | null
    TIMES_TRIGGERED: bigint | null
  }

  export type QRTZ_SIMPLE_TRIGGERSMaxAggregateOutputType = {
    SCHED_NAME: string | null
    TRIGGER_NAME: string | null
    TRIGGER_GROUP: string | null
    REPEAT_COUNT: bigint | null
    REPEAT_INTERVAL: bigint | null
    TIMES_TRIGGERED: bigint | null
  }

  export type QRTZ_SIMPLE_TRIGGERSCountAggregateOutputType = {
    SCHED_NAME: number
    TRIGGER_NAME: number
    TRIGGER_GROUP: number
    REPEAT_COUNT: number
    REPEAT_INTERVAL: number
    TIMES_TRIGGERED: number
    _all: number
  }


  export type QRTZ_SIMPLE_TRIGGERSAvgAggregateInputType = {
    REPEAT_COUNT?: true
    REPEAT_INTERVAL?: true
    TIMES_TRIGGERED?: true
  }

  export type QRTZ_SIMPLE_TRIGGERSSumAggregateInputType = {
    REPEAT_COUNT?: true
    REPEAT_INTERVAL?: true
    TIMES_TRIGGERED?: true
  }

  export type QRTZ_SIMPLE_TRIGGERSMinAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    REPEAT_COUNT?: true
    REPEAT_INTERVAL?: true
    TIMES_TRIGGERED?: true
  }

  export type QRTZ_SIMPLE_TRIGGERSMaxAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    REPEAT_COUNT?: true
    REPEAT_INTERVAL?: true
    TIMES_TRIGGERED?: true
  }

  export type QRTZ_SIMPLE_TRIGGERSCountAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    REPEAT_COUNT?: true
    REPEAT_INTERVAL?: true
    TIMES_TRIGGERED?: true
    _all?: true
  }

  export type QRTZ_SIMPLE_TRIGGERSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_SIMPLE_TRIGGERS to aggregate.
     */
    where?: QRTZ_SIMPLE_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_SIMPLE_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_SIMPLE_TRIGGERSOrderByWithRelationInput | QRTZ_SIMPLE_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_SIMPLE_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_SIMPLE_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRTZ_SIMPLE_TRIGGERS
    **/
    _count?: true | QRTZ_SIMPLE_TRIGGERSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QRTZ_SIMPLE_TRIGGERSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QRTZ_SIMPLE_TRIGGERSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRTZ_SIMPLE_TRIGGERSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRTZ_SIMPLE_TRIGGERSMaxAggregateInputType
  }

  export type GetQRTZ_SIMPLE_TRIGGERSAggregateType<T extends QRTZ_SIMPLE_TRIGGERSAggregateArgs> = {
        [P in keyof T & keyof AggregateQRTZ_SIMPLE_TRIGGERS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRTZ_SIMPLE_TRIGGERS[P]>
      : GetScalarType<T[P], AggregateQRTZ_SIMPLE_TRIGGERS[P]>
  }




  export type QRTZ_SIMPLE_TRIGGERSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRTZ_SIMPLE_TRIGGERSWhereInput
    orderBy?: QRTZ_SIMPLE_TRIGGERSOrderByWithAggregationInput | QRTZ_SIMPLE_TRIGGERSOrderByWithAggregationInput[]
    by: QRTZ_SIMPLE_TRIGGERSScalarFieldEnum[] | QRTZ_SIMPLE_TRIGGERSScalarFieldEnum
    having?: QRTZ_SIMPLE_TRIGGERSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRTZ_SIMPLE_TRIGGERSCountAggregateInputType | true
    _avg?: QRTZ_SIMPLE_TRIGGERSAvgAggregateInputType
    _sum?: QRTZ_SIMPLE_TRIGGERSSumAggregateInputType
    _min?: QRTZ_SIMPLE_TRIGGERSMinAggregateInputType
    _max?: QRTZ_SIMPLE_TRIGGERSMaxAggregateInputType
  }

  export type QRTZ_SIMPLE_TRIGGERSGroupByOutputType = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    REPEAT_COUNT: bigint
    REPEAT_INTERVAL: bigint
    TIMES_TRIGGERED: bigint
    _count: QRTZ_SIMPLE_TRIGGERSCountAggregateOutputType | null
    _avg: QRTZ_SIMPLE_TRIGGERSAvgAggregateOutputType | null
    _sum: QRTZ_SIMPLE_TRIGGERSSumAggregateOutputType | null
    _min: QRTZ_SIMPLE_TRIGGERSMinAggregateOutputType | null
    _max: QRTZ_SIMPLE_TRIGGERSMaxAggregateOutputType | null
  }

  type GetQRTZ_SIMPLE_TRIGGERSGroupByPayload<T extends QRTZ_SIMPLE_TRIGGERSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRTZ_SIMPLE_TRIGGERSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRTZ_SIMPLE_TRIGGERSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRTZ_SIMPLE_TRIGGERSGroupByOutputType[P]>
            : GetScalarType<T[P], QRTZ_SIMPLE_TRIGGERSGroupByOutputType[P]>
        }
      >
    >


  export type QRTZ_SIMPLE_TRIGGERSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SCHED_NAME?: boolean
    TRIGGER_NAME?: boolean
    TRIGGER_GROUP?: boolean
    REPEAT_COUNT?: boolean
    REPEAT_INTERVAL?: boolean
    TIMES_TRIGGERED?: boolean
    QRTZ_TRIGGERS?: boolean | QRTZ_TRIGGERSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qRTZ_SIMPLE_TRIGGERS"]>



  export type QRTZ_SIMPLE_TRIGGERSSelectScalar = {
    SCHED_NAME?: boolean
    TRIGGER_NAME?: boolean
    TRIGGER_GROUP?: boolean
    REPEAT_COUNT?: boolean
    REPEAT_INTERVAL?: boolean
    TIMES_TRIGGERED?: boolean
  }

  export type QRTZ_SIMPLE_TRIGGERSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SCHED_NAME" | "TRIGGER_NAME" | "TRIGGER_GROUP" | "REPEAT_COUNT" | "REPEAT_INTERVAL" | "TIMES_TRIGGERED", ExtArgs["result"]["qRTZ_SIMPLE_TRIGGERS"]>
  export type QRTZ_SIMPLE_TRIGGERSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QRTZ_TRIGGERS?: boolean | QRTZ_TRIGGERSDefaultArgs<ExtArgs>
  }

  export type $QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRTZ_SIMPLE_TRIGGERS"
    objects: {
      QRTZ_TRIGGERS: Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      SCHED_NAME: string
      TRIGGER_NAME: string
      TRIGGER_GROUP: string
      REPEAT_COUNT: bigint
      REPEAT_INTERVAL: bigint
      TIMES_TRIGGERED: bigint
    }, ExtArgs["result"]["qRTZ_SIMPLE_TRIGGERS"]>
    composites: {}
  }

  type QRTZ_SIMPLE_TRIGGERSGetPayload<S extends boolean | null | undefined | QRTZ_SIMPLE_TRIGGERSDefaultArgs> = $Result.GetResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload, S>

  type QRTZ_SIMPLE_TRIGGERSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRTZ_SIMPLE_TRIGGERSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRTZ_SIMPLE_TRIGGERSCountAggregateInputType | true
    }

  export interface QRTZ_SIMPLE_TRIGGERSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRTZ_SIMPLE_TRIGGERS'], meta: { name: 'QRTZ_SIMPLE_TRIGGERS' } }
    /**
     * Find zero or one QRTZ_SIMPLE_TRIGGERS that matches the filter.
     * @param {QRTZ_SIMPLE_TRIGGERSFindUniqueArgs} args - Arguments to find a QRTZ_SIMPLE_TRIGGERS
     * @example
     * // Get one QRTZ_SIMPLE_TRIGGERS
     * const qRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRTZ_SIMPLE_TRIGGERSFindUniqueArgs>(args: SelectSubset<T, QRTZ_SIMPLE_TRIGGERSFindUniqueArgs<ExtArgs>>): Prisma__QRTZ_SIMPLE_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRTZ_SIMPLE_TRIGGERS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRTZ_SIMPLE_TRIGGERSFindUniqueOrThrowArgs} args - Arguments to find a QRTZ_SIMPLE_TRIGGERS
     * @example
     * // Get one QRTZ_SIMPLE_TRIGGERS
     * const qRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRTZ_SIMPLE_TRIGGERSFindUniqueOrThrowArgs>(args: SelectSubset<T, QRTZ_SIMPLE_TRIGGERSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRTZ_SIMPLE_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_SIMPLE_TRIGGERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPLE_TRIGGERSFindFirstArgs} args - Arguments to find a QRTZ_SIMPLE_TRIGGERS
     * @example
     * // Get one QRTZ_SIMPLE_TRIGGERS
     * const qRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRTZ_SIMPLE_TRIGGERSFindFirstArgs>(args?: SelectSubset<T, QRTZ_SIMPLE_TRIGGERSFindFirstArgs<ExtArgs>>): Prisma__QRTZ_SIMPLE_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_SIMPLE_TRIGGERS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPLE_TRIGGERSFindFirstOrThrowArgs} args - Arguments to find a QRTZ_SIMPLE_TRIGGERS
     * @example
     * // Get one QRTZ_SIMPLE_TRIGGERS
     * const qRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRTZ_SIMPLE_TRIGGERSFindFirstOrThrowArgs>(args?: SelectSubset<T, QRTZ_SIMPLE_TRIGGERSFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRTZ_SIMPLE_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRTZ_SIMPLE_TRIGGERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPLE_TRIGGERSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRTZ_SIMPLE_TRIGGERS
     * const qRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.findMany()
     * 
     * // Get first 10 QRTZ_SIMPLE_TRIGGERS
     * const qRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.findMany({ take: 10 })
     * 
     * // Only select the `SCHED_NAME`
     * const qRTZ_SIMPLE_TRIGGERSWithSCHED_NAMEOnly = await prisma.qRTZ_SIMPLE_TRIGGERS.findMany({ select: { SCHED_NAME: true } })
     * 
     */
    findMany<T extends QRTZ_SIMPLE_TRIGGERSFindManyArgs>(args?: SelectSubset<T, QRTZ_SIMPLE_TRIGGERSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRTZ_SIMPLE_TRIGGERS.
     * @param {QRTZ_SIMPLE_TRIGGERSCreateArgs} args - Arguments to create a QRTZ_SIMPLE_TRIGGERS.
     * @example
     * // Create one QRTZ_SIMPLE_TRIGGERS
     * const QRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.create({
     *   data: {
     *     // ... data to create a QRTZ_SIMPLE_TRIGGERS
     *   }
     * })
     * 
     */
    create<T extends QRTZ_SIMPLE_TRIGGERSCreateArgs>(args: SelectSubset<T, QRTZ_SIMPLE_TRIGGERSCreateArgs<ExtArgs>>): Prisma__QRTZ_SIMPLE_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRTZ_SIMPLE_TRIGGERS.
     * @param {QRTZ_SIMPLE_TRIGGERSCreateManyArgs} args - Arguments to create many QRTZ_SIMPLE_TRIGGERS.
     * @example
     * // Create many QRTZ_SIMPLE_TRIGGERS
     * const qRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRTZ_SIMPLE_TRIGGERSCreateManyArgs>(args?: SelectSubset<T, QRTZ_SIMPLE_TRIGGERSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QRTZ_SIMPLE_TRIGGERS.
     * @param {QRTZ_SIMPLE_TRIGGERSDeleteArgs} args - Arguments to delete one QRTZ_SIMPLE_TRIGGERS.
     * @example
     * // Delete one QRTZ_SIMPLE_TRIGGERS
     * const QRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.delete({
     *   where: {
     *     // ... filter to delete one QRTZ_SIMPLE_TRIGGERS
     *   }
     * })
     * 
     */
    delete<T extends QRTZ_SIMPLE_TRIGGERSDeleteArgs>(args: SelectSubset<T, QRTZ_SIMPLE_TRIGGERSDeleteArgs<ExtArgs>>): Prisma__QRTZ_SIMPLE_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRTZ_SIMPLE_TRIGGERS.
     * @param {QRTZ_SIMPLE_TRIGGERSUpdateArgs} args - Arguments to update one QRTZ_SIMPLE_TRIGGERS.
     * @example
     * // Update one QRTZ_SIMPLE_TRIGGERS
     * const qRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRTZ_SIMPLE_TRIGGERSUpdateArgs>(args: SelectSubset<T, QRTZ_SIMPLE_TRIGGERSUpdateArgs<ExtArgs>>): Prisma__QRTZ_SIMPLE_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRTZ_SIMPLE_TRIGGERS.
     * @param {QRTZ_SIMPLE_TRIGGERSDeleteManyArgs} args - Arguments to filter QRTZ_SIMPLE_TRIGGERS to delete.
     * @example
     * // Delete a few QRTZ_SIMPLE_TRIGGERS
     * const { count } = await prisma.qRTZ_SIMPLE_TRIGGERS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRTZ_SIMPLE_TRIGGERSDeleteManyArgs>(args?: SelectSubset<T, QRTZ_SIMPLE_TRIGGERSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRTZ_SIMPLE_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPLE_TRIGGERSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRTZ_SIMPLE_TRIGGERS
     * const qRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRTZ_SIMPLE_TRIGGERSUpdateManyArgs>(args: SelectSubset<T, QRTZ_SIMPLE_TRIGGERSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QRTZ_SIMPLE_TRIGGERS.
     * @param {QRTZ_SIMPLE_TRIGGERSUpsertArgs} args - Arguments to update or create a QRTZ_SIMPLE_TRIGGERS.
     * @example
     * // Update or create a QRTZ_SIMPLE_TRIGGERS
     * const qRTZ_SIMPLE_TRIGGERS = await prisma.qRTZ_SIMPLE_TRIGGERS.upsert({
     *   create: {
     *     // ... data to create a QRTZ_SIMPLE_TRIGGERS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRTZ_SIMPLE_TRIGGERS we want to update
     *   }
     * })
     */
    upsert<T extends QRTZ_SIMPLE_TRIGGERSUpsertArgs>(args: SelectSubset<T, QRTZ_SIMPLE_TRIGGERSUpsertArgs<ExtArgs>>): Prisma__QRTZ_SIMPLE_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRTZ_SIMPLE_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPLE_TRIGGERSCountArgs} args - Arguments to filter QRTZ_SIMPLE_TRIGGERS to count.
     * @example
     * // Count the number of QRTZ_SIMPLE_TRIGGERS
     * const count = await prisma.qRTZ_SIMPLE_TRIGGERS.count({
     *   where: {
     *     // ... the filter for the QRTZ_SIMPLE_TRIGGERS we want to count
     *   }
     * })
    **/
    count<T extends QRTZ_SIMPLE_TRIGGERSCountArgs>(
      args?: Subset<T, QRTZ_SIMPLE_TRIGGERSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRTZ_SIMPLE_TRIGGERSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRTZ_SIMPLE_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPLE_TRIGGERSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRTZ_SIMPLE_TRIGGERSAggregateArgs>(args: Subset<T, QRTZ_SIMPLE_TRIGGERSAggregateArgs>): Prisma.PrismaPromise<GetQRTZ_SIMPLE_TRIGGERSAggregateType<T>>

    /**
     * Group by QRTZ_SIMPLE_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPLE_TRIGGERSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRTZ_SIMPLE_TRIGGERSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRTZ_SIMPLE_TRIGGERSGroupByArgs['orderBy'] }
        : { orderBy?: QRTZ_SIMPLE_TRIGGERSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRTZ_SIMPLE_TRIGGERSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRTZ_SIMPLE_TRIGGERSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRTZ_SIMPLE_TRIGGERS model
   */
  readonly fields: QRTZ_SIMPLE_TRIGGERSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRTZ_SIMPLE_TRIGGERS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRTZ_SIMPLE_TRIGGERSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    QRTZ_TRIGGERS<T extends QRTZ_TRIGGERSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QRTZ_TRIGGERSDefaultArgs<ExtArgs>>): Prisma__QRTZ_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRTZ_SIMPLE_TRIGGERS model
   */
  interface QRTZ_SIMPLE_TRIGGERSFieldRefs {
    readonly SCHED_NAME: FieldRef<"QRTZ_SIMPLE_TRIGGERS", 'String'>
    readonly TRIGGER_NAME: FieldRef<"QRTZ_SIMPLE_TRIGGERS", 'String'>
    readonly TRIGGER_GROUP: FieldRef<"QRTZ_SIMPLE_TRIGGERS", 'String'>
    readonly REPEAT_COUNT: FieldRef<"QRTZ_SIMPLE_TRIGGERS", 'BigInt'>
    readonly REPEAT_INTERVAL: FieldRef<"QRTZ_SIMPLE_TRIGGERS", 'BigInt'>
    readonly TIMES_TRIGGERED: FieldRef<"QRTZ_SIMPLE_TRIGGERS", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * QRTZ_SIMPLE_TRIGGERS findUnique
   */
  export type QRTZ_SIMPLE_TRIGGERSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPLE_TRIGGERS
     */
    select?: QRTZ_SIMPLE_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPLE_TRIGGERS
     */
    omit?: QRTZ_SIMPLE_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPLE_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_SIMPLE_TRIGGERS to fetch.
     */
    where: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_SIMPLE_TRIGGERS findUniqueOrThrow
   */
  export type QRTZ_SIMPLE_TRIGGERSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPLE_TRIGGERS
     */
    select?: QRTZ_SIMPLE_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPLE_TRIGGERS
     */
    omit?: QRTZ_SIMPLE_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPLE_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_SIMPLE_TRIGGERS to fetch.
     */
    where: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_SIMPLE_TRIGGERS findFirst
   */
  export type QRTZ_SIMPLE_TRIGGERSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPLE_TRIGGERS
     */
    select?: QRTZ_SIMPLE_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPLE_TRIGGERS
     */
    omit?: QRTZ_SIMPLE_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPLE_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_SIMPLE_TRIGGERS to fetch.
     */
    where?: QRTZ_SIMPLE_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_SIMPLE_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_SIMPLE_TRIGGERSOrderByWithRelationInput | QRTZ_SIMPLE_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_SIMPLE_TRIGGERS.
     */
    cursor?: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_SIMPLE_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_SIMPLE_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_SIMPLE_TRIGGERS.
     */
    distinct?: QRTZ_SIMPLE_TRIGGERSScalarFieldEnum | QRTZ_SIMPLE_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_SIMPLE_TRIGGERS findFirstOrThrow
   */
  export type QRTZ_SIMPLE_TRIGGERSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPLE_TRIGGERS
     */
    select?: QRTZ_SIMPLE_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPLE_TRIGGERS
     */
    omit?: QRTZ_SIMPLE_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPLE_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_SIMPLE_TRIGGERS to fetch.
     */
    where?: QRTZ_SIMPLE_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_SIMPLE_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_SIMPLE_TRIGGERSOrderByWithRelationInput | QRTZ_SIMPLE_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_SIMPLE_TRIGGERS.
     */
    cursor?: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_SIMPLE_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_SIMPLE_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_SIMPLE_TRIGGERS.
     */
    distinct?: QRTZ_SIMPLE_TRIGGERSScalarFieldEnum | QRTZ_SIMPLE_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_SIMPLE_TRIGGERS findMany
   */
  export type QRTZ_SIMPLE_TRIGGERSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPLE_TRIGGERS
     */
    select?: QRTZ_SIMPLE_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPLE_TRIGGERS
     */
    omit?: QRTZ_SIMPLE_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPLE_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_SIMPLE_TRIGGERS to fetch.
     */
    where?: QRTZ_SIMPLE_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_SIMPLE_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_SIMPLE_TRIGGERSOrderByWithRelationInput | QRTZ_SIMPLE_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRTZ_SIMPLE_TRIGGERS.
     */
    cursor?: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_SIMPLE_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_SIMPLE_TRIGGERS.
     */
    skip?: number
    distinct?: QRTZ_SIMPLE_TRIGGERSScalarFieldEnum | QRTZ_SIMPLE_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_SIMPLE_TRIGGERS create
   */
  export type QRTZ_SIMPLE_TRIGGERSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPLE_TRIGGERS
     */
    select?: QRTZ_SIMPLE_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPLE_TRIGGERS
     */
    omit?: QRTZ_SIMPLE_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPLE_TRIGGERSInclude<ExtArgs> | null
    /**
     * The data needed to create a QRTZ_SIMPLE_TRIGGERS.
     */
    data: XOR<QRTZ_SIMPLE_TRIGGERSCreateInput, QRTZ_SIMPLE_TRIGGERSUncheckedCreateInput>
  }

  /**
   * QRTZ_SIMPLE_TRIGGERS createMany
   */
  export type QRTZ_SIMPLE_TRIGGERSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRTZ_SIMPLE_TRIGGERS.
     */
    data: QRTZ_SIMPLE_TRIGGERSCreateManyInput | QRTZ_SIMPLE_TRIGGERSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRTZ_SIMPLE_TRIGGERS update
   */
  export type QRTZ_SIMPLE_TRIGGERSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPLE_TRIGGERS
     */
    select?: QRTZ_SIMPLE_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPLE_TRIGGERS
     */
    omit?: QRTZ_SIMPLE_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPLE_TRIGGERSInclude<ExtArgs> | null
    /**
     * The data needed to update a QRTZ_SIMPLE_TRIGGERS.
     */
    data: XOR<QRTZ_SIMPLE_TRIGGERSUpdateInput, QRTZ_SIMPLE_TRIGGERSUncheckedUpdateInput>
    /**
     * Choose, which QRTZ_SIMPLE_TRIGGERS to update.
     */
    where: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_SIMPLE_TRIGGERS updateMany
   */
  export type QRTZ_SIMPLE_TRIGGERSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRTZ_SIMPLE_TRIGGERS.
     */
    data: XOR<QRTZ_SIMPLE_TRIGGERSUpdateManyMutationInput, QRTZ_SIMPLE_TRIGGERSUncheckedUpdateManyInput>
    /**
     * Filter which QRTZ_SIMPLE_TRIGGERS to update
     */
    where?: QRTZ_SIMPLE_TRIGGERSWhereInput
    /**
     * Limit how many QRTZ_SIMPLE_TRIGGERS to update.
     */
    limit?: number
  }

  /**
   * QRTZ_SIMPLE_TRIGGERS upsert
   */
  export type QRTZ_SIMPLE_TRIGGERSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPLE_TRIGGERS
     */
    select?: QRTZ_SIMPLE_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPLE_TRIGGERS
     */
    omit?: QRTZ_SIMPLE_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPLE_TRIGGERSInclude<ExtArgs> | null
    /**
     * The filter to search for the QRTZ_SIMPLE_TRIGGERS to update in case it exists.
     */
    where: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
    /**
     * In case the QRTZ_SIMPLE_TRIGGERS found by the `where` argument doesn't exist, create a new QRTZ_SIMPLE_TRIGGERS with this data.
     */
    create: XOR<QRTZ_SIMPLE_TRIGGERSCreateInput, QRTZ_SIMPLE_TRIGGERSUncheckedCreateInput>
    /**
     * In case the QRTZ_SIMPLE_TRIGGERS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRTZ_SIMPLE_TRIGGERSUpdateInput, QRTZ_SIMPLE_TRIGGERSUncheckedUpdateInput>
  }

  /**
   * QRTZ_SIMPLE_TRIGGERS delete
   */
  export type QRTZ_SIMPLE_TRIGGERSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPLE_TRIGGERS
     */
    select?: QRTZ_SIMPLE_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPLE_TRIGGERS
     */
    omit?: QRTZ_SIMPLE_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPLE_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter which QRTZ_SIMPLE_TRIGGERS to delete.
     */
    where: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_SIMPLE_TRIGGERS deleteMany
   */
  export type QRTZ_SIMPLE_TRIGGERSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_SIMPLE_TRIGGERS to delete
     */
    where?: QRTZ_SIMPLE_TRIGGERSWhereInput
    /**
     * Limit how many QRTZ_SIMPLE_TRIGGERS to delete.
     */
    limit?: number
  }

  /**
   * QRTZ_SIMPLE_TRIGGERS without action
   */
  export type QRTZ_SIMPLE_TRIGGERSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPLE_TRIGGERS
     */
    select?: QRTZ_SIMPLE_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPLE_TRIGGERS
     */
    omit?: QRTZ_SIMPLE_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPLE_TRIGGERSInclude<ExtArgs> | null
  }


  /**
   * Model QRTZ_SIMPROP_TRIGGERS
   */

  export type AggregateQRTZ_SIMPROP_TRIGGERS = {
    _count: QRTZ_SIMPROP_TRIGGERSCountAggregateOutputType | null
    _avg: QRTZ_SIMPROP_TRIGGERSAvgAggregateOutputType | null
    _sum: QRTZ_SIMPROP_TRIGGERSSumAggregateOutputType | null
    _min: QRTZ_SIMPROP_TRIGGERSMinAggregateOutputType | null
    _max: QRTZ_SIMPROP_TRIGGERSMaxAggregateOutputType | null
  }

  export type QRTZ_SIMPROP_TRIGGERSAvgAggregateOutputType = {
    INT_PROP_1: number | null
    INT_PROP_2: number | null
    LONG_PROP_1: number | null
    LONG_PROP_2: number | null
    DEC_PROP_1: Decimal | null
    DEC_PROP_2: Decimal | null
  }

  export type QRTZ_SIMPROP_TRIGGERSSumAggregateOutputType = {
    INT_PROP_1: number | null
    INT_PROP_2: number | null
    LONG_PROP_1: bigint | null
    LONG_PROP_2: bigint | null
    DEC_PROP_1: Decimal | null
    DEC_PROP_2: Decimal | null
  }

  export type QRTZ_SIMPROP_TRIGGERSMinAggregateOutputType = {
    SCHED_NAME: string | null
    TRIGGER_NAME: string | null
    TRIGGER_GROUP: string | null
    STR_PROP_1: string | null
    STR_PROP_2: string | null
    STR_PROP_3: string | null
    INT_PROP_1: number | null
    INT_PROP_2: number | null
    LONG_PROP_1: bigint | null
    LONG_PROP_2: bigint | null
    DEC_PROP_1: Decimal | null
    DEC_PROP_2: Decimal | null
    BOOL_PROP_1: string | null
    BOOL_PROP_2: string | null
  }

  export type QRTZ_SIMPROP_TRIGGERSMaxAggregateOutputType = {
    SCHED_NAME: string | null
    TRIGGER_NAME: string | null
    TRIGGER_GROUP: string | null
    STR_PROP_1: string | null
    STR_PROP_2: string | null
    STR_PROP_3: string | null
    INT_PROP_1: number | null
    INT_PROP_2: number | null
    LONG_PROP_1: bigint | null
    LONG_PROP_2: bigint | null
    DEC_PROP_1: Decimal | null
    DEC_PROP_2: Decimal | null
    BOOL_PROP_1: string | null
    BOOL_PROP_2: string | null
  }

  export type QRTZ_SIMPROP_TRIGGERSCountAggregateOutputType = {
    SCHED_NAME: number
    TRIGGER_NAME: number
    TRIGGER_GROUP: number
    STR_PROP_1: number
    STR_PROP_2: number
    STR_PROP_3: number
    INT_PROP_1: number
    INT_PROP_2: number
    LONG_PROP_1: number
    LONG_PROP_2: number
    DEC_PROP_1: number
    DEC_PROP_2: number
    BOOL_PROP_1: number
    BOOL_PROP_2: number
    _all: number
  }


  export type QRTZ_SIMPROP_TRIGGERSAvgAggregateInputType = {
    INT_PROP_1?: true
    INT_PROP_2?: true
    LONG_PROP_1?: true
    LONG_PROP_2?: true
    DEC_PROP_1?: true
    DEC_PROP_2?: true
  }

  export type QRTZ_SIMPROP_TRIGGERSSumAggregateInputType = {
    INT_PROP_1?: true
    INT_PROP_2?: true
    LONG_PROP_1?: true
    LONG_PROP_2?: true
    DEC_PROP_1?: true
    DEC_PROP_2?: true
  }

  export type QRTZ_SIMPROP_TRIGGERSMinAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    STR_PROP_1?: true
    STR_PROP_2?: true
    STR_PROP_3?: true
    INT_PROP_1?: true
    INT_PROP_2?: true
    LONG_PROP_1?: true
    LONG_PROP_2?: true
    DEC_PROP_1?: true
    DEC_PROP_2?: true
    BOOL_PROP_1?: true
    BOOL_PROP_2?: true
  }

  export type QRTZ_SIMPROP_TRIGGERSMaxAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    STR_PROP_1?: true
    STR_PROP_2?: true
    STR_PROP_3?: true
    INT_PROP_1?: true
    INT_PROP_2?: true
    LONG_PROP_1?: true
    LONG_PROP_2?: true
    DEC_PROP_1?: true
    DEC_PROP_2?: true
    BOOL_PROP_1?: true
    BOOL_PROP_2?: true
  }

  export type QRTZ_SIMPROP_TRIGGERSCountAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    STR_PROP_1?: true
    STR_PROP_2?: true
    STR_PROP_3?: true
    INT_PROP_1?: true
    INT_PROP_2?: true
    LONG_PROP_1?: true
    LONG_PROP_2?: true
    DEC_PROP_1?: true
    DEC_PROP_2?: true
    BOOL_PROP_1?: true
    BOOL_PROP_2?: true
    _all?: true
  }

  export type QRTZ_SIMPROP_TRIGGERSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_SIMPROP_TRIGGERS to aggregate.
     */
    where?: QRTZ_SIMPROP_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_SIMPROP_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_SIMPROP_TRIGGERSOrderByWithRelationInput | QRTZ_SIMPROP_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_SIMPROP_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_SIMPROP_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRTZ_SIMPROP_TRIGGERS
    **/
    _count?: true | QRTZ_SIMPROP_TRIGGERSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QRTZ_SIMPROP_TRIGGERSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QRTZ_SIMPROP_TRIGGERSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRTZ_SIMPROP_TRIGGERSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRTZ_SIMPROP_TRIGGERSMaxAggregateInputType
  }

  export type GetQRTZ_SIMPROP_TRIGGERSAggregateType<T extends QRTZ_SIMPROP_TRIGGERSAggregateArgs> = {
        [P in keyof T & keyof AggregateQRTZ_SIMPROP_TRIGGERS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRTZ_SIMPROP_TRIGGERS[P]>
      : GetScalarType<T[P], AggregateQRTZ_SIMPROP_TRIGGERS[P]>
  }




  export type QRTZ_SIMPROP_TRIGGERSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRTZ_SIMPROP_TRIGGERSWhereInput
    orderBy?: QRTZ_SIMPROP_TRIGGERSOrderByWithAggregationInput | QRTZ_SIMPROP_TRIGGERSOrderByWithAggregationInput[]
    by: QRTZ_SIMPROP_TRIGGERSScalarFieldEnum[] | QRTZ_SIMPROP_TRIGGERSScalarFieldEnum
    having?: QRTZ_SIMPROP_TRIGGERSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRTZ_SIMPROP_TRIGGERSCountAggregateInputType | true
    _avg?: QRTZ_SIMPROP_TRIGGERSAvgAggregateInputType
    _sum?: QRTZ_SIMPROP_TRIGGERSSumAggregateInputType
    _min?: QRTZ_SIMPROP_TRIGGERSMinAggregateInputType
    _max?: QRTZ_SIMPROP_TRIGGERSMaxAggregateInputType
  }

  export type QRTZ_SIMPROP_TRIGGERSGroupByOutputType = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    STR_PROP_1: string | null
    STR_PROP_2: string | null
    STR_PROP_3: string | null
    INT_PROP_1: number | null
    INT_PROP_2: number | null
    LONG_PROP_1: bigint | null
    LONG_PROP_2: bigint | null
    DEC_PROP_1: Decimal | null
    DEC_PROP_2: Decimal | null
    BOOL_PROP_1: string | null
    BOOL_PROP_2: string | null
    _count: QRTZ_SIMPROP_TRIGGERSCountAggregateOutputType | null
    _avg: QRTZ_SIMPROP_TRIGGERSAvgAggregateOutputType | null
    _sum: QRTZ_SIMPROP_TRIGGERSSumAggregateOutputType | null
    _min: QRTZ_SIMPROP_TRIGGERSMinAggregateOutputType | null
    _max: QRTZ_SIMPROP_TRIGGERSMaxAggregateOutputType | null
  }

  type GetQRTZ_SIMPROP_TRIGGERSGroupByPayload<T extends QRTZ_SIMPROP_TRIGGERSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRTZ_SIMPROP_TRIGGERSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRTZ_SIMPROP_TRIGGERSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRTZ_SIMPROP_TRIGGERSGroupByOutputType[P]>
            : GetScalarType<T[P], QRTZ_SIMPROP_TRIGGERSGroupByOutputType[P]>
        }
      >
    >


  export type QRTZ_SIMPROP_TRIGGERSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SCHED_NAME?: boolean
    TRIGGER_NAME?: boolean
    TRIGGER_GROUP?: boolean
    STR_PROP_1?: boolean
    STR_PROP_2?: boolean
    STR_PROP_3?: boolean
    INT_PROP_1?: boolean
    INT_PROP_2?: boolean
    LONG_PROP_1?: boolean
    LONG_PROP_2?: boolean
    DEC_PROP_1?: boolean
    DEC_PROP_2?: boolean
    BOOL_PROP_1?: boolean
    BOOL_PROP_2?: boolean
    QRTZ_TRIGGERS?: boolean | QRTZ_TRIGGERSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qRTZ_SIMPROP_TRIGGERS"]>



  export type QRTZ_SIMPROP_TRIGGERSSelectScalar = {
    SCHED_NAME?: boolean
    TRIGGER_NAME?: boolean
    TRIGGER_GROUP?: boolean
    STR_PROP_1?: boolean
    STR_PROP_2?: boolean
    STR_PROP_3?: boolean
    INT_PROP_1?: boolean
    INT_PROP_2?: boolean
    LONG_PROP_1?: boolean
    LONG_PROP_2?: boolean
    DEC_PROP_1?: boolean
    DEC_PROP_2?: boolean
    BOOL_PROP_1?: boolean
    BOOL_PROP_2?: boolean
  }

  export type QRTZ_SIMPROP_TRIGGERSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SCHED_NAME" | "TRIGGER_NAME" | "TRIGGER_GROUP" | "STR_PROP_1" | "STR_PROP_2" | "STR_PROP_3" | "INT_PROP_1" | "INT_PROP_2" | "LONG_PROP_1" | "LONG_PROP_2" | "DEC_PROP_1" | "DEC_PROP_2" | "BOOL_PROP_1" | "BOOL_PROP_2", ExtArgs["result"]["qRTZ_SIMPROP_TRIGGERS"]>
  export type QRTZ_SIMPROP_TRIGGERSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QRTZ_TRIGGERS?: boolean | QRTZ_TRIGGERSDefaultArgs<ExtArgs>
  }

  export type $QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRTZ_SIMPROP_TRIGGERS"
    objects: {
      QRTZ_TRIGGERS: Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      SCHED_NAME: string
      TRIGGER_NAME: string
      TRIGGER_GROUP: string
      STR_PROP_1: string | null
      STR_PROP_2: string | null
      STR_PROP_3: string | null
      INT_PROP_1: number | null
      INT_PROP_2: number | null
      LONG_PROP_1: bigint | null
      LONG_PROP_2: bigint | null
      DEC_PROP_1: Prisma.Decimal | null
      DEC_PROP_2: Prisma.Decimal | null
      BOOL_PROP_1: string | null
      BOOL_PROP_2: string | null
    }, ExtArgs["result"]["qRTZ_SIMPROP_TRIGGERS"]>
    composites: {}
  }

  type QRTZ_SIMPROP_TRIGGERSGetPayload<S extends boolean | null | undefined | QRTZ_SIMPROP_TRIGGERSDefaultArgs> = $Result.GetResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload, S>

  type QRTZ_SIMPROP_TRIGGERSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRTZ_SIMPROP_TRIGGERSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRTZ_SIMPROP_TRIGGERSCountAggregateInputType | true
    }

  export interface QRTZ_SIMPROP_TRIGGERSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRTZ_SIMPROP_TRIGGERS'], meta: { name: 'QRTZ_SIMPROP_TRIGGERS' } }
    /**
     * Find zero or one QRTZ_SIMPROP_TRIGGERS that matches the filter.
     * @param {QRTZ_SIMPROP_TRIGGERSFindUniqueArgs} args - Arguments to find a QRTZ_SIMPROP_TRIGGERS
     * @example
     * // Get one QRTZ_SIMPROP_TRIGGERS
     * const qRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRTZ_SIMPROP_TRIGGERSFindUniqueArgs>(args: SelectSubset<T, QRTZ_SIMPROP_TRIGGERSFindUniqueArgs<ExtArgs>>): Prisma__QRTZ_SIMPROP_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRTZ_SIMPROP_TRIGGERS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRTZ_SIMPROP_TRIGGERSFindUniqueOrThrowArgs} args - Arguments to find a QRTZ_SIMPROP_TRIGGERS
     * @example
     * // Get one QRTZ_SIMPROP_TRIGGERS
     * const qRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRTZ_SIMPROP_TRIGGERSFindUniqueOrThrowArgs>(args: SelectSubset<T, QRTZ_SIMPROP_TRIGGERSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRTZ_SIMPROP_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_SIMPROP_TRIGGERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPROP_TRIGGERSFindFirstArgs} args - Arguments to find a QRTZ_SIMPROP_TRIGGERS
     * @example
     * // Get one QRTZ_SIMPROP_TRIGGERS
     * const qRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRTZ_SIMPROP_TRIGGERSFindFirstArgs>(args?: SelectSubset<T, QRTZ_SIMPROP_TRIGGERSFindFirstArgs<ExtArgs>>): Prisma__QRTZ_SIMPROP_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_SIMPROP_TRIGGERS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPROP_TRIGGERSFindFirstOrThrowArgs} args - Arguments to find a QRTZ_SIMPROP_TRIGGERS
     * @example
     * // Get one QRTZ_SIMPROP_TRIGGERS
     * const qRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRTZ_SIMPROP_TRIGGERSFindFirstOrThrowArgs>(args?: SelectSubset<T, QRTZ_SIMPROP_TRIGGERSFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRTZ_SIMPROP_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRTZ_SIMPROP_TRIGGERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPROP_TRIGGERSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRTZ_SIMPROP_TRIGGERS
     * const qRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.findMany()
     * 
     * // Get first 10 QRTZ_SIMPROP_TRIGGERS
     * const qRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.findMany({ take: 10 })
     * 
     * // Only select the `SCHED_NAME`
     * const qRTZ_SIMPROP_TRIGGERSWithSCHED_NAMEOnly = await prisma.qRTZ_SIMPROP_TRIGGERS.findMany({ select: { SCHED_NAME: true } })
     * 
     */
    findMany<T extends QRTZ_SIMPROP_TRIGGERSFindManyArgs>(args?: SelectSubset<T, QRTZ_SIMPROP_TRIGGERSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRTZ_SIMPROP_TRIGGERS.
     * @param {QRTZ_SIMPROP_TRIGGERSCreateArgs} args - Arguments to create a QRTZ_SIMPROP_TRIGGERS.
     * @example
     * // Create one QRTZ_SIMPROP_TRIGGERS
     * const QRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.create({
     *   data: {
     *     // ... data to create a QRTZ_SIMPROP_TRIGGERS
     *   }
     * })
     * 
     */
    create<T extends QRTZ_SIMPROP_TRIGGERSCreateArgs>(args: SelectSubset<T, QRTZ_SIMPROP_TRIGGERSCreateArgs<ExtArgs>>): Prisma__QRTZ_SIMPROP_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRTZ_SIMPROP_TRIGGERS.
     * @param {QRTZ_SIMPROP_TRIGGERSCreateManyArgs} args - Arguments to create many QRTZ_SIMPROP_TRIGGERS.
     * @example
     * // Create many QRTZ_SIMPROP_TRIGGERS
     * const qRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRTZ_SIMPROP_TRIGGERSCreateManyArgs>(args?: SelectSubset<T, QRTZ_SIMPROP_TRIGGERSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QRTZ_SIMPROP_TRIGGERS.
     * @param {QRTZ_SIMPROP_TRIGGERSDeleteArgs} args - Arguments to delete one QRTZ_SIMPROP_TRIGGERS.
     * @example
     * // Delete one QRTZ_SIMPROP_TRIGGERS
     * const QRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.delete({
     *   where: {
     *     // ... filter to delete one QRTZ_SIMPROP_TRIGGERS
     *   }
     * })
     * 
     */
    delete<T extends QRTZ_SIMPROP_TRIGGERSDeleteArgs>(args: SelectSubset<T, QRTZ_SIMPROP_TRIGGERSDeleteArgs<ExtArgs>>): Prisma__QRTZ_SIMPROP_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRTZ_SIMPROP_TRIGGERS.
     * @param {QRTZ_SIMPROP_TRIGGERSUpdateArgs} args - Arguments to update one QRTZ_SIMPROP_TRIGGERS.
     * @example
     * // Update one QRTZ_SIMPROP_TRIGGERS
     * const qRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRTZ_SIMPROP_TRIGGERSUpdateArgs>(args: SelectSubset<T, QRTZ_SIMPROP_TRIGGERSUpdateArgs<ExtArgs>>): Prisma__QRTZ_SIMPROP_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRTZ_SIMPROP_TRIGGERS.
     * @param {QRTZ_SIMPROP_TRIGGERSDeleteManyArgs} args - Arguments to filter QRTZ_SIMPROP_TRIGGERS to delete.
     * @example
     * // Delete a few QRTZ_SIMPROP_TRIGGERS
     * const { count } = await prisma.qRTZ_SIMPROP_TRIGGERS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRTZ_SIMPROP_TRIGGERSDeleteManyArgs>(args?: SelectSubset<T, QRTZ_SIMPROP_TRIGGERSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRTZ_SIMPROP_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPROP_TRIGGERSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRTZ_SIMPROP_TRIGGERS
     * const qRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRTZ_SIMPROP_TRIGGERSUpdateManyArgs>(args: SelectSubset<T, QRTZ_SIMPROP_TRIGGERSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QRTZ_SIMPROP_TRIGGERS.
     * @param {QRTZ_SIMPROP_TRIGGERSUpsertArgs} args - Arguments to update or create a QRTZ_SIMPROP_TRIGGERS.
     * @example
     * // Update or create a QRTZ_SIMPROP_TRIGGERS
     * const qRTZ_SIMPROP_TRIGGERS = await prisma.qRTZ_SIMPROP_TRIGGERS.upsert({
     *   create: {
     *     // ... data to create a QRTZ_SIMPROP_TRIGGERS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRTZ_SIMPROP_TRIGGERS we want to update
     *   }
     * })
     */
    upsert<T extends QRTZ_SIMPROP_TRIGGERSUpsertArgs>(args: SelectSubset<T, QRTZ_SIMPROP_TRIGGERSUpsertArgs<ExtArgs>>): Prisma__QRTZ_SIMPROP_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRTZ_SIMPROP_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPROP_TRIGGERSCountArgs} args - Arguments to filter QRTZ_SIMPROP_TRIGGERS to count.
     * @example
     * // Count the number of QRTZ_SIMPROP_TRIGGERS
     * const count = await prisma.qRTZ_SIMPROP_TRIGGERS.count({
     *   where: {
     *     // ... the filter for the QRTZ_SIMPROP_TRIGGERS we want to count
     *   }
     * })
    **/
    count<T extends QRTZ_SIMPROP_TRIGGERSCountArgs>(
      args?: Subset<T, QRTZ_SIMPROP_TRIGGERSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRTZ_SIMPROP_TRIGGERSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRTZ_SIMPROP_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPROP_TRIGGERSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRTZ_SIMPROP_TRIGGERSAggregateArgs>(args: Subset<T, QRTZ_SIMPROP_TRIGGERSAggregateArgs>): Prisma.PrismaPromise<GetQRTZ_SIMPROP_TRIGGERSAggregateType<T>>

    /**
     * Group by QRTZ_SIMPROP_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_SIMPROP_TRIGGERSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRTZ_SIMPROP_TRIGGERSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRTZ_SIMPROP_TRIGGERSGroupByArgs['orderBy'] }
        : { orderBy?: QRTZ_SIMPROP_TRIGGERSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRTZ_SIMPROP_TRIGGERSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRTZ_SIMPROP_TRIGGERSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRTZ_SIMPROP_TRIGGERS model
   */
  readonly fields: QRTZ_SIMPROP_TRIGGERSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRTZ_SIMPROP_TRIGGERS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRTZ_SIMPROP_TRIGGERSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    QRTZ_TRIGGERS<T extends QRTZ_TRIGGERSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QRTZ_TRIGGERSDefaultArgs<ExtArgs>>): Prisma__QRTZ_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRTZ_SIMPROP_TRIGGERS model
   */
  interface QRTZ_SIMPROP_TRIGGERSFieldRefs {
    readonly SCHED_NAME: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'String'>
    readonly TRIGGER_NAME: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'String'>
    readonly TRIGGER_GROUP: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'String'>
    readonly STR_PROP_1: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'String'>
    readonly STR_PROP_2: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'String'>
    readonly STR_PROP_3: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'String'>
    readonly INT_PROP_1: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'Int'>
    readonly INT_PROP_2: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'Int'>
    readonly LONG_PROP_1: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'BigInt'>
    readonly LONG_PROP_2: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'BigInt'>
    readonly DEC_PROP_1: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'Decimal'>
    readonly DEC_PROP_2: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'Decimal'>
    readonly BOOL_PROP_1: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'String'>
    readonly BOOL_PROP_2: FieldRef<"QRTZ_SIMPROP_TRIGGERS", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QRTZ_SIMPROP_TRIGGERS findUnique
   */
  export type QRTZ_SIMPROP_TRIGGERSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPROP_TRIGGERS
     */
    select?: QRTZ_SIMPROP_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPROP_TRIGGERS
     */
    omit?: QRTZ_SIMPROP_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPROP_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_SIMPROP_TRIGGERS to fetch.
     */
    where: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_SIMPROP_TRIGGERS findUniqueOrThrow
   */
  export type QRTZ_SIMPROP_TRIGGERSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPROP_TRIGGERS
     */
    select?: QRTZ_SIMPROP_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPROP_TRIGGERS
     */
    omit?: QRTZ_SIMPROP_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPROP_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_SIMPROP_TRIGGERS to fetch.
     */
    where: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_SIMPROP_TRIGGERS findFirst
   */
  export type QRTZ_SIMPROP_TRIGGERSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPROP_TRIGGERS
     */
    select?: QRTZ_SIMPROP_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPROP_TRIGGERS
     */
    omit?: QRTZ_SIMPROP_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPROP_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_SIMPROP_TRIGGERS to fetch.
     */
    where?: QRTZ_SIMPROP_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_SIMPROP_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_SIMPROP_TRIGGERSOrderByWithRelationInput | QRTZ_SIMPROP_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_SIMPROP_TRIGGERS.
     */
    cursor?: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_SIMPROP_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_SIMPROP_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_SIMPROP_TRIGGERS.
     */
    distinct?: QRTZ_SIMPROP_TRIGGERSScalarFieldEnum | QRTZ_SIMPROP_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_SIMPROP_TRIGGERS findFirstOrThrow
   */
  export type QRTZ_SIMPROP_TRIGGERSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPROP_TRIGGERS
     */
    select?: QRTZ_SIMPROP_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPROP_TRIGGERS
     */
    omit?: QRTZ_SIMPROP_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPROP_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_SIMPROP_TRIGGERS to fetch.
     */
    where?: QRTZ_SIMPROP_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_SIMPROP_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_SIMPROP_TRIGGERSOrderByWithRelationInput | QRTZ_SIMPROP_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_SIMPROP_TRIGGERS.
     */
    cursor?: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_SIMPROP_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_SIMPROP_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_SIMPROP_TRIGGERS.
     */
    distinct?: QRTZ_SIMPROP_TRIGGERSScalarFieldEnum | QRTZ_SIMPROP_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_SIMPROP_TRIGGERS findMany
   */
  export type QRTZ_SIMPROP_TRIGGERSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPROP_TRIGGERS
     */
    select?: QRTZ_SIMPROP_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPROP_TRIGGERS
     */
    omit?: QRTZ_SIMPROP_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPROP_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_SIMPROP_TRIGGERS to fetch.
     */
    where?: QRTZ_SIMPROP_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_SIMPROP_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_SIMPROP_TRIGGERSOrderByWithRelationInput | QRTZ_SIMPROP_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRTZ_SIMPROP_TRIGGERS.
     */
    cursor?: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_SIMPROP_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_SIMPROP_TRIGGERS.
     */
    skip?: number
    distinct?: QRTZ_SIMPROP_TRIGGERSScalarFieldEnum | QRTZ_SIMPROP_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_SIMPROP_TRIGGERS create
   */
  export type QRTZ_SIMPROP_TRIGGERSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPROP_TRIGGERS
     */
    select?: QRTZ_SIMPROP_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPROP_TRIGGERS
     */
    omit?: QRTZ_SIMPROP_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPROP_TRIGGERSInclude<ExtArgs> | null
    /**
     * The data needed to create a QRTZ_SIMPROP_TRIGGERS.
     */
    data: XOR<QRTZ_SIMPROP_TRIGGERSCreateInput, QRTZ_SIMPROP_TRIGGERSUncheckedCreateInput>
  }

  /**
   * QRTZ_SIMPROP_TRIGGERS createMany
   */
  export type QRTZ_SIMPROP_TRIGGERSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRTZ_SIMPROP_TRIGGERS.
     */
    data: QRTZ_SIMPROP_TRIGGERSCreateManyInput | QRTZ_SIMPROP_TRIGGERSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRTZ_SIMPROP_TRIGGERS update
   */
  export type QRTZ_SIMPROP_TRIGGERSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPROP_TRIGGERS
     */
    select?: QRTZ_SIMPROP_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPROP_TRIGGERS
     */
    omit?: QRTZ_SIMPROP_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPROP_TRIGGERSInclude<ExtArgs> | null
    /**
     * The data needed to update a QRTZ_SIMPROP_TRIGGERS.
     */
    data: XOR<QRTZ_SIMPROP_TRIGGERSUpdateInput, QRTZ_SIMPROP_TRIGGERSUncheckedUpdateInput>
    /**
     * Choose, which QRTZ_SIMPROP_TRIGGERS to update.
     */
    where: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_SIMPROP_TRIGGERS updateMany
   */
  export type QRTZ_SIMPROP_TRIGGERSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRTZ_SIMPROP_TRIGGERS.
     */
    data: XOR<QRTZ_SIMPROP_TRIGGERSUpdateManyMutationInput, QRTZ_SIMPROP_TRIGGERSUncheckedUpdateManyInput>
    /**
     * Filter which QRTZ_SIMPROP_TRIGGERS to update
     */
    where?: QRTZ_SIMPROP_TRIGGERSWhereInput
    /**
     * Limit how many QRTZ_SIMPROP_TRIGGERS to update.
     */
    limit?: number
  }

  /**
   * QRTZ_SIMPROP_TRIGGERS upsert
   */
  export type QRTZ_SIMPROP_TRIGGERSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPROP_TRIGGERS
     */
    select?: QRTZ_SIMPROP_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPROP_TRIGGERS
     */
    omit?: QRTZ_SIMPROP_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPROP_TRIGGERSInclude<ExtArgs> | null
    /**
     * The filter to search for the QRTZ_SIMPROP_TRIGGERS to update in case it exists.
     */
    where: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
    /**
     * In case the QRTZ_SIMPROP_TRIGGERS found by the `where` argument doesn't exist, create a new QRTZ_SIMPROP_TRIGGERS with this data.
     */
    create: XOR<QRTZ_SIMPROP_TRIGGERSCreateInput, QRTZ_SIMPROP_TRIGGERSUncheckedCreateInput>
    /**
     * In case the QRTZ_SIMPROP_TRIGGERS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRTZ_SIMPROP_TRIGGERSUpdateInput, QRTZ_SIMPROP_TRIGGERSUncheckedUpdateInput>
  }

  /**
   * QRTZ_SIMPROP_TRIGGERS delete
   */
  export type QRTZ_SIMPROP_TRIGGERSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPROP_TRIGGERS
     */
    select?: QRTZ_SIMPROP_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPROP_TRIGGERS
     */
    omit?: QRTZ_SIMPROP_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPROP_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter which QRTZ_SIMPROP_TRIGGERS to delete.
     */
    where: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_SIMPROP_TRIGGERS deleteMany
   */
  export type QRTZ_SIMPROP_TRIGGERSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_SIMPROP_TRIGGERS to delete
     */
    where?: QRTZ_SIMPROP_TRIGGERSWhereInput
    /**
     * Limit how many QRTZ_SIMPROP_TRIGGERS to delete.
     */
    limit?: number
  }

  /**
   * QRTZ_SIMPROP_TRIGGERS without action
   */
  export type QRTZ_SIMPROP_TRIGGERSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPROP_TRIGGERS
     */
    select?: QRTZ_SIMPROP_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPROP_TRIGGERS
     */
    omit?: QRTZ_SIMPROP_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPROP_TRIGGERSInclude<ExtArgs> | null
  }


  /**
   * Model QRTZ_TRIGGERS
   */

  export type AggregateQRTZ_TRIGGERS = {
    _count: QRTZ_TRIGGERSCountAggregateOutputType | null
    _avg: QRTZ_TRIGGERSAvgAggregateOutputType | null
    _sum: QRTZ_TRIGGERSSumAggregateOutputType | null
    _min: QRTZ_TRIGGERSMinAggregateOutputType | null
    _max: QRTZ_TRIGGERSMaxAggregateOutputType | null
  }

  export type QRTZ_TRIGGERSAvgAggregateOutputType = {
    NEXT_FIRE_TIME: number | null
    PREV_FIRE_TIME: number | null
    PRIORITY: number | null
    START_TIME: number | null
    END_TIME: number | null
    MISFIRE_INSTR: number | null
  }

  export type QRTZ_TRIGGERSSumAggregateOutputType = {
    NEXT_FIRE_TIME: bigint | null
    PREV_FIRE_TIME: bigint | null
    PRIORITY: number | null
    START_TIME: bigint | null
    END_TIME: bigint | null
    MISFIRE_INSTR: number | null
  }

  export type QRTZ_TRIGGERSMinAggregateOutputType = {
    SCHED_NAME: string | null
    TRIGGER_NAME: string | null
    TRIGGER_GROUP: string | null
    JOB_NAME: string | null
    JOB_GROUP: string | null
    DESCRIPTION: string | null
    NEXT_FIRE_TIME: bigint | null
    PREV_FIRE_TIME: bigint | null
    PRIORITY: number | null
    TRIGGER_STATE: string | null
    TRIGGER_TYPE: string | null
    START_TIME: bigint | null
    END_TIME: bigint | null
    CALENDAR_NAME: string | null
    MISFIRE_INSTR: number | null
    JOB_DATA: Uint8Array | null
  }

  export type QRTZ_TRIGGERSMaxAggregateOutputType = {
    SCHED_NAME: string | null
    TRIGGER_NAME: string | null
    TRIGGER_GROUP: string | null
    JOB_NAME: string | null
    JOB_GROUP: string | null
    DESCRIPTION: string | null
    NEXT_FIRE_TIME: bigint | null
    PREV_FIRE_TIME: bigint | null
    PRIORITY: number | null
    TRIGGER_STATE: string | null
    TRIGGER_TYPE: string | null
    START_TIME: bigint | null
    END_TIME: bigint | null
    CALENDAR_NAME: string | null
    MISFIRE_INSTR: number | null
    JOB_DATA: Uint8Array | null
  }

  export type QRTZ_TRIGGERSCountAggregateOutputType = {
    SCHED_NAME: number
    TRIGGER_NAME: number
    TRIGGER_GROUP: number
    JOB_NAME: number
    JOB_GROUP: number
    DESCRIPTION: number
    NEXT_FIRE_TIME: number
    PREV_FIRE_TIME: number
    PRIORITY: number
    TRIGGER_STATE: number
    TRIGGER_TYPE: number
    START_TIME: number
    END_TIME: number
    CALENDAR_NAME: number
    MISFIRE_INSTR: number
    JOB_DATA: number
    _all: number
  }


  export type QRTZ_TRIGGERSAvgAggregateInputType = {
    NEXT_FIRE_TIME?: true
    PREV_FIRE_TIME?: true
    PRIORITY?: true
    START_TIME?: true
    END_TIME?: true
    MISFIRE_INSTR?: true
  }

  export type QRTZ_TRIGGERSSumAggregateInputType = {
    NEXT_FIRE_TIME?: true
    PREV_FIRE_TIME?: true
    PRIORITY?: true
    START_TIME?: true
    END_TIME?: true
    MISFIRE_INSTR?: true
  }

  export type QRTZ_TRIGGERSMinAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    JOB_NAME?: true
    JOB_GROUP?: true
    DESCRIPTION?: true
    NEXT_FIRE_TIME?: true
    PREV_FIRE_TIME?: true
    PRIORITY?: true
    TRIGGER_STATE?: true
    TRIGGER_TYPE?: true
    START_TIME?: true
    END_TIME?: true
    CALENDAR_NAME?: true
    MISFIRE_INSTR?: true
    JOB_DATA?: true
  }

  export type QRTZ_TRIGGERSMaxAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    JOB_NAME?: true
    JOB_GROUP?: true
    DESCRIPTION?: true
    NEXT_FIRE_TIME?: true
    PREV_FIRE_TIME?: true
    PRIORITY?: true
    TRIGGER_STATE?: true
    TRIGGER_TYPE?: true
    START_TIME?: true
    END_TIME?: true
    CALENDAR_NAME?: true
    MISFIRE_INSTR?: true
    JOB_DATA?: true
  }

  export type QRTZ_TRIGGERSCountAggregateInputType = {
    SCHED_NAME?: true
    TRIGGER_NAME?: true
    TRIGGER_GROUP?: true
    JOB_NAME?: true
    JOB_GROUP?: true
    DESCRIPTION?: true
    NEXT_FIRE_TIME?: true
    PREV_FIRE_TIME?: true
    PRIORITY?: true
    TRIGGER_STATE?: true
    TRIGGER_TYPE?: true
    START_TIME?: true
    END_TIME?: true
    CALENDAR_NAME?: true
    MISFIRE_INSTR?: true
    JOB_DATA?: true
    _all?: true
  }

  export type QRTZ_TRIGGERSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_TRIGGERS to aggregate.
     */
    where?: QRTZ_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_TRIGGERSOrderByWithRelationInput | QRTZ_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRTZ_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRTZ_TRIGGERS
    **/
    _count?: true | QRTZ_TRIGGERSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QRTZ_TRIGGERSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QRTZ_TRIGGERSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRTZ_TRIGGERSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRTZ_TRIGGERSMaxAggregateInputType
  }

  export type GetQRTZ_TRIGGERSAggregateType<T extends QRTZ_TRIGGERSAggregateArgs> = {
        [P in keyof T & keyof AggregateQRTZ_TRIGGERS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRTZ_TRIGGERS[P]>
      : GetScalarType<T[P], AggregateQRTZ_TRIGGERS[P]>
  }




  export type QRTZ_TRIGGERSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRTZ_TRIGGERSWhereInput
    orderBy?: QRTZ_TRIGGERSOrderByWithAggregationInput | QRTZ_TRIGGERSOrderByWithAggregationInput[]
    by: QRTZ_TRIGGERSScalarFieldEnum[] | QRTZ_TRIGGERSScalarFieldEnum
    having?: QRTZ_TRIGGERSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRTZ_TRIGGERSCountAggregateInputType | true
    _avg?: QRTZ_TRIGGERSAvgAggregateInputType
    _sum?: QRTZ_TRIGGERSSumAggregateInputType
    _min?: QRTZ_TRIGGERSMinAggregateInputType
    _max?: QRTZ_TRIGGERSMaxAggregateInputType
  }

  export type QRTZ_TRIGGERSGroupByOutputType = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION: string | null
    NEXT_FIRE_TIME: bigint | null
    PREV_FIRE_TIME: bigint | null
    PRIORITY: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint
    END_TIME: bigint | null
    CALENDAR_NAME: string | null
    MISFIRE_INSTR: number | null
    JOB_DATA: Uint8Array | null
    _count: QRTZ_TRIGGERSCountAggregateOutputType | null
    _avg: QRTZ_TRIGGERSAvgAggregateOutputType | null
    _sum: QRTZ_TRIGGERSSumAggregateOutputType | null
    _min: QRTZ_TRIGGERSMinAggregateOutputType | null
    _max: QRTZ_TRIGGERSMaxAggregateOutputType | null
  }

  type GetQRTZ_TRIGGERSGroupByPayload<T extends QRTZ_TRIGGERSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRTZ_TRIGGERSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRTZ_TRIGGERSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRTZ_TRIGGERSGroupByOutputType[P]>
            : GetScalarType<T[P], QRTZ_TRIGGERSGroupByOutputType[P]>
        }
      >
    >


  export type QRTZ_TRIGGERSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SCHED_NAME?: boolean
    TRIGGER_NAME?: boolean
    TRIGGER_GROUP?: boolean
    JOB_NAME?: boolean
    JOB_GROUP?: boolean
    DESCRIPTION?: boolean
    NEXT_FIRE_TIME?: boolean
    PREV_FIRE_TIME?: boolean
    PRIORITY?: boolean
    TRIGGER_STATE?: boolean
    TRIGGER_TYPE?: boolean
    START_TIME?: boolean
    END_TIME?: boolean
    CALENDAR_NAME?: boolean
    MISFIRE_INSTR?: boolean
    JOB_DATA?: boolean
    QRTZ_BLOB_TRIGGERS?: boolean | QRTZ_TRIGGERS$QRTZ_BLOB_TRIGGERSArgs<ExtArgs>
    QRTZ_CRON_TRIGGERS?: boolean | QRTZ_TRIGGERS$QRTZ_CRON_TRIGGERSArgs<ExtArgs>
    QRTZ_SIMPLE_TRIGGERS?: boolean | QRTZ_TRIGGERS$QRTZ_SIMPLE_TRIGGERSArgs<ExtArgs>
    QRTZ_SIMPROP_TRIGGERS?: boolean | QRTZ_TRIGGERS$QRTZ_SIMPROP_TRIGGERSArgs<ExtArgs>
    QRTZ_JOB_DETAILS?: boolean | QRTZ_JOB_DETAILSDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qRTZ_TRIGGERS"]>



  export type QRTZ_TRIGGERSSelectScalar = {
    SCHED_NAME?: boolean
    TRIGGER_NAME?: boolean
    TRIGGER_GROUP?: boolean
    JOB_NAME?: boolean
    JOB_GROUP?: boolean
    DESCRIPTION?: boolean
    NEXT_FIRE_TIME?: boolean
    PREV_FIRE_TIME?: boolean
    PRIORITY?: boolean
    TRIGGER_STATE?: boolean
    TRIGGER_TYPE?: boolean
    START_TIME?: boolean
    END_TIME?: boolean
    CALENDAR_NAME?: boolean
    MISFIRE_INSTR?: boolean
    JOB_DATA?: boolean
  }

  export type QRTZ_TRIGGERSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SCHED_NAME" | "TRIGGER_NAME" | "TRIGGER_GROUP" | "JOB_NAME" | "JOB_GROUP" | "DESCRIPTION" | "NEXT_FIRE_TIME" | "PREV_FIRE_TIME" | "PRIORITY" | "TRIGGER_STATE" | "TRIGGER_TYPE" | "START_TIME" | "END_TIME" | "CALENDAR_NAME" | "MISFIRE_INSTR" | "JOB_DATA", ExtArgs["result"]["qRTZ_TRIGGERS"]>
  export type QRTZ_TRIGGERSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QRTZ_BLOB_TRIGGERS?: boolean | QRTZ_TRIGGERS$QRTZ_BLOB_TRIGGERSArgs<ExtArgs>
    QRTZ_CRON_TRIGGERS?: boolean | QRTZ_TRIGGERS$QRTZ_CRON_TRIGGERSArgs<ExtArgs>
    QRTZ_SIMPLE_TRIGGERS?: boolean | QRTZ_TRIGGERS$QRTZ_SIMPLE_TRIGGERSArgs<ExtArgs>
    QRTZ_SIMPROP_TRIGGERS?: boolean | QRTZ_TRIGGERS$QRTZ_SIMPROP_TRIGGERSArgs<ExtArgs>
    QRTZ_JOB_DETAILS?: boolean | QRTZ_JOB_DETAILSDefaultArgs<ExtArgs>
  }

  export type $QRTZ_TRIGGERSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRTZ_TRIGGERS"
    objects: {
      QRTZ_BLOB_TRIGGERS: Prisma.$QRTZ_BLOB_TRIGGERSPayload<ExtArgs> | null
      QRTZ_CRON_TRIGGERS: Prisma.$QRTZ_CRON_TRIGGERSPayload<ExtArgs> | null
      QRTZ_SIMPLE_TRIGGERS: Prisma.$QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs> | null
      QRTZ_SIMPROP_TRIGGERS: Prisma.$QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs> | null
      QRTZ_JOB_DETAILS: Prisma.$QRTZ_JOB_DETAILSPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      SCHED_NAME: string
      TRIGGER_NAME: string
      TRIGGER_GROUP: string
      JOB_NAME: string
      JOB_GROUP: string
      DESCRIPTION: string | null
      NEXT_FIRE_TIME: bigint | null
      PREV_FIRE_TIME: bigint | null
      PRIORITY: number | null
      TRIGGER_STATE: string
      TRIGGER_TYPE: string
      START_TIME: bigint
      END_TIME: bigint | null
      CALENDAR_NAME: string | null
      MISFIRE_INSTR: number | null
      JOB_DATA: Uint8Array | null
    }, ExtArgs["result"]["qRTZ_TRIGGERS"]>
    composites: {}
  }

  type QRTZ_TRIGGERSGetPayload<S extends boolean | null | undefined | QRTZ_TRIGGERSDefaultArgs> = $Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload, S>

  type QRTZ_TRIGGERSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRTZ_TRIGGERSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRTZ_TRIGGERSCountAggregateInputType | true
    }

  export interface QRTZ_TRIGGERSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRTZ_TRIGGERS'], meta: { name: 'QRTZ_TRIGGERS' } }
    /**
     * Find zero or one QRTZ_TRIGGERS that matches the filter.
     * @param {QRTZ_TRIGGERSFindUniqueArgs} args - Arguments to find a QRTZ_TRIGGERS
     * @example
     * // Get one QRTZ_TRIGGERS
     * const qRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRTZ_TRIGGERSFindUniqueArgs>(args: SelectSubset<T, QRTZ_TRIGGERSFindUniqueArgs<ExtArgs>>): Prisma__QRTZ_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRTZ_TRIGGERS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRTZ_TRIGGERSFindUniqueOrThrowArgs} args - Arguments to find a QRTZ_TRIGGERS
     * @example
     * // Get one QRTZ_TRIGGERS
     * const qRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRTZ_TRIGGERSFindUniqueOrThrowArgs>(args: SelectSubset<T, QRTZ_TRIGGERSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRTZ_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_TRIGGERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_TRIGGERSFindFirstArgs} args - Arguments to find a QRTZ_TRIGGERS
     * @example
     * // Get one QRTZ_TRIGGERS
     * const qRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRTZ_TRIGGERSFindFirstArgs>(args?: SelectSubset<T, QRTZ_TRIGGERSFindFirstArgs<ExtArgs>>): Prisma__QRTZ_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRTZ_TRIGGERS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_TRIGGERSFindFirstOrThrowArgs} args - Arguments to find a QRTZ_TRIGGERS
     * @example
     * // Get one QRTZ_TRIGGERS
     * const qRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRTZ_TRIGGERSFindFirstOrThrowArgs>(args?: SelectSubset<T, QRTZ_TRIGGERSFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRTZ_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRTZ_TRIGGERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_TRIGGERSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRTZ_TRIGGERS
     * const qRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.findMany()
     * 
     * // Get first 10 QRTZ_TRIGGERS
     * const qRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.findMany({ take: 10 })
     * 
     * // Only select the `SCHED_NAME`
     * const qRTZ_TRIGGERSWithSCHED_NAMEOnly = await prisma.qRTZ_TRIGGERS.findMany({ select: { SCHED_NAME: true } })
     * 
     */
    findMany<T extends QRTZ_TRIGGERSFindManyArgs>(args?: SelectSubset<T, QRTZ_TRIGGERSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRTZ_TRIGGERS.
     * @param {QRTZ_TRIGGERSCreateArgs} args - Arguments to create a QRTZ_TRIGGERS.
     * @example
     * // Create one QRTZ_TRIGGERS
     * const QRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.create({
     *   data: {
     *     // ... data to create a QRTZ_TRIGGERS
     *   }
     * })
     * 
     */
    create<T extends QRTZ_TRIGGERSCreateArgs>(args: SelectSubset<T, QRTZ_TRIGGERSCreateArgs<ExtArgs>>): Prisma__QRTZ_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRTZ_TRIGGERS.
     * @param {QRTZ_TRIGGERSCreateManyArgs} args - Arguments to create many QRTZ_TRIGGERS.
     * @example
     * // Create many QRTZ_TRIGGERS
     * const qRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRTZ_TRIGGERSCreateManyArgs>(args?: SelectSubset<T, QRTZ_TRIGGERSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QRTZ_TRIGGERS.
     * @param {QRTZ_TRIGGERSDeleteArgs} args - Arguments to delete one QRTZ_TRIGGERS.
     * @example
     * // Delete one QRTZ_TRIGGERS
     * const QRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.delete({
     *   where: {
     *     // ... filter to delete one QRTZ_TRIGGERS
     *   }
     * })
     * 
     */
    delete<T extends QRTZ_TRIGGERSDeleteArgs>(args: SelectSubset<T, QRTZ_TRIGGERSDeleteArgs<ExtArgs>>): Prisma__QRTZ_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRTZ_TRIGGERS.
     * @param {QRTZ_TRIGGERSUpdateArgs} args - Arguments to update one QRTZ_TRIGGERS.
     * @example
     * // Update one QRTZ_TRIGGERS
     * const qRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRTZ_TRIGGERSUpdateArgs>(args: SelectSubset<T, QRTZ_TRIGGERSUpdateArgs<ExtArgs>>): Prisma__QRTZ_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRTZ_TRIGGERS.
     * @param {QRTZ_TRIGGERSDeleteManyArgs} args - Arguments to filter QRTZ_TRIGGERS to delete.
     * @example
     * // Delete a few QRTZ_TRIGGERS
     * const { count } = await prisma.qRTZ_TRIGGERS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRTZ_TRIGGERSDeleteManyArgs>(args?: SelectSubset<T, QRTZ_TRIGGERSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRTZ_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_TRIGGERSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRTZ_TRIGGERS
     * const qRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRTZ_TRIGGERSUpdateManyArgs>(args: SelectSubset<T, QRTZ_TRIGGERSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QRTZ_TRIGGERS.
     * @param {QRTZ_TRIGGERSUpsertArgs} args - Arguments to update or create a QRTZ_TRIGGERS.
     * @example
     * // Update or create a QRTZ_TRIGGERS
     * const qRTZ_TRIGGERS = await prisma.qRTZ_TRIGGERS.upsert({
     *   create: {
     *     // ... data to create a QRTZ_TRIGGERS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRTZ_TRIGGERS we want to update
     *   }
     * })
     */
    upsert<T extends QRTZ_TRIGGERSUpsertArgs>(args: SelectSubset<T, QRTZ_TRIGGERSUpsertArgs<ExtArgs>>): Prisma__QRTZ_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_TRIGGERSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRTZ_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_TRIGGERSCountArgs} args - Arguments to filter QRTZ_TRIGGERS to count.
     * @example
     * // Count the number of QRTZ_TRIGGERS
     * const count = await prisma.qRTZ_TRIGGERS.count({
     *   where: {
     *     // ... the filter for the QRTZ_TRIGGERS we want to count
     *   }
     * })
    **/
    count<T extends QRTZ_TRIGGERSCountArgs>(
      args?: Subset<T, QRTZ_TRIGGERSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRTZ_TRIGGERSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRTZ_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_TRIGGERSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRTZ_TRIGGERSAggregateArgs>(args: Subset<T, QRTZ_TRIGGERSAggregateArgs>): Prisma.PrismaPromise<GetQRTZ_TRIGGERSAggregateType<T>>

    /**
     * Group by QRTZ_TRIGGERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRTZ_TRIGGERSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRTZ_TRIGGERSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRTZ_TRIGGERSGroupByArgs['orderBy'] }
        : { orderBy?: QRTZ_TRIGGERSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRTZ_TRIGGERSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRTZ_TRIGGERSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRTZ_TRIGGERS model
   */
  readonly fields: QRTZ_TRIGGERSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRTZ_TRIGGERS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRTZ_TRIGGERSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    QRTZ_BLOB_TRIGGERS<T extends QRTZ_TRIGGERS$QRTZ_BLOB_TRIGGERSArgs<ExtArgs> = {}>(args?: Subset<T, QRTZ_TRIGGERS$QRTZ_BLOB_TRIGGERSArgs<ExtArgs>>): Prisma__QRTZ_BLOB_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_BLOB_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    QRTZ_CRON_TRIGGERS<T extends QRTZ_TRIGGERS$QRTZ_CRON_TRIGGERSArgs<ExtArgs> = {}>(args?: Subset<T, QRTZ_TRIGGERS$QRTZ_CRON_TRIGGERSArgs<ExtArgs>>): Prisma__QRTZ_CRON_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_CRON_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    QRTZ_SIMPLE_TRIGGERS<T extends QRTZ_TRIGGERS$QRTZ_SIMPLE_TRIGGERSArgs<ExtArgs> = {}>(args?: Subset<T, QRTZ_TRIGGERS$QRTZ_SIMPLE_TRIGGERSArgs<ExtArgs>>): Prisma__QRTZ_SIMPLE_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPLE_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    QRTZ_SIMPROP_TRIGGERS<T extends QRTZ_TRIGGERS$QRTZ_SIMPROP_TRIGGERSArgs<ExtArgs> = {}>(args?: Subset<T, QRTZ_TRIGGERS$QRTZ_SIMPROP_TRIGGERSArgs<ExtArgs>>): Prisma__QRTZ_SIMPROP_TRIGGERSClient<$Result.GetResult<Prisma.$QRTZ_SIMPROP_TRIGGERSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    QRTZ_JOB_DETAILS<T extends QRTZ_JOB_DETAILSDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QRTZ_JOB_DETAILSDefaultArgs<ExtArgs>>): Prisma__QRTZ_JOB_DETAILSClient<$Result.GetResult<Prisma.$QRTZ_JOB_DETAILSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRTZ_TRIGGERS model
   */
  interface QRTZ_TRIGGERSFieldRefs {
    readonly SCHED_NAME: FieldRef<"QRTZ_TRIGGERS", 'String'>
    readonly TRIGGER_NAME: FieldRef<"QRTZ_TRIGGERS", 'String'>
    readonly TRIGGER_GROUP: FieldRef<"QRTZ_TRIGGERS", 'String'>
    readonly JOB_NAME: FieldRef<"QRTZ_TRIGGERS", 'String'>
    readonly JOB_GROUP: FieldRef<"QRTZ_TRIGGERS", 'String'>
    readonly DESCRIPTION: FieldRef<"QRTZ_TRIGGERS", 'String'>
    readonly NEXT_FIRE_TIME: FieldRef<"QRTZ_TRIGGERS", 'BigInt'>
    readonly PREV_FIRE_TIME: FieldRef<"QRTZ_TRIGGERS", 'BigInt'>
    readonly PRIORITY: FieldRef<"QRTZ_TRIGGERS", 'Int'>
    readonly TRIGGER_STATE: FieldRef<"QRTZ_TRIGGERS", 'String'>
    readonly TRIGGER_TYPE: FieldRef<"QRTZ_TRIGGERS", 'String'>
    readonly START_TIME: FieldRef<"QRTZ_TRIGGERS", 'BigInt'>
    readonly END_TIME: FieldRef<"QRTZ_TRIGGERS", 'BigInt'>
    readonly CALENDAR_NAME: FieldRef<"QRTZ_TRIGGERS", 'String'>
    readonly MISFIRE_INSTR: FieldRef<"QRTZ_TRIGGERS", 'Int'>
    readonly JOB_DATA: FieldRef<"QRTZ_TRIGGERS", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * QRTZ_TRIGGERS findUnique
   */
  export type QRTZ_TRIGGERSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_TRIGGERS
     */
    select?: QRTZ_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_TRIGGERS
     */
    omit?: QRTZ_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_TRIGGERS to fetch.
     */
    where: QRTZ_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_TRIGGERS findUniqueOrThrow
   */
  export type QRTZ_TRIGGERSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_TRIGGERS
     */
    select?: QRTZ_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_TRIGGERS
     */
    omit?: QRTZ_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_TRIGGERS to fetch.
     */
    where: QRTZ_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_TRIGGERS findFirst
   */
  export type QRTZ_TRIGGERSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_TRIGGERS
     */
    select?: QRTZ_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_TRIGGERS
     */
    omit?: QRTZ_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_TRIGGERS to fetch.
     */
    where?: QRTZ_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_TRIGGERSOrderByWithRelationInput | QRTZ_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_TRIGGERS.
     */
    cursor?: QRTZ_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_TRIGGERS.
     */
    distinct?: QRTZ_TRIGGERSScalarFieldEnum | QRTZ_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_TRIGGERS findFirstOrThrow
   */
  export type QRTZ_TRIGGERSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_TRIGGERS
     */
    select?: QRTZ_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_TRIGGERS
     */
    omit?: QRTZ_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_TRIGGERS to fetch.
     */
    where?: QRTZ_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_TRIGGERSOrderByWithRelationInput | QRTZ_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRTZ_TRIGGERS.
     */
    cursor?: QRTZ_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_TRIGGERS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRTZ_TRIGGERS.
     */
    distinct?: QRTZ_TRIGGERSScalarFieldEnum | QRTZ_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_TRIGGERS findMany
   */
  export type QRTZ_TRIGGERSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_TRIGGERS
     */
    select?: QRTZ_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_TRIGGERS
     */
    omit?: QRTZ_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter, which QRTZ_TRIGGERS to fetch.
     */
    where?: QRTZ_TRIGGERSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRTZ_TRIGGERS to fetch.
     */
    orderBy?: QRTZ_TRIGGERSOrderByWithRelationInput | QRTZ_TRIGGERSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRTZ_TRIGGERS.
     */
    cursor?: QRTZ_TRIGGERSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRTZ_TRIGGERS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRTZ_TRIGGERS.
     */
    skip?: number
    distinct?: QRTZ_TRIGGERSScalarFieldEnum | QRTZ_TRIGGERSScalarFieldEnum[]
  }

  /**
   * QRTZ_TRIGGERS create
   */
  export type QRTZ_TRIGGERSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_TRIGGERS
     */
    select?: QRTZ_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_TRIGGERS
     */
    omit?: QRTZ_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_TRIGGERSInclude<ExtArgs> | null
    /**
     * The data needed to create a QRTZ_TRIGGERS.
     */
    data: XOR<QRTZ_TRIGGERSCreateInput, QRTZ_TRIGGERSUncheckedCreateInput>
  }

  /**
   * QRTZ_TRIGGERS createMany
   */
  export type QRTZ_TRIGGERSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRTZ_TRIGGERS.
     */
    data: QRTZ_TRIGGERSCreateManyInput | QRTZ_TRIGGERSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRTZ_TRIGGERS update
   */
  export type QRTZ_TRIGGERSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_TRIGGERS
     */
    select?: QRTZ_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_TRIGGERS
     */
    omit?: QRTZ_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_TRIGGERSInclude<ExtArgs> | null
    /**
     * The data needed to update a QRTZ_TRIGGERS.
     */
    data: XOR<QRTZ_TRIGGERSUpdateInput, QRTZ_TRIGGERSUncheckedUpdateInput>
    /**
     * Choose, which QRTZ_TRIGGERS to update.
     */
    where: QRTZ_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_TRIGGERS updateMany
   */
  export type QRTZ_TRIGGERSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRTZ_TRIGGERS.
     */
    data: XOR<QRTZ_TRIGGERSUpdateManyMutationInput, QRTZ_TRIGGERSUncheckedUpdateManyInput>
    /**
     * Filter which QRTZ_TRIGGERS to update
     */
    where?: QRTZ_TRIGGERSWhereInput
    /**
     * Limit how many QRTZ_TRIGGERS to update.
     */
    limit?: number
  }

  /**
   * QRTZ_TRIGGERS upsert
   */
  export type QRTZ_TRIGGERSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_TRIGGERS
     */
    select?: QRTZ_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_TRIGGERS
     */
    omit?: QRTZ_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_TRIGGERSInclude<ExtArgs> | null
    /**
     * The filter to search for the QRTZ_TRIGGERS to update in case it exists.
     */
    where: QRTZ_TRIGGERSWhereUniqueInput
    /**
     * In case the QRTZ_TRIGGERS found by the `where` argument doesn't exist, create a new QRTZ_TRIGGERS with this data.
     */
    create: XOR<QRTZ_TRIGGERSCreateInput, QRTZ_TRIGGERSUncheckedCreateInput>
    /**
     * In case the QRTZ_TRIGGERS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRTZ_TRIGGERSUpdateInput, QRTZ_TRIGGERSUncheckedUpdateInput>
  }

  /**
   * QRTZ_TRIGGERS delete
   */
  export type QRTZ_TRIGGERSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_TRIGGERS
     */
    select?: QRTZ_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_TRIGGERS
     */
    omit?: QRTZ_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_TRIGGERSInclude<ExtArgs> | null
    /**
     * Filter which QRTZ_TRIGGERS to delete.
     */
    where: QRTZ_TRIGGERSWhereUniqueInput
  }

  /**
   * QRTZ_TRIGGERS deleteMany
   */
  export type QRTZ_TRIGGERSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRTZ_TRIGGERS to delete
     */
    where?: QRTZ_TRIGGERSWhereInput
    /**
     * Limit how many QRTZ_TRIGGERS to delete.
     */
    limit?: number
  }

  /**
   * QRTZ_TRIGGERS.QRTZ_BLOB_TRIGGERS
   */
  export type QRTZ_TRIGGERS$QRTZ_BLOB_TRIGGERSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_BLOB_TRIGGERS
     */
    select?: QRTZ_BLOB_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_BLOB_TRIGGERS
     */
    omit?: QRTZ_BLOB_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_BLOB_TRIGGERSInclude<ExtArgs> | null
    where?: QRTZ_BLOB_TRIGGERSWhereInput
  }

  /**
   * QRTZ_TRIGGERS.QRTZ_CRON_TRIGGERS
   */
  export type QRTZ_TRIGGERS$QRTZ_CRON_TRIGGERSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_CRON_TRIGGERS
     */
    select?: QRTZ_CRON_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_CRON_TRIGGERS
     */
    omit?: QRTZ_CRON_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_CRON_TRIGGERSInclude<ExtArgs> | null
    where?: QRTZ_CRON_TRIGGERSWhereInput
  }

  /**
   * QRTZ_TRIGGERS.QRTZ_SIMPLE_TRIGGERS
   */
  export type QRTZ_TRIGGERS$QRTZ_SIMPLE_TRIGGERSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPLE_TRIGGERS
     */
    select?: QRTZ_SIMPLE_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPLE_TRIGGERS
     */
    omit?: QRTZ_SIMPLE_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPLE_TRIGGERSInclude<ExtArgs> | null
    where?: QRTZ_SIMPLE_TRIGGERSWhereInput
  }

  /**
   * QRTZ_TRIGGERS.QRTZ_SIMPROP_TRIGGERS
   */
  export type QRTZ_TRIGGERS$QRTZ_SIMPROP_TRIGGERSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_SIMPROP_TRIGGERS
     */
    select?: QRTZ_SIMPROP_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_SIMPROP_TRIGGERS
     */
    omit?: QRTZ_SIMPROP_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_SIMPROP_TRIGGERSInclude<ExtArgs> | null
    where?: QRTZ_SIMPROP_TRIGGERSWhereInput
  }

  /**
   * QRTZ_TRIGGERS without action
   */
  export type QRTZ_TRIGGERSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRTZ_TRIGGERS
     */
    select?: QRTZ_TRIGGERSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRTZ_TRIGGERS
     */
    omit?: QRTZ_TRIGGERSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRTZ_TRIGGERSInclude<ExtArgs> | null
  }


  /**
   * Model bag
   */

  export type AggregateBag = {
    _count: BagCountAggregateOutputType | null
    _avg: BagAvgAggregateOutputType | null
    _sum: BagSumAggregateOutputType | null
    _min: BagMinAggregateOutputType | null
    _max: BagMaxAggregateOutputType | null
  }

  export type BagAvgAggregateOutputType = {
    bag_id: number | null
  }

  export type BagSumAggregateOutputType = {
    bag_id: bigint | null
  }

  export type BagMinAggregateOutputType = {
    bag_id: bigint | null
  }

  export type BagMaxAggregateOutputType = {
    bag_id: bigint | null
  }

  export type BagCountAggregateOutputType = {
    bag_id: number
    _all: number
  }


  export type BagAvgAggregateInputType = {
    bag_id?: true
  }

  export type BagSumAggregateInputType = {
    bag_id?: true
  }

  export type BagMinAggregateInputType = {
    bag_id?: true
  }

  export type BagMaxAggregateInputType = {
    bag_id?: true
  }

  export type BagCountAggregateInputType = {
    bag_id?: true
    _all?: true
  }

  export type BagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bag to aggregate.
     */
    where?: bagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bags to fetch.
     */
    orderBy?: bagOrderByWithRelationInput | bagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bags
    **/
    _count?: true | BagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BagMaxAggregateInputType
  }

  export type GetBagAggregateType<T extends BagAggregateArgs> = {
        [P in keyof T & keyof AggregateBag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBag[P]>
      : GetScalarType<T[P], AggregateBag[P]>
  }




  export type bagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bagWhereInput
    orderBy?: bagOrderByWithAggregationInput | bagOrderByWithAggregationInput[]
    by: BagScalarFieldEnum[] | BagScalarFieldEnum
    having?: bagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BagCountAggregateInputType | true
    _avg?: BagAvgAggregateInputType
    _sum?: BagSumAggregateInputType
    _min?: BagMinAggregateInputType
    _max?: BagMaxAggregateInputType
  }

  export type BagGroupByOutputType = {
    bag_id: bigint
    _count: BagCountAggregateOutputType | null
    _avg: BagAvgAggregateOutputType | null
    _sum: BagSumAggregateOutputType | null
    _min: BagMinAggregateOutputType | null
    _max: BagMaxAggregateOutputType | null
  }

  type GetBagGroupByPayload<T extends bagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BagGroupByOutputType[P]>
            : GetScalarType<T[P], BagGroupByOutputType[P]>
        }
      >
    >


  export type bagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bag_id?: boolean
  }, ExtArgs["result"]["bag"]>



  export type bagSelectScalar = {
    bag_id?: boolean
  }

  export type bagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"bag_id", ExtArgs["result"]["bag"]>

  export type $bagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bag"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      bag_id: bigint
    }, ExtArgs["result"]["bag"]>
    composites: {}
  }

  type bagGetPayload<S extends boolean | null | undefined | bagDefaultArgs> = $Result.GetResult<Prisma.$bagPayload, S>

  type bagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BagCountAggregateInputType | true
    }

  export interface bagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bag'], meta: { name: 'bag' } }
    /**
     * Find zero or one Bag that matches the filter.
     * @param {bagFindUniqueArgs} args - Arguments to find a Bag
     * @example
     * // Get one Bag
     * const bag = await prisma.bag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bagFindUniqueArgs>(args: SelectSubset<T, bagFindUniqueArgs<ExtArgs>>): Prisma__bagClient<$Result.GetResult<Prisma.$bagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bagFindUniqueOrThrowArgs} args - Arguments to find a Bag
     * @example
     * // Get one Bag
     * const bag = await prisma.bag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bagFindUniqueOrThrowArgs>(args: SelectSubset<T, bagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bagClient<$Result.GetResult<Prisma.$bagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bagFindFirstArgs} args - Arguments to find a Bag
     * @example
     * // Get one Bag
     * const bag = await prisma.bag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bagFindFirstArgs>(args?: SelectSubset<T, bagFindFirstArgs<ExtArgs>>): Prisma__bagClient<$Result.GetResult<Prisma.$bagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bagFindFirstOrThrowArgs} args - Arguments to find a Bag
     * @example
     * // Get one Bag
     * const bag = await prisma.bag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bagFindFirstOrThrowArgs>(args?: SelectSubset<T, bagFindFirstOrThrowArgs<ExtArgs>>): Prisma__bagClient<$Result.GetResult<Prisma.$bagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bags
     * const bags = await prisma.bag.findMany()
     * 
     * // Get first 10 Bags
     * const bags = await prisma.bag.findMany({ take: 10 })
     * 
     * // Only select the `bag_id`
     * const bagWithBag_idOnly = await prisma.bag.findMany({ select: { bag_id: true } })
     * 
     */
    findMany<T extends bagFindManyArgs>(args?: SelectSubset<T, bagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bag.
     * @param {bagCreateArgs} args - Arguments to create a Bag.
     * @example
     * // Create one Bag
     * const Bag = await prisma.bag.create({
     *   data: {
     *     // ... data to create a Bag
     *   }
     * })
     * 
     */
    create<T extends bagCreateArgs>(args: SelectSubset<T, bagCreateArgs<ExtArgs>>): Prisma__bagClient<$Result.GetResult<Prisma.$bagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bags.
     * @param {bagCreateManyArgs} args - Arguments to create many Bags.
     * @example
     * // Create many Bags
     * const bag = await prisma.bag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bagCreateManyArgs>(args?: SelectSubset<T, bagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bag.
     * @param {bagDeleteArgs} args - Arguments to delete one Bag.
     * @example
     * // Delete one Bag
     * const Bag = await prisma.bag.delete({
     *   where: {
     *     // ... filter to delete one Bag
     *   }
     * })
     * 
     */
    delete<T extends bagDeleteArgs>(args: SelectSubset<T, bagDeleteArgs<ExtArgs>>): Prisma__bagClient<$Result.GetResult<Prisma.$bagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bag.
     * @param {bagUpdateArgs} args - Arguments to update one Bag.
     * @example
     * // Update one Bag
     * const bag = await prisma.bag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bagUpdateArgs>(args: SelectSubset<T, bagUpdateArgs<ExtArgs>>): Prisma__bagClient<$Result.GetResult<Prisma.$bagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bags.
     * @param {bagDeleteManyArgs} args - Arguments to filter Bags to delete.
     * @example
     * // Delete a few Bags
     * const { count } = await prisma.bag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bagDeleteManyArgs>(args?: SelectSubset<T, bagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bags
     * const bag = await prisma.bag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bagUpdateManyArgs>(args: SelectSubset<T, bagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bag.
     * @param {bagUpsertArgs} args - Arguments to update or create a Bag.
     * @example
     * // Update or create a Bag
     * const bag = await prisma.bag.upsert({
     *   create: {
     *     // ... data to create a Bag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bag we want to update
     *   }
     * })
     */
    upsert<T extends bagUpsertArgs>(args: SelectSubset<T, bagUpsertArgs<ExtArgs>>): Prisma__bagClient<$Result.GetResult<Prisma.$bagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bagCountArgs} args - Arguments to filter Bags to count.
     * @example
     * // Count the number of Bags
     * const count = await prisma.bag.count({
     *   where: {
     *     // ... the filter for the Bags we want to count
     *   }
     * })
    **/
    count<T extends bagCountArgs>(
      args?: Subset<T, bagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BagAggregateArgs>(args: Subset<T, BagAggregateArgs>): Prisma.PrismaPromise<GetBagAggregateType<T>>

    /**
     * Group by Bag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bagGroupByArgs['orderBy'] }
        : { orderBy?: bagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bag model
   */
  readonly fields: bagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bag model
   */
  interface bagFieldRefs {
    readonly bag_id: FieldRef<"bag", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * bag findUnique
   */
  export type bagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bag
     */
    select?: bagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bag
     */
    omit?: bagOmit<ExtArgs> | null
    /**
     * Filter, which bag to fetch.
     */
    where: bagWhereUniqueInput
  }

  /**
   * bag findUniqueOrThrow
   */
  export type bagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bag
     */
    select?: bagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bag
     */
    omit?: bagOmit<ExtArgs> | null
    /**
     * Filter, which bag to fetch.
     */
    where: bagWhereUniqueInput
  }

  /**
   * bag findFirst
   */
  export type bagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bag
     */
    select?: bagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bag
     */
    omit?: bagOmit<ExtArgs> | null
    /**
     * Filter, which bag to fetch.
     */
    where?: bagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bags to fetch.
     */
    orderBy?: bagOrderByWithRelationInput | bagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bags.
     */
    cursor?: bagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bags.
     */
    distinct?: BagScalarFieldEnum | BagScalarFieldEnum[]
  }

  /**
   * bag findFirstOrThrow
   */
  export type bagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bag
     */
    select?: bagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bag
     */
    omit?: bagOmit<ExtArgs> | null
    /**
     * Filter, which bag to fetch.
     */
    where?: bagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bags to fetch.
     */
    orderBy?: bagOrderByWithRelationInput | bagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bags.
     */
    cursor?: bagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bags.
     */
    distinct?: BagScalarFieldEnum | BagScalarFieldEnum[]
  }

  /**
   * bag findMany
   */
  export type bagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bag
     */
    select?: bagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bag
     */
    omit?: bagOmit<ExtArgs> | null
    /**
     * Filter, which bags to fetch.
     */
    where?: bagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bags to fetch.
     */
    orderBy?: bagOrderByWithRelationInput | bagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bags.
     */
    cursor?: bagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bags.
     */
    skip?: number
    distinct?: BagScalarFieldEnum | BagScalarFieldEnum[]
  }

  /**
   * bag create
   */
  export type bagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bag
     */
    select?: bagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bag
     */
    omit?: bagOmit<ExtArgs> | null
    /**
     * The data needed to create a bag.
     */
    data?: XOR<bagCreateInput, bagUncheckedCreateInput>
  }

  /**
   * bag createMany
   */
  export type bagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bags.
     */
    data: bagCreateManyInput | bagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bag update
   */
  export type bagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bag
     */
    select?: bagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bag
     */
    omit?: bagOmit<ExtArgs> | null
    /**
     * The data needed to update a bag.
     */
    data: XOR<bagUpdateInput, bagUncheckedUpdateInput>
    /**
     * Choose, which bag to update.
     */
    where: bagWhereUniqueInput
  }

  /**
   * bag updateMany
   */
  export type bagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bags.
     */
    data: XOR<bagUpdateManyMutationInput, bagUncheckedUpdateManyInput>
    /**
     * Filter which bags to update
     */
    where?: bagWhereInput
    /**
     * Limit how many bags to update.
     */
    limit?: number
  }

  /**
   * bag upsert
   */
  export type bagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bag
     */
    select?: bagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bag
     */
    omit?: bagOmit<ExtArgs> | null
    /**
     * The filter to search for the bag to update in case it exists.
     */
    where: bagWhereUniqueInput
    /**
     * In case the bag found by the `where` argument doesn't exist, create a new bag with this data.
     */
    create: XOR<bagCreateInput, bagUncheckedCreateInput>
    /**
     * In case the bag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bagUpdateInput, bagUncheckedUpdateInput>
  }

  /**
   * bag delete
   */
  export type bagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bag
     */
    select?: bagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bag
     */
    omit?: bagOmit<ExtArgs> | null
    /**
     * Filter which bag to delete.
     */
    where: bagWhereUniqueInput
  }

  /**
   * bag deleteMany
   */
  export type bagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bags to delete
     */
    where?: bagWhereInput
    /**
     * Limit how many bags to delete.
     */
    limit?: number
  }

  /**
   * bag without action
   */
  export type bagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bag
     */
    select?: bagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bag
     */
    omit?: bagOmit<ExtArgs> | null
  }


  /**
   * Model ban_word
   */

  export type AggregateBan_word = {
    _count: Ban_wordCountAggregateOutputType | null
    _avg: Ban_wordAvgAggregateOutputType | null
    _sum: Ban_wordSumAggregateOutputType | null
    _min: Ban_wordMinAggregateOutputType | null
    _max: Ban_wordMaxAggregateOutputType | null
  }

  export type Ban_wordAvgAggregateOutputType = {
    id: number | null
  }

  export type Ban_wordSumAggregateOutputType = {
    id: bigint | null
  }

  export type Ban_wordMinAggregateOutputType = {
    id: bigint | null
    word: string | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type Ban_wordMaxAggregateOutputType = {
    id: bigint | null
    word: string | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type Ban_wordCountAggregateOutputType = {
    id: number
    word: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type Ban_wordAvgAggregateInputType = {
    id?: true
  }

  export type Ban_wordSumAggregateInputType = {
    id?: true
  }

  export type Ban_wordMinAggregateInputType = {
    id?: true
    word?: true
    created_at?: true
    modified_at?: true
  }

  export type Ban_wordMaxAggregateInputType = {
    id?: true
    word?: true
    created_at?: true
    modified_at?: true
  }

  export type Ban_wordCountAggregateInputType = {
    id?: true
    word?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type Ban_wordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ban_word to aggregate.
     */
    where?: ban_wordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ban_words to fetch.
     */
    orderBy?: ban_wordOrderByWithRelationInput | ban_wordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ban_wordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ban_words from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ban_words.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ban_words
    **/
    _count?: true | Ban_wordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ban_wordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ban_wordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ban_wordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ban_wordMaxAggregateInputType
  }

  export type GetBan_wordAggregateType<T extends Ban_wordAggregateArgs> = {
        [P in keyof T & keyof AggregateBan_word]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBan_word[P]>
      : GetScalarType<T[P], AggregateBan_word[P]>
  }




  export type ban_wordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ban_wordWhereInput
    orderBy?: ban_wordOrderByWithAggregationInput | ban_wordOrderByWithAggregationInput[]
    by: Ban_wordScalarFieldEnum[] | Ban_wordScalarFieldEnum
    having?: ban_wordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ban_wordCountAggregateInputType | true
    _avg?: Ban_wordAvgAggregateInputType
    _sum?: Ban_wordSumAggregateInputType
    _min?: Ban_wordMinAggregateInputType
    _max?: Ban_wordMaxAggregateInputType
  }

  export type Ban_wordGroupByOutputType = {
    id: bigint
    word: string
    created_at: Date
    modified_at: Date
    _count: Ban_wordCountAggregateOutputType | null
    _avg: Ban_wordAvgAggregateOutputType | null
    _sum: Ban_wordSumAggregateOutputType | null
    _min: Ban_wordMinAggregateOutputType | null
    _max: Ban_wordMaxAggregateOutputType | null
  }

  type GetBan_wordGroupByPayload<T extends ban_wordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ban_wordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ban_wordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ban_wordGroupByOutputType[P]>
            : GetScalarType<T[P], Ban_wordGroupByOutputType[P]>
        }
      >
    >


  export type ban_wordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    word?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["ban_word"]>



  export type ban_wordSelectScalar = {
    id?: boolean
    word?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type ban_wordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "word" | "created_at" | "modified_at", ExtArgs["result"]["ban_word"]>

  export type $ban_wordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ban_word"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      word: string
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["ban_word"]>
    composites: {}
  }

  type ban_wordGetPayload<S extends boolean | null | undefined | ban_wordDefaultArgs> = $Result.GetResult<Prisma.$ban_wordPayload, S>

  type ban_wordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ban_wordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ban_wordCountAggregateInputType | true
    }

  export interface ban_wordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ban_word'], meta: { name: 'ban_word' } }
    /**
     * Find zero or one Ban_word that matches the filter.
     * @param {ban_wordFindUniqueArgs} args - Arguments to find a Ban_word
     * @example
     * // Get one Ban_word
     * const ban_word = await prisma.ban_word.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ban_wordFindUniqueArgs>(args: SelectSubset<T, ban_wordFindUniqueArgs<ExtArgs>>): Prisma__ban_wordClient<$Result.GetResult<Prisma.$ban_wordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ban_word that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ban_wordFindUniqueOrThrowArgs} args - Arguments to find a Ban_word
     * @example
     * // Get one Ban_word
     * const ban_word = await prisma.ban_word.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ban_wordFindUniqueOrThrowArgs>(args: SelectSubset<T, ban_wordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ban_wordClient<$Result.GetResult<Prisma.$ban_wordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ban_word that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ban_wordFindFirstArgs} args - Arguments to find a Ban_word
     * @example
     * // Get one Ban_word
     * const ban_word = await prisma.ban_word.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ban_wordFindFirstArgs>(args?: SelectSubset<T, ban_wordFindFirstArgs<ExtArgs>>): Prisma__ban_wordClient<$Result.GetResult<Prisma.$ban_wordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ban_word that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ban_wordFindFirstOrThrowArgs} args - Arguments to find a Ban_word
     * @example
     * // Get one Ban_word
     * const ban_word = await prisma.ban_word.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ban_wordFindFirstOrThrowArgs>(args?: SelectSubset<T, ban_wordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ban_wordClient<$Result.GetResult<Prisma.$ban_wordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ban_words that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ban_wordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ban_words
     * const ban_words = await prisma.ban_word.findMany()
     * 
     * // Get first 10 Ban_words
     * const ban_words = await prisma.ban_word.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ban_wordWithIdOnly = await prisma.ban_word.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ban_wordFindManyArgs>(args?: SelectSubset<T, ban_wordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ban_wordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ban_word.
     * @param {ban_wordCreateArgs} args - Arguments to create a Ban_word.
     * @example
     * // Create one Ban_word
     * const Ban_word = await prisma.ban_word.create({
     *   data: {
     *     // ... data to create a Ban_word
     *   }
     * })
     * 
     */
    create<T extends ban_wordCreateArgs>(args: SelectSubset<T, ban_wordCreateArgs<ExtArgs>>): Prisma__ban_wordClient<$Result.GetResult<Prisma.$ban_wordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ban_words.
     * @param {ban_wordCreateManyArgs} args - Arguments to create many Ban_words.
     * @example
     * // Create many Ban_words
     * const ban_word = await prisma.ban_word.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ban_wordCreateManyArgs>(args?: SelectSubset<T, ban_wordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ban_word.
     * @param {ban_wordDeleteArgs} args - Arguments to delete one Ban_word.
     * @example
     * // Delete one Ban_word
     * const Ban_word = await prisma.ban_word.delete({
     *   where: {
     *     // ... filter to delete one Ban_word
     *   }
     * })
     * 
     */
    delete<T extends ban_wordDeleteArgs>(args: SelectSubset<T, ban_wordDeleteArgs<ExtArgs>>): Prisma__ban_wordClient<$Result.GetResult<Prisma.$ban_wordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ban_word.
     * @param {ban_wordUpdateArgs} args - Arguments to update one Ban_word.
     * @example
     * // Update one Ban_word
     * const ban_word = await prisma.ban_word.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ban_wordUpdateArgs>(args: SelectSubset<T, ban_wordUpdateArgs<ExtArgs>>): Prisma__ban_wordClient<$Result.GetResult<Prisma.$ban_wordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ban_words.
     * @param {ban_wordDeleteManyArgs} args - Arguments to filter Ban_words to delete.
     * @example
     * // Delete a few Ban_words
     * const { count } = await prisma.ban_word.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ban_wordDeleteManyArgs>(args?: SelectSubset<T, ban_wordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ban_words.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ban_wordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ban_words
     * const ban_word = await prisma.ban_word.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ban_wordUpdateManyArgs>(args: SelectSubset<T, ban_wordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ban_word.
     * @param {ban_wordUpsertArgs} args - Arguments to update or create a Ban_word.
     * @example
     * // Update or create a Ban_word
     * const ban_word = await prisma.ban_word.upsert({
     *   create: {
     *     // ... data to create a Ban_word
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ban_word we want to update
     *   }
     * })
     */
    upsert<T extends ban_wordUpsertArgs>(args: SelectSubset<T, ban_wordUpsertArgs<ExtArgs>>): Prisma__ban_wordClient<$Result.GetResult<Prisma.$ban_wordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ban_words.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ban_wordCountArgs} args - Arguments to filter Ban_words to count.
     * @example
     * // Count the number of Ban_words
     * const count = await prisma.ban_word.count({
     *   where: {
     *     // ... the filter for the Ban_words we want to count
     *   }
     * })
    **/
    count<T extends ban_wordCountArgs>(
      args?: Subset<T, ban_wordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ban_wordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ban_word.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ban_wordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ban_wordAggregateArgs>(args: Subset<T, Ban_wordAggregateArgs>): Prisma.PrismaPromise<GetBan_wordAggregateType<T>>

    /**
     * Group by Ban_word.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ban_wordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ban_wordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ban_wordGroupByArgs['orderBy'] }
        : { orderBy?: ban_wordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ban_wordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBan_wordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ban_word model
   */
  readonly fields: ban_wordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ban_word.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ban_wordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ban_word model
   */
  interface ban_wordFieldRefs {
    readonly id: FieldRef<"ban_word", 'BigInt'>
    readonly word: FieldRef<"ban_word", 'String'>
    readonly created_at: FieldRef<"ban_word", 'DateTime'>
    readonly modified_at: FieldRef<"ban_word", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ban_word findUnique
   */
  export type ban_wordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ban_word
     */
    select?: ban_wordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ban_word
     */
    omit?: ban_wordOmit<ExtArgs> | null
    /**
     * Filter, which ban_word to fetch.
     */
    where: ban_wordWhereUniqueInput
  }

  /**
   * ban_word findUniqueOrThrow
   */
  export type ban_wordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ban_word
     */
    select?: ban_wordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ban_word
     */
    omit?: ban_wordOmit<ExtArgs> | null
    /**
     * Filter, which ban_word to fetch.
     */
    where: ban_wordWhereUniqueInput
  }

  /**
   * ban_word findFirst
   */
  export type ban_wordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ban_word
     */
    select?: ban_wordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ban_word
     */
    omit?: ban_wordOmit<ExtArgs> | null
    /**
     * Filter, which ban_word to fetch.
     */
    where?: ban_wordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ban_words to fetch.
     */
    orderBy?: ban_wordOrderByWithRelationInput | ban_wordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ban_words.
     */
    cursor?: ban_wordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ban_words from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ban_words.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ban_words.
     */
    distinct?: Ban_wordScalarFieldEnum | Ban_wordScalarFieldEnum[]
  }

  /**
   * ban_word findFirstOrThrow
   */
  export type ban_wordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ban_word
     */
    select?: ban_wordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ban_word
     */
    omit?: ban_wordOmit<ExtArgs> | null
    /**
     * Filter, which ban_word to fetch.
     */
    where?: ban_wordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ban_words to fetch.
     */
    orderBy?: ban_wordOrderByWithRelationInput | ban_wordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ban_words.
     */
    cursor?: ban_wordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ban_words from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ban_words.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ban_words.
     */
    distinct?: Ban_wordScalarFieldEnum | Ban_wordScalarFieldEnum[]
  }

  /**
   * ban_word findMany
   */
  export type ban_wordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ban_word
     */
    select?: ban_wordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ban_word
     */
    omit?: ban_wordOmit<ExtArgs> | null
    /**
     * Filter, which ban_words to fetch.
     */
    where?: ban_wordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ban_words to fetch.
     */
    orderBy?: ban_wordOrderByWithRelationInput | ban_wordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ban_words.
     */
    cursor?: ban_wordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ban_words from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ban_words.
     */
    skip?: number
    distinct?: Ban_wordScalarFieldEnum | Ban_wordScalarFieldEnum[]
  }

  /**
   * ban_word create
   */
  export type ban_wordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ban_word
     */
    select?: ban_wordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ban_word
     */
    omit?: ban_wordOmit<ExtArgs> | null
    /**
     * The data needed to create a ban_word.
     */
    data: XOR<ban_wordCreateInput, ban_wordUncheckedCreateInput>
  }

  /**
   * ban_word createMany
   */
  export type ban_wordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ban_words.
     */
    data: ban_wordCreateManyInput | ban_wordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ban_word update
   */
  export type ban_wordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ban_word
     */
    select?: ban_wordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ban_word
     */
    omit?: ban_wordOmit<ExtArgs> | null
    /**
     * The data needed to update a ban_word.
     */
    data: XOR<ban_wordUpdateInput, ban_wordUncheckedUpdateInput>
    /**
     * Choose, which ban_word to update.
     */
    where: ban_wordWhereUniqueInput
  }

  /**
   * ban_word updateMany
   */
  export type ban_wordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ban_words.
     */
    data: XOR<ban_wordUpdateManyMutationInput, ban_wordUncheckedUpdateManyInput>
    /**
     * Filter which ban_words to update
     */
    where?: ban_wordWhereInput
    /**
     * Limit how many ban_words to update.
     */
    limit?: number
  }

  /**
   * ban_word upsert
   */
  export type ban_wordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ban_word
     */
    select?: ban_wordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ban_word
     */
    omit?: ban_wordOmit<ExtArgs> | null
    /**
     * The filter to search for the ban_word to update in case it exists.
     */
    where: ban_wordWhereUniqueInput
    /**
     * In case the ban_word found by the `where` argument doesn't exist, create a new ban_word with this data.
     */
    create: XOR<ban_wordCreateInput, ban_wordUncheckedCreateInput>
    /**
     * In case the ban_word was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ban_wordUpdateInput, ban_wordUncheckedUpdateInput>
  }

  /**
   * ban_word delete
   */
  export type ban_wordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ban_word
     */
    select?: ban_wordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ban_word
     */
    omit?: ban_wordOmit<ExtArgs> | null
    /**
     * Filter which ban_word to delete.
     */
    where: ban_wordWhereUniqueInput
  }

  /**
   * ban_word deleteMany
   */
  export type ban_wordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ban_words to delete
     */
    where?: ban_wordWhereInput
    /**
     * Limit how many ban_words to delete.
     */
    limit?: number
  }

  /**
   * ban_word without action
   */
  export type ban_wordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ban_word
     */
    select?: ban_wordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ban_word
     */
    omit?: ban_wordOmit<ExtArgs> | null
  }


  /**
   * Model flyway_schema_history
   */

  export type AggregateFlyway_schema_history = {
    _count: Flyway_schema_historyCountAggregateOutputType | null
    _avg: Flyway_schema_historyAvgAggregateOutputType | null
    _sum: Flyway_schema_historySumAggregateOutputType | null
    _min: Flyway_schema_historyMinAggregateOutputType | null
    _max: Flyway_schema_historyMaxAggregateOutputType | null
  }

  export type Flyway_schema_historyAvgAggregateOutputType = {
    installed_rank: number | null
    checksum: number | null
    execution_time: number | null
  }

  export type Flyway_schema_historySumAggregateOutputType = {
    installed_rank: number | null
    checksum: number | null
    execution_time: number | null
  }

  export type Flyway_schema_historyMinAggregateOutputType = {
    installed_rank: number | null
    version: string | null
    description: string | null
    type: string | null
    script: string | null
    checksum: number | null
    installed_by: string | null
    installed_on: Date | null
    execution_time: number | null
    success: boolean | null
  }

  export type Flyway_schema_historyMaxAggregateOutputType = {
    installed_rank: number | null
    version: string | null
    description: string | null
    type: string | null
    script: string | null
    checksum: number | null
    installed_by: string | null
    installed_on: Date | null
    execution_time: number | null
    success: boolean | null
  }

  export type Flyway_schema_historyCountAggregateOutputType = {
    installed_rank: number
    version: number
    description: number
    type: number
    script: number
    checksum: number
    installed_by: number
    installed_on: number
    execution_time: number
    success: number
    _all: number
  }


  export type Flyway_schema_historyAvgAggregateInputType = {
    installed_rank?: true
    checksum?: true
    execution_time?: true
  }

  export type Flyway_schema_historySumAggregateInputType = {
    installed_rank?: true
    checksum?: true
    execution_time?: true
  }

  export type Flyway_schema_historyMinAggregateInputType = {
    installed_rank?: true
    version?: true
    description?: true
    type?: true
    script?: true
    checksum?: true
    installed_by?: true
    installed_on?: true
    execution_time?: true
    success?: true
  }

  export type Flyway_schema_historyMaxAggregateInputType = {
    installed_rank?: true
    version?: true
    description?: true
    type?: true
    script?: true
    checksum?: true
    installed_by?: true
    installed_on?: true
    execution_time?: true
    success?: true
  }

  export type Flyway_schema_historyCountAggregateInputType = {
    installed_rank?: true
    version?: true
    description?: true
    type?: true
    script?: true
    checksum?: true
    installed_by?: true
    installed_on?: true
    execution_time?: true
    success?: true
    _all?: true
  }

  export type Flyway_schema_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flyway_schema_history to aggregate.
     */
    where?: flyway_schema_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flyway_schema_histories to fetch.
     */
    orderBy?: flyway_schema_historyOrderByWithRelationInput | flyway_schema_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: flyway_schema_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flyway_schema_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flyway_schema_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned flyway_schema_histories
    **/
    _count?: true | Flyway_schema_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Flyway_schema_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Flyway_schema_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Flyway_schema_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Flyway_schema_historyMaxAggregateInputType
  }

  export type GetFlyway_schema_historyAggregateType<T extends Flyway_schema_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateFlyway_schema_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlyway_schema_history[P]>
      : GetScalarType<T[P], AggregateFlyway_schema_history[P]>
  }




  export type flyway_schema_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flyway_schema_historyWhereInput
    orderBy?: flyway_schema_historyOrderByWithAggregationInput | flyway_schema_historyOrderByWithAggregationInput[]
    by: Flyway_schema_historyScalarFieldEnum[] | Flyway_schema_historyScalarFieldEnum
    having?: flyway_schema_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Flyway_schema_historyCountAggregateInputType | true
    _avg?: Flyway_schema_historyAvgAggregateInputType
    _sum?: Flyway_schema_historySumAggregateInputType
    _min?: Flyway_schema_historyMinAggregateInputType
    _max?: Flyway_schema_historyMaxAggregateInputType
  }

  export type Flyway_schema_historyGroupByOutputType = {
    installed_rank: number
    version: string | null
    description: string
    type: string
    script: string
    checksum: number | null
    installed_by: string
    installed_on: Date
    execution_time: number
    success: boolean
    _count: Flyway_schema_historyCountAggregateOutputType | null
    _avg: Flyway_schema_historyAvgAggregateOutputType | null
    _sum: Flyway_schema_historySumAggregateOutputType | null
    _min: Flyway_schema_historyMinAggregateOutputType | null
    _max: Flyway_schema_historyMaxAggregateOutputType | null
  }

  type GetFlyway_schema_historyGroupByPayload<T extends flyway_schema_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Flyway_schema_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Flyway_schema_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Flyway_schema_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Flyway_schema_historyGroupByOutputType[P]>
        }
      >
    >


  export type flyway_schema_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    installed_rank?: boolean
    version?: boolean
    description?: boolean
    type?: boolean
    script?: boolean
    checksum?: boolean
    installed_by?: boolean
    installed_on?: boolean
    execution_time?: boolean
    success?: boolean
  }, ExtArgs["result"]["flyway_schema_history"]>



  export type flyway_schema_historySelectScalar = {
    installed_rank?: boolean
    version?: boolean
    description?: boolean
    type?: boolean
    script?: boolean
    checksum?: boolean
    installed_by?: boolean
    installed_on?: boolean
    execution_time?: boolean
    success?: boolean
  }

  export type flyway_schema_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"installed_rank" | "version" | "description" | "type" | "script" | "checksum" | "installed_by" | "installed_on" | "execution_time" | "success", ExtArgs["result"]["flyway_schema_history"]>

  export type $flyway_schema_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "flyway_schema_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      installed_rank: number
      version: string | null
      description: string
      type: string
      script: string
      checksum: number | null
      installed_by: string
      installed_on: Date
      execution_time: number
      success: boolean
    }, ExtArgs["result"]["flyway_schema_history"]>
    composites: {}
  }

  type flyway_schema_historyGetPayload<S extends boolean | null | undefined | flyway_schema_historyDefaultArgs> = $Result.GetResult<Prisma.$flyway_schema_historyPayload, S>

  type flyway_schema_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<flyway_schema_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Flyway_schema_historyCountAggregateInputType | true
    }

  export interface flyway_schema_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['flyway_schema_history'], meta: { name: 'flyway_schema_history' } }
    /**
     * Find zero or one Flyway_schema_history that matches the filter.
     * @param {flyway_schema_historyFindUniqueArgs} args - Arguments to find a Flyway_schema_history
     * @example
     * // Get one Flyway_schema_history
     * const flyway_schema_history = await prisma.flyway_schema_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends flyway_schema_historyFindUniqueArgs>(args: SelectSubset<T, flyway_schema_historyFindUniqueArgs<ExtArgs>>): Prisma__flyway_schema_historyClient<$Result.GetResult<Prisma.$flyway_schema_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Flyway_schema_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {flyway_schema_historyFindUniqueOrThrowArgs} args - Arguments to find a Flyway_schema_history
     * @example
     * // Get one Flyway_schema_history
     * const flyway_schema_history = await prisma.flyway_schema_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends flyway_schema_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, flyway_schema_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__flyway_schema_historyClient<$Result.GetResult<Prisma.$flyway_schema_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flyway_schema_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flyway_schema_historyFindFirstArgs} args - Arguments to find a Flyway_schema_history
     * @example
     * // Get one Flyway_schema_history
     * const flyway_schema_history = await prisma.flyway_schema_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends flyway_schema_historyFindFirstArgs>(args?: SelectSubset<T, flyway_schema_historyFindFirstArgs<ExtArgs>>): Prisma__flyway_schema_historyClient<$Result.GetResult<Prisma.$flyway_schema_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flyway_schema_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flyway_schema_historyFindFirstOrThrowArgs} args - Arguments to find a Flyway_schema_history
     * @example
     * // Get one Flyway_schema_history
     * const flyway_schema_history = await prisma.flyway_schema_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends flyway_schema_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, flyway_schema_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__flyway_schema_historyClient<$Result.GetResult<Prisma.$flyway_schema_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Flyway_schema_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flyway_schema_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flyway_schema_histories
     * const flyway_schema_histories = await prisma.flyway_schema_history.findMany()
     * 
     * // Get first 10 Flyway_schema_histories
     * const flyway_schema_histories = await prisma.flyway_schema_history.findMany({ take: 10 })
     * 
     * // Only select the `installed_rank`
     * const flyway_schema_historyWithInstalled_rankOnly = await prisma.flyway_schema_history.findMany({ select: { installed_rank: true } })
     * 
     */
    findMany<T extends flyway_schema_historyFindManyArgs>(args?: SelectSubset<T, flyway_schema_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flyway_schema_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Flyway_schema_history.
     * @param {flyway_schema_historyCreateArgs} args - Arguments to create a Flyway_schema_history.
     * @example
     * // Create one Flyway_schema_history
     * const Flyway_schema_history = await prisma.flyway_schema_history.create({
     *   data: {
     *     // ... data to create a Flyway_schema_history
     *   }
     * })
     * 
     */
    create<T extends flyway_schema_historyCreateArgs>(args: SelectSubset<T, flyway_schema_historyCreateArgs<ExtArgs>>): Prisma__flyway_schema_historyClient<$Result.GetResult<Prisma.$flyway_schema_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Flyway_schema_histories.
     * @param {flyway_schema_historyCreateManyArgs} args - Arguments to create many Flyway_schema_histories.
     * @example
     * // Create many Flyway_schema_histories
     * const flyway_schema_history = await prisma.flyway_schema_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends flyway_schema_historyCreateManyArgs>(args?: SelectSubset<T, flyway_schema_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Flyway_schema_history.
     * @param {flyway_schema_historyDeleteArgs} args - Arguments to delete one Flyway_schema_history.
     * @example
     * // Delete one Flyway_schema_history
     * const Flyway_schema_history = await prisma.flyway_schema_history.delete({
     *   where: {
     *     // ... filter to delete one Flyway_schema_history
     *   }
     * })
     * 
     */
    delete<T extends flyway_schema_historyDeleteArgs>(args: SelectSubset<T, flyway_schema_historyDeleteArgs<ExtArgs>>): Prisma__flyway_schema_historyClient<$Result.GetResult<Prisma.$flyway_schema_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Flyway_schema_history.
     * @param {flyway_schema_historyUpdateArgs} args - Arguments to update one Flyway_schema_history.
     * @example
     * // Update one Flyway_schema_history
     * const flyway_schema_history = await prisma.flyway_schema_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends flyway_schema_historyUpdateArgs>(args: SelectSubset<T, flyway_schema_historyUpdateArgs<ExtArgs>>): Prisma__flyway_schema_historyClient<$Result.GetResult<Prisma.$flyway_schema_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Flyway_schema_histories.
     * @param {flyway_schema_historyDeleteManyArgs} args - Arguments to filter Flyway_schema_histories to delete.
     * @example
     * // Delete a few Flyway_schema_histories
     * const { count } = await prisma.flyway_schema_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends flyway_schema_historyDeleteManyArgs>(args?: SelectSubset<T, flyway_schema_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flyway_schema_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flyway_schema_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flyway_schema_histories
     * const flyway_schema_history = await prisma.flyway_schema_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends flyway_schema_historyUpdateManyArgs>(args: SelectSubset<T, flyway_schema_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Flyway_schema_history.
     * @param {flyway_schema_historyUpsertArgs} args - Arguments to update or create a Flyway_schema_history.
     * @example
     * // Update or create a Flyway_schema_history
     * const flyway_schema_history = await prisma.flyway_schema_history.upsert({
     *   create: {
     *     // ... data to create a Flyway_schema_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flyway_schema_history we want to update
     *   }
     * })
     */
    upsert<T extends flyway_schema_historyUpsertArgs>(args: SelectSubset<T, flyway_schema_historyUpsertArgs<ExtArgs>>): Prisma__flyway_schema_historyClient<$Result.GetResult<Prisma.$flyway_schema_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Flyway_schema_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flyway_schema_historyCountArgs} args - Arguments to filter Flyway_schema_histories to count.
     * @example
     * // Count the number of Flyway_schema_histories
     * const count = await prisma.flyway_schema_history.count({
     *   where: {
     *     // ... the filter for the Flyway_schema_histories we want to count
     *   }
     * })
    **/
    count<T extends flyway_schema_historyCountArgs>(
      args?: Subset<T, flyway_schema_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Flyway_schema_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flyway_schema_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Flyway_schema_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Flyway_schema_historyAggregateArgs>(args: Subset<T, Flyway_schema_historyAggregateArgs>): Prisma.PrismaPromise<GetFlyway_schema_historyAggregateType<T>>

    /**
     * Group by Flyway_schema_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flyway_schema_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends flyway_schema_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: flyway_schema_historyGroupByArgs['orderBy'] }
        : { orderBy?: flyway_schema_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, flyway_schema_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlyway_schema_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the flyway_schema_history model
   */
  readonly fields: flyway_schema_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for flyway_schema_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__flyway_schema_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the flyway_schema_history model
   */
  interface flyway_schema_historyFieldRefs {
    readonly installed_rank: FieldRef<"flyway_schema_history", 'Int'>
    readonly version: FieldRef<"flyway_schema_history", 'String'>
    readonly description: FieldRef<"flyway_schema_history", 'String'>
    readonly type: FieldRef<"flyway_schema_history", 'String'>
    readonly script: FieldRef<"flyway_schema_history", 'String'>
    readonly checksum: FieldRef<"flyway_schema_history", 'Int'>
    readonly installed_by: FieldRef<"flyway_schema_history", 'String'>
    readonly installed_on: FieldRef<"flyway_schema_history", 'DateTime'>
    readonly execution_time: FieldRef<"flyway_schema_history", 'Int'>
    readonly success: FieldRef<"flyway_schema_history", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * flyway_schema_history findUnique
   */
  export type flyway_schema_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     */
    select?: flyway_schema_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the flyway_schema_history
     */
    omit?: flyway_schema_historyOmit<ExtArgs> | null
    /**
     * Filter, which flyway_schema_history to fetch.
     */
    where: flyway_schema_historyWhereUniqueInput
  }

  /**
   * flyway_schema_history findUniqueOrThrow
   */
  export type flyway_schema_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     */
    select?: flyway_schema_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the flyway_schema_history
     */
    omit?: flyway_schema_historyOmit<ExtArgs> | null
    /**
     * Filter, which flyway_schema_history to fetch.
     */
    where: flyway_schema_historyWhereUniqueInput
  }

  /**
   * flyway_schema_history findFirst
   */
  export type flyway_schema_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     */
    select?: flyway_schema_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the flyway_schema_history
     */
    omit?: flyway_schema_historyOmit<ExtArgs> | null
    /**
     * Filter, which flyway_schema_history to fetch.
     */
    where?: flyway_schema_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flyway_schema_histories to fetch.
     */
    orderBy?: flyway_schema_historyOrderByWithRelationInput | flyway_schema_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flyway_schema_histories.
     */
    cursor?: flyway_schema_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flyway_schema_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flyway_schema_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flyway_schema_histories.
     */
    distinct?: Flyway_schema_historyScalarFieldEnum | Flyway_schema_historyScalarFieldEnum[]
  }

  /**
   * flyway_schema_history findFirstOrThrow
   */
  export type flyway_schema_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     */
    select?: flyway_schema_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the flyway_schema_history
     */
    omit?: flyway_schema_historyOmit<ExtArgs> | null
    /**
     * Filter, which flyway_schema_history to fetch.
     */
    where?: flyway_schema_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flyway_schema_histories to fetch.
     */
    orderBy?: flyway_schema_historyOrderByWithRelationInput | flyway_schema_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flyway_schema_histories.
     */
    cursor?: flyway_schema_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flyway_schema_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flyway_schema_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flyway_schema_histories.
     */
    distinct?: Flyway_schema_historyScalarFieldEnum | Flyway_schema_historyScalarFieldEnum[]
  }

  /**
   * flyway_schema_history findMany
   */
  export type flyway_schema_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     */
    select?: flyway_schema_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the flyway_schema_history
     */
    omit?: flyway_schema_historyOmit<ExtArgs> | null
    /**
     * Filter, which flyway_schema_histories to fetch.
     */
    where?: flyway_schema_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flyway_schema_histories to fetch.
     */
    orderBy?: flyway_schema_historyOrderByWithRelationInput | flyway_schema_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing flyway_schema_histories.
     */
    cursor?: flyway_schema_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flyway_schema_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flyway_schema_histories.
     */
    skip?: number
    distinct?: Flyway_schema_historyScalarFieldEnum | Flyway_schema_historyScalarFieldEnum[]
  }

  /**
   * flyway_schema_history create
   */
  export type flyway_schema_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     */
    select?: flyway_schema_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the flyway_schema_history
     */
    omit?: flyway_schema_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a flyway_schema_history.
     */
    data: XOR<flyway_schema_historyCreateInput, flyway_schema_historyUncheckedCreateInput>
  }

  /**
   * flyway_schema_history createMany
   */
  export type flyway_schema_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many flyway_schema_histories.
     */
    data: flyway_schema_historyCreateManyInput | flyway_schema_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * flyway_schema_history update
   */
  export type flyway_schema_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     */
    select?: flyway_schema_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the flyway_schema_history
     */
    omit?: flyway_schema_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a flyway_schema_history.
     */
    data: XOR<flyway_schema_historyUpdateInput, flyway_schema_historyUncheckedUpdateInput>
    /**
     * Choose, which flyway_schema_history to update.
     */
    where: flyway_schema_historyWhereUniqueInput
  }

  /**
   * flyway_schema_history updateMany
   */
  export type flyway_schema_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update flyway_schema_histories.
     */
    data: XOR<flyway_schema_historyUpdateManyMutationInput, flyway_schema_historyUncheckedUpdateManyInput>
    /**
     * Filter which flyway_schema_histories to update
     */
    where?: flyway_schema_historyWhereInput
    /**
     * Limit how many flyway_schema_histories to update.
     */
    limit?: number
  }

  /**
   * flyway_schema_history upsert
   */
  export type flyway_schema_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     */
    select?: flyway_schema_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the flyway_schema_history
     */
    omit?: flyway_schema_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the flyway_schema_history to update in case it exists.
     */
    where: flyway_schema_historyWhereUniqueInput
    /**
     * In case the flyway_schema_history found by the `where` argument doesn't exist, create a new flyway_schema_history with this data.
     */
    create: XOR<flyway_schema_historyCreateInput, flyway_schema_historyUncheckedCreateInput>
    /**
     * In case the flyway_schema_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<flyway_schema_historyUpdateInput, flyway_schema_historyUncheckedUpdateInput>
  }

  /**
   * flyway_schema_history delete
   */
  export type flyway_schema_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     */
    select?: flyway_schema_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the flyway_schema_history
     */
    omit?: flyway_schema_historyOmit<ExtArgs> | null
    /**
     * Filter which flyway_schema_history to delete.
     */
    where: flyway_schema_historyWhereUniqueInput
  }

  /**
   * flyway_schema_history deleteMany
   */
  export type flyway_schema_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flyway_schema_histories to delete
     */
    where?: flyway_schema_historyWhereInput
    /**
     * Limit how many flyway_schema_histories to delete.
     */
    limit?: number
  }

  /**
   * flyway_schema_history without action
   */
  export type flyway_schema_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     */
    select?: flyway_schema_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the flyway_schema_history
     */
    omit?: flyway_schema_historyOmit<ExtArgs> | null
  }


  /**
   * Model follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _avg: FollowAvgAggregateOutputType | null
    _sum: FollowSumAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowAvgAggregateOutputType = {
    follow_id: number | null
    user_id: number | null
    target_user_id: number | null
  }

  export type FollowSumAggregateOutputType = {
    follow_id: bigint | null
    user_id: bigint | null
    target_user_id: bigint | null
  }

  export type FollowMinAggregateOutputType = {
    follow_id: bigint | null
    user_id: bigint | null
    target_user_id: bigint | null
    created_at: Date | null
    modified_at: Date | null
    deleted: boolean | null
  }

  export type FollowMaxAggregateOutputType = {
    follow_id: bigint | null
    user_id: bigint | null
    target_user_id: bigint | null
    created_at: Date | null
    modified_at: Date | null
    deleted: boolean | null
  }

  export type FollowCountAggregateOutputType = {
    follow_id: number
    user_id: number
    target_user_id: number
    created_at: number
    modified_at: number
    deleted: number
    _all: number
  }


  export type FollowAvgAggregateInputType = {
    follow_id?: true
    user_id?: true
    target_user_id?: true
  }

  export type FollowSumAggregateInputType = {
    follow_id?: true
    user_id?: true
    target_user_id?: true
  }

  export type FollowMinAggregateInputType = {
    follow_id?: true
    user_id?: true
    target_user_id?: true
    created_at?: true
    modified_at?: true
    deleted?: true
  }

  export type FollowMaxAggregateInputType = {
    follow_id?: true
    user_id?: true
    target_user_id?: true
    created_at?: true
    modified_at?: true
    deleted?: true
  }

  export type FollowCountAggregateInputType = {
    follow_id?: true
    user_id?: true
    target_user_id?: true
    created_at?: true
    modified_at?: true
    deleted?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which follow to aggregate.
     */
    where?: followWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of follows to fetch.
     */
    orderBy?: followOrderByWithRelationInput | followOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: followWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FollowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FollowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type followGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: followWhereInput
    orderBy?: followOrderByWithAggregationInput | followOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: followScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _avg?: FollowAvgAggregateInputType
    _sum?: FollowSumAggregateInputType
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    follow_id: bigint
    user_id: bigint
    target_user_id: bigint
    created_at: Date
    modified_at: Date
    deleted: boolean
    _count: FollowCountAggregateOutputType | null
    _avg: FollowAvgAggregateOutputType | null
    _sum: FollowSumAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends followGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type followSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    follow_id?: boolean
    user_id?: boolean
    target_user_id?: boolean
    created_at?: boolean
    modified_at?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["follow"]>



  export type followSelectScalar = {
    follow_id?: boolean
    user_id?: boolean
    target_user_id?: boolean
    created_at?: boolean
    modified_at?: boolean
    deleted?: boolean
  }

  export type followOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"follow_id" | "user_id" | "target_user_id" | "created_at" | "modified_at" | "deleted", ExtArgs["result"]["follow"]>

  export type $followPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "follow"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      follow_id: bigint
      user_id: bigint
      target_user_id: bigint
      created_at: Date
      modified_at: Date
      deleted: boolean
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type followGetPayload<S extends boolean | null | undefined | followDefaultArgs> = $Result.GetResult<Prisma.$followPayload, S>

  type followCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<followFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface followDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['follow'], meta: { name: 'follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {followFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends followFindUniqueArgs>(args: SelectSubset<T, followFindUniqueArgs<ExtArgs>>): Prisma__followClient<$Result.GetResult<Prisma.$followPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {followFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends followFindUniqueOrThrowArgs>(args: SelectSubset<T, followFindUniqueOrThrowArgs<ExtArgs>>): Prisma__followClient<$Result.GetResult<Prisma.$followPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends followFindFirstArgs>(args?: SelectSubset<T, followFindFirstArgs<ExtArgs>>): Prisma__followClient<$Result.GetResult<Prisma.$followPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends followFindFirstOrThrowArgs>(args?: SelectSubset<T, followFindFirstOrThrowArgs<ExtArgs>>): Prisma__followClient<$Result.GetResult<Prisma.$followPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `follow_id`
     * const followWithFollow_idOnly = await prisma.follow.findMany({ select: { follow_id: true } })
     * 
     */
    findMany<T extends followFindManyArgs>(args?: SelectSubset<T, followFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Follow.
     * @param {followCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends followCreateArgs>(args: SelectSubset<T, followCreateArgs<ExtArgs>>): Prisma__followClient<$Result.GetResult<Prisma.$followPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Follows.
     * @param {followCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends followCreateManyArgs>(args?: SelectSubset<T, followCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Follow.
     * @param {followDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends followDeleteArgs>(args: SelectSubset<T, followDeleteArgs<ExtArgs>>): Prisma__followClient<$Result.GetResult<Prisma.$followPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Follow.
     * @param {followUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends followUpdateArgs>(args: SelectSubset<T, followUpdateArgs<ExtArgs>>): Prisma__followClient<$Result.GetResult<Prisma.$followPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Follows.
     * @param {followDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends followDeleteManyArgs>(args?: SelectSubset<T, followDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends followUpdateManyArgs>(args: SelectSubset<T, followUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Follow.
     * @param {followUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends followUpsertArgs>(args: SelectSubset<T, followUpsertArgs<ExtArgs>>): Prisma__followClient<$Result.GetResult<Prisma.$followPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends followCountArgs>(
      args?: Subset<T, followCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends followGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: followGroupByArgs['orderBy'] }
        : { orderBy?: followGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, followGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the follow model
   */
  readonly fields: followFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__followClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the follow model
   */
  interface followFieldRefs {
    readonly follow_id: FieldRef<"follow", 'BigInt'>
    readonly user_id: FieldRef<"follow", 'BigInt'>
    readonly target_user_id: FieldRef<"follow", 'BigInt'>
    readonly created_at: FieldRef<"follow", 'DateTime'>
    readonly modified_at: FieldRef<"follow", 'DateTime'>
    readonly deleted: FieldRef<"follow", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * follow findUnique
   */
  export type followFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follow
     */
    select?: followSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follow
     */
    omit?: followOmit<ExtArgs> | null
    /**
     * Filter, which follow to fetch.
     */
    where: followWhereUniqueInput
  }

  /**
   * follow findUniqueOrThrow
   */
  export type followFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follow
     */
    select?: followSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follow
     */
    omit?: followOmit<ExtArgs> | null
    /**
     * Filter, which follow to fetch.
     */
    where: followWhereUniqueInput
  }

  /**
   * follow findFirst
   */
  export type followFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follow
     */
    select?: followSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follow
     */
    omit?: followOmit<ExtArgs> | null
    /**
     * Filter, which follow to fetch.
     */
    where?: followWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of follows to fetch.
     */
    orderBy?: followOrderByWithRelationInput | followOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for follows.
     */
    cursor?: followWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * follow findFirstOrThrow
   */
  export type followFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follow
     */
    select?: followSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follow
     */
    omit?: followOmit<ExtArgs> | null
    /**
     * Filter, which follow to fetch.
     */
    where?: followWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of follows to fetch.
     */
    orderBy?: followOrderByWithRelationInput | followOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for follows.
     */
    cursor?: followWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * follow findMany
   */
  export type followFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follow
     */
    select?: followSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follow
     */
    omit?: followOmit<ExtArgs> | null
    /**
     * Filter, which follows to fetch.
     */
    where?: followWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of follows to fetch.
     */
    orderBy?: followOrderByWithRelationInput | followOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing follows.
     */
    cursor?: followWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * follow create
   */
  export type followCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follow
     */
    select?: followSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follow
     */
    omit?: followOmit<ExtArgs> | null
    /**
     * The data needed to create a follow.
     */
    data: XOR<followCreateInput, followUncheckedCreateInput>
  }

  /**
   * follow createMany
   */
  export type followCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many follows.
     */
    data: followCreateManyInput | followCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * follow update
   */
  export type followUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follow
     */
    select?: followSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follow
     */
    omit?: followOmit<ExtArgs> | null
    /**
     * The data needed to update a follow.
     */
    data: XOR<followUpdateInput, followUncheckedUpdateInput>
    /**
     * Choose, which follow to update.
     */
    where: followWhereUniqueInput
  }

  /**
   * follow updateMany
   */
  export type followUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update follows.
     */
    data: XOR<followUpdateManyMutationInput, followUncheckedUpdateManyInput>
    /**
     * Filter which follows to update
     */
    where?: followWhereInput
    /**
     * Limit how many follows to update.
     */
    limit?: number
  }

  /**
   * follow upsert
   */
  export type followUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follow
     */
    select?: followSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follow
     */
    omit?: followOmit<ExtArgs> | null
    /**
     * The filter to search for the follow to update in case it exists.
     */
    where: followWhereUniqueInput
    /**
     * In case the follow found by the `where` argument doesn't exist, create a new follow with this data.
     */
    create: XOR<followCreateInput, followUncheckedCreateInput>
    /**
     * In case the follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<followUpdateInput, followUncheckedUpdateInput>
  }

  /**
   * follow delete
   */
  export type followDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follow
     */
    select?: followSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follow
     */
    omit?: followOmit<ExtArgs> | null
    /**
     * Filter which follow to delete.
     */
    where: followWhereUniqueInput
  }

  /**
   * follow deleteMany
   */
  export type followDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which follows to delete
     */
    where?: followWhereInput
    /**
     * Limit how many follows to delete.
     */
    limit?: number
  }

  /**
   * follow without action
   */
  export type followDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follow
     */
    select?: followSelect<ExtArgs> | null
    /**
     * Omit specific fields from the follow
     */
    omit?: followOmit<ExtArgs> | null
  }


  /**
   * Model hashtag
   */

  export type AggregateHashtag = {
    _count: HashtagCountAggregateOutputType | null
    _avg: HashtagAvgAggregateOutputType | null
    _sum: HashtagSumAggregateOutputType | null
    _min: HashtagMinAggregateOutputType | null
    _max: HashtagMaxAggregateOutputType | null
  }

  export type HashtagAvgAggregateOutputType = {
    hashtag_id: number | null
  }

  export type HashtagSumAggregateOutputType = {
    hashtag_id: bigint | null
  }

  export type HashtagMinAggregateOutputType = {
    hashtag_id: bigint | null
    hashtag: string | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type HashtagMaxAggregateOutputType = {
    hashtag_id: bigint | null
    hashtag: string | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type HashtagCountAggregateOutputType = {
    hashtag_id: number
    hashtag: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type HashtagAvgAggregateInputType = {
    hashtag_id?: true
  }

  export type HashtagSumAggregateInputType = {
    hashtag_id?: true
  }

  export type HashtagMinAggregateInputType = {
    hashtag_id?: true
    hashtag?: true
    created_at?: true
    modified_at?: true
  }

  export type HashtagMaxAggregateInputType = {
    hashtag_id?: true
    hashtag?: true
    created_at?: true
    modified_at?: true
  }

  export type HashtagCountAggregateInputType = {
    hashtag_id?: true
    hashtag?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type HashtagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hashtag to aggregate.
     */
    where?: hashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hashtags to fetch.
     */
    orderBy?: hashtagOrderByWithRelationInput | hashtagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hashtags
    **/
    _count?: true | HashtagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HashtagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HashtagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HashtagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HashtagMaxAggregateInputType
  }

  export type GetHashtagAggregateType<T extends HashtagAggregateArgs> = {
        [P in keyof T & keyof AggregateHashtag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHashtag[P]>
      : GetScalarType<T[P], AggregateHashtag[P]>
  }




  export type hashtagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hashtagWhereInput
    orderBy?: hashtagOrderByWithAggregationInput | hashtagOrderByWithAggregationInput[]
    by: HashtagScalarFieldEnum[] | HashtagScalarFieldEnum
    having?: hashtagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HashtagCountAggregateInputType | true
    _avg?: HashtagAvgAggregateInputType
    _sum?: HashtagSumAggregateInputType
    _min?: HashtagMinAggregateInputType
    _max?: HashtagMaxAggregateInputType
  }

  export type HashtagGroupByOutputType = {
    hashtag_id: bigint
    hashtag: string
    created_at: Date
    modified_at: Date
    _count: HashtagCountAggregateOutputType | null
    _avg: HashtagAvgAggregateOutputType | null
    _sum: HashtagSumAggregateOutputType | null
    _min: HashtagMinAggregateOutputType | null
    _max: HashtagMaxAggregateOutputType | null
  }

  type GetHashtagGroupByPayload<T extends hashtagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HashtagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HashtagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HashtagGroupByOutputType[P]>
            : GetScalarType<T[P], HashtagGroupByOutputType[P]>
        }
      >
    >


  export type hashtagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hashtag_id?: boolean
    hashtag?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["hashtag"]>



  export type hashtagSelectScalar = {
    hashtag_id?: boolean
    hashtag?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type hashtagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hashtag_id" | "hashtag" | "created_at" | "modified_at", ExtArgs["result"]["hashtag"]>

  export type $hashtagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hashtag"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      hashtag_id: bigint
      hashtag: string
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["hashtag"]>
    composites: {}
  }

  type hashtagGetPayload<S extends boolean | null | undefined | hashtagDefaultArgs> = $Result.GetResult<Prisma.$hashtagPayload, S>

  type hashtagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hashtagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HashtagCountAggregateInputType | true
    }

  export interface hashtagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hashtag'], meta: { name: 'hashtag' } }
    /**
     * Find zero or one Hashtag that matches the filter.
     * @param {hashtagFindUniqueArgs} args - Arguments to find a Hashtag
     * @example
     * // Get one Hashtag
     * const hashtag = await prisma.hashtag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hashtagFindUniqueArgs>(args: SelectSubset<T, hashtagFindUniqueArgs<ExtArgs>>): Prisma__hashtagClient<$Result.GetResult<Prisma.$hashtagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hashtag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hashtagFindUniqueOrThrowArgs} args - Arguments to find a Hashtag
     * @example
     * // Get one Hashtag
     * const hashtag = await prisma.hashtag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hashtagFindUniqueOrThrowArgs>(args: SelectSubset<T, hashtagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hashtagClient<$Result.GetResult<Prisma.$hashtagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hashtag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hashtagFindFirstArgs} args - Arguments to find a Hashtag
     * @example
     * // Get one Hashtag
     * const hashtag = await prisma.hashtag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hashtagFindFirstArgs>(args?: SelectSubset<T, hashtagFindFirstArgs<ExtArgs>>): Prisma__hashtagClient<$Result.GetResult<Prisma.$hashtagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hashtag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hashtagFindFirstOrThrowArgs} args - Arguments to find a Hashtag
     * @example
     * // Get one Hashtag
     * const hashtag = await prisma.hashtag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hashtagFindFirstOrThrowArgs>(args?: SelectSubset<T, hashtagFindFirstOrThrowArgs<ExtArgs>>): Prisma__hashtagClient<$Result.GetResult<Prisma.$hashtagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hashtagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hashtags
     * const hashtags = await prisma.hashtag.findMany()
     * 
     * // Get first 10 Hashtags
     * const hashtags = await prisma.hashtag.findMany({ take: 10 })
     * 
     * // Only select the `hashtag_id`
     * const hashtagWithHashtag_idOnly = await prisma.hashtag.findMany({ select: { hashtag_id: true } })
     * 
     */
    findMany<T extends hashtagFindManyArgs>(args?: SelectSubset<T, hashtagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hashtagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hashtag.
     * @param {hashtagCreateArgs} args - Arguments to create a Hashtag.
     * @example
     * // Create one Hashtag
     * const Hashtag = await prisma.hashtag.create({
     *   data: {
     *     // ... data to create a Hashtag
     *   }
     * })
     * 
     */
    create<T extends hashtagCreateArgs>(args: SelectSubset<T, hashtagCreateArgs<ExtArgs>>): Prisma__hashtagClient<$Result.GetResult<Prisma.$hashtagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hashtags.
     * @param {hashtagCreateManyArgs} args - Arguments to create many Hashtags.
     * @example
     * // Create many Hashtags
     * const hashtag = await prisma.hashtag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hashtagCreateManyArgs>(args?: SelectSubset<T, hashtagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hashtag.
     * @param {hashtagDeleteArgs} args - Arguments to delete one Hashtag.
     * @example
     * // Delete one Hashtag
     * const Hashtag = await prisma.hashtag.delete({
     *   where: {
     *     // ... filter to delete one Hashtag
     *   }
     * })
     * 
     */
    delete<T extends hashtagDeleteArgs>(args: SelectSubset<T, hashtagDeleteArgs<ExtArgs>>): Prisma__hashtagClient<$Result.GetResult<Prisma.$hashtagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hashtag.
     * @param {hashtagUpdateArgs} args - Arguments to update one Hashtag.
     * @example
     * // Update one Hashtag
     * const hashtag = await prisma.hashtag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hashtagUpdateArgs>(args: SelectSubset<T, hashtagUpdateArgs<ExtArgs>>): Prisma__hashtagClient<$Result.GetResult<Prisma.$hashtagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hashtags.
     * @param {hashtagDeleteManyArgs} args - Arguments to filter Hashtags to delete.
     * @example
     * // Delete a few Hashtags
     * const { count } = await prisma.hashtag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hashtagDeleteManyArgs>(args?: SelectSubset<T, hashtagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hashtagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hashtags
     * const hashtag = await prisma.hashtag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hashtagUpdateManyArgs>(args: SelectSubset<T, hashtagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hashtag.
     * @param {hashtagUpsertArgs} args - Arguments to update or create a Hashtag.
     * @example
     * // Update or create a Hashtag
     * const hashtag = await prisma.hashtag.upsert({
     *   create: {
     *     // ... data to create a Hashtag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hashtag we want to update
     *   }
     * })
     */
    upsert<T extends hashtagUpsertArgs>(args: SelectSubset<T, hashtagUpsertArgs<ExtArgs>>): Prisma__hashtagClient<$Result.GetResult<Prisma.$hashtagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hashtagCountArgs} args - Arguments to filter Hashtags to count.
     * @example
     * // Count the number of Hashtags
     * const count = await prisma.hashtag.count({
     *   where: {
     *     // ... the filter for the Hashtags we want to count
     *   }
     * })
    **/
    count<T extends hashtagCountArgs>(
      args?: Subset<T, hashtagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HashtagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashtagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HashtagAggregateArgs>(args: Subset<T, HashtagAggregateArgs>): Prisma.PrismaPromise<GetHashtagAggregateType<T>>

    /**
     * Group by Hashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hashtagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hashtagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hashtagGroupByArgs['orderBy'] }
        : { orderBy?: hashtagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hashtagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHashtagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hashtag model
   */
  readonly fields: hashtagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hashtag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hashtagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hashtag model
   */
  interface hashtagFieldRefs {
    readonly hashtag_id: FieldRef<"hashtag", 'BigInt'>
    readonly hashtag: FieldRef<"hashtag", 'String'>
    readonly created_at: FieldRef<"hashtag", 'DateTime'>
    readonly modified_at: FieldRef<"hashtag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * hashtag findUnique
   */
  export type hashtagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashtag
     */
    select?: hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashtag
     */
    omit?: hashtagOmit<ExtArgs> | null
    /**
     * Filter, which hashtag to fetch.
     */
    where: hashtagWhereUniqueInput
  }

  /**
   * hashtag findUniqueOrThrow
   */
  export type hashtagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashtag
     */
    select?: hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashtag
     */
    omit?: hashtagOmit<ExtArgs> | null
    /**
     * Filter, which hashtag to fetch.
     */
    where: hashtagWhereUniqueInput
  }

  /**
   * hashtag findFirst
   */
  export type hashtagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashtag
     */
    select?: hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashtag
     */
    omit?: hashtagOmit<ExtArgs> | null
    /**
     * Filter, which hashtag to fetch.
     */
    where?: hashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hashtags to fetch.
     */
    orderBy?: hashtagOrderByWithRelationInput | hashtagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hashtags.
     */
    cursor?: hashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hashtags.
     */
    distinct?: HashtagScalarFieldEnum | HashtagScalarFieldEnum[]
  }

  /**
   * hashtag findFirstOrThrow
   */
  export type hashtagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashtag
     */
    select?: hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashtag
     */
    omit?: hashtagOmit<ExtArgs> | null
    /**
     * Filter, which hashtag to fetch.
     */
    where?: hashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hashtags to fetch.
     */
    orderBy?: hashtagOrderByWithRelationInput | hashtagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hashtags.
     */
    cursor?: hashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hashtags.
     */
    distinct?: HashtagScalarFieldEnum | HashtagScalarFieldEnum[]
  }

  /**
   * hashtag findMany
   */
  export type hashtagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashtag
     */
    select?: hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashtag
     */
    omit?: hashtagOmit<ExtArgs> | null
    /**
     * Filter, which hashtags to fetch.
     */
    where?: hashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hashtags to fetch.
     */
    orderBy?: hashtagOrderByWithRelationInput | hashtagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hashtags.
     */
    cursor?: hashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hashtags.
     */
    skip?: number
    distinct?: HashtagScalarFieldEnum | HashtagScalarFieldEnum[]
  }

  /**
   * hashtag create
   */
  export type hashtagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashtag
     */
    select?: hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashtag
     */
    omit?: hashtagOmit<ExtArgs> | null
    /**
     * The data needed to create a hashtag.
     */
    data: XOR<hashtagCreateInput, hashtagUncheckedCreateInput>
  }

  /**
   * hashtag createMany
   */
  export type hashtagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hashtags.
     */
    data: hashtagCreateManyInput | hashtagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hashtag update
   */
  export type hashtagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashtag
     */
    select?: hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashtag
     */
    omit?: hashtagOmit<ExtArgs> | null
    /**
     * The data needed to update a hashtag.
     */
    data: XOR<hashtagUpdateInput, hashtagUncheckedUpdateInput>
    /**
     * Choose, which hashtag to update.
     */
    where: hashtagWhereUniqueInput
  }

  /**
   * hashtag updateMany
   */
  export type hashtagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hashtags.
     */
    data: XOR<hashtagUpdateManyMutationInput, hashtagUncheckedUpdateManyInput>
    /**
     * Filter which hashtags to update
     */
    where?: hashtagWhereInput
    /**
     * Limit how many hashtags to update.
     */
    limit?: number
  }

  /**
   * hashtag upsert
   */
  export type hashtagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashtag
     */
    select?: hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashtag
     */
    omit?: hashtagOmit<ExtArgs> | null
    /**
     * The filter to search for the hashtag to update in case it exists.
     */
    where: hashtagWhereUniqueInput
    /**
     * In case the hashtag found by the `where` argument doesn't exist, create a new hashtag with this data.
     */
    create: XOR<hashtagCreateInput, hashtagUncheckedCreateInput>
    /**
     * In case the hashtag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hashtagUpdateInput, hashtagUncheckedUpdateInput>
  }

  /**
   * hashtag delete
   */
  export type hashtagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashtag
     */
    select?: hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashtag
     */
    omit?: hashtagOmit<ExtArgs> | null
    /**
     * Filter which hashtag to delete.
     */
    where: hashtagWhereUniqueInput
  }

  /**
   * hashtag deleteMany
   */
  export type hashtagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hashtags to delete
     */
    where?: hashtagWhereInput
    /**
     * Limit how many hashtags to delete.
     */
    limit?: number
  }

  /**
   * hashtag without action
   */
  export type hashtagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hashtag
     */
    select?: hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hashtag
     */
    omit?: hashtagOmit<ExtArgs> | null
  }


  /**
   * Model hobby
   */

  export type AggregateHobby = {
    _count: HobbyCountAggregateOutputType | null
    _avg: HobbyAvgAggregateOutputType | null
    _sum: HobbySumAggregateOutputType | null
    _min: HobbyMinAggregateOutputType | null
    _max: HobbyMaxAggregateOutputType | null
  }

  export type HobbyAvgAggregateOutputType = {
    hobby_id: number | null
    user_id: number | null
    hobby_category_id: number | null
    hobby_group_id: number | null
    created_by: number | null
    modified_by: number | null
  }

  export type HobbySumAggregateOutputType = {
    hobby_id: bigint | null
    user_id: bigint | null
    hobby_category_id: bigint | null
    hobby_group_id: bigint | null
    created_by: bigint | null
    modified_by: bigint | null
  }

  export type HobbyMinAggregateOutputType = {
    hobby_id: bigint | null
    user_id: bigint | null
    hobby_category_id: bigint | null
    hobby_name: string | null
    hobby_group_id: bigint | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
  }

  export type HobbyMaxAggregateOutputType = {
    hobby_id: bigint | null
    user_id: bigint | null
    hobby_category_id: bigint | null
    hobby_name: string | null
    hobby_group_id: bigint | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
  }

  export type HobbyCountAggregateOutputType = {
    hobby_id: number
    user_id: number
    hobby_category_id: number
    hobby_name: number
    hobby_group_id: number
    created_at: number
    created_by: number
    modified_at: number
    modified_by: number
    deleted: number
    _all: number
  }


  export type HobbyAvgAggregateInputType = {
    hobby_id?: true
    user_id?: true
    hobby_category_id?: true
    hobby_group_id?: true
    created_by?: true
    modified_by?: true
  }

  export type HobbySumAggregateInputType = {
    hobby_id?: true
    user_id?: true
    hobby_category_id?: true
    hobby_group_id?: true
    created_by?: true
    modified_by?: true
  }

  export type HobbyMinAggregateInputType = {
    hobby_id?: true
    user_id?: true
    hobby_category_id?: true
    hobby_name?: true
    hobby_group_id?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
  }

  export type HobbyMaxAggregateInputType = {
    hobby_id?: true
    user_id?: true
    hobby_category_id?: true
    hobby_name?: true
    hobby_group_id?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
  }

  export type HobbyCountAggregateInputType = {
    hobby_id?: true
    user_id?: true
    hobby_category_id?: true
    hobby_name?: true
    hobby_group_id?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
    _all?: true
  }

  export type HobbyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby to aggregate.
     */
    where?: hobbyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobbies to fetch.
     */
    orderBy?: hobbyOrderByWithRelationInput | hobbyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hobbyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobbies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobbies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hobbies
    **/
    _count?: true | HobbyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HobbyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HobbySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HobbyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HobbyMaxAggregateInputType
  }

  export type GetHobbyAggregateType<T extends HobbyAggregateArgs> = {
        [P in keyof T & keyof AggregateHobby]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHobby[P]>
      : GetScalarType<T[P], AggregateHobby[P]>
  }




  export type hobbyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hobbyWhereInput
    orderBy?: hobbyOrderByWithAggregationInput | hobbyOrderByWithAggregationInput[]
    by: HobbyScalarFieldEnum[] | HobbyScalarFieldEnum
    having?: hobbyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HobbyCountAggregateInputType | true
    _avg?: HobbyAvgAggregateInputType
    _sum?: HobbySumAggregateInputType
    _min?: HobbyMinAggregateInputType
    _max?: HobbyMaxAggregateInputType
  }

  export type HobbyGroupByOutputType = {
    hobby_id: bigint
    user_id: bigint
    hobby_category_id: bigint
    hobby_name: string
    hobby_group_id: bigint
    created_at: Date
    created_by: bigint
    modified_at: Date
    modified_by: bigint
    deleted: boolean
    _count: HobbyCountAggregateOutputType | null
    _avg: HobbyAvgAggregateOutputType | null
    _sum: HobbySumAggregateOutputType | null
    _min: HobbyMinAggregateOutputType | null
    _max: HobbyMaxAggregateOutputType | null
  }

  type GetHobbyGroupByPayload<T extends hobbyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HobbyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HobbyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HobbyGroupByOutputType[P]>
            : GetScalarType<T[P], HobbyGroupByOutputType[P]>
        }
      >
    >


  export type hobbySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hobby_id?: boolean
    user_id?: boolean
    hobby_category_id?: boolean
    hobby_name?: boolean
    hobby_group_id?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["hobby"]>



  export type hobbySelectScalar = {
    hobby_id?: boolean
    user_id?: boolean
    hobby_category_id?: boolean
    hobby_name?: boolean
    hobby_group_id?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
  }

  export type hobbyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hobby_id" | "user_id" | "hobby_category_id" | "hobby_name" | "hobby_group_id" | "created_at" | "created_by" | "modified_at" | "modified_by" | "deleted", ExtArgs["result"]["hobby"]>

  export type $hobbyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hobby"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      hobby_id: bigint
      user_id: bigint
      hobby_category_id: bigint
      hobby_name: string
      hobby_group_id: bigint
      created_at: Date
      created_by: bigint
      modified_at: Date
      modified_by: bigint
      deleted: boolean
    }, ExtArgs["result"]["hobby"]>
    composites: {}
  }

  type hobbyGetPayload<S extends boolean | null | undefined | hobbyDefaultArgs> = $Result.GetResult<Prisma.$hobbyPayload, S>

  type hobbyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hobbyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HobbyCountAggregateInputType | true
    }

  export interface hobbyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hobby'], meta: { name: 'hobby' } }
    /**
     * Find zero or one Hobby that matches the filter.
     * @param {hobbyFindUniqueArgs} args - Arguments to find a Hobby
     * @example
     * // Get one Hobby
     * const hobby = await prisma.hobby.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hobbyFindUniqueArgs>(args: SelectSubset<T, hobbyFindUniqueArgs<ExtArgs>>): Prisma__hobbyClient<$Result.GetResult<Prisma.$hobbyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hobby that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hobbyFindUniqueOrThrowArgs} args - Arguments to find a Hobby
     * @example
     * // Get one Hobby
     * const hobby = await prisma.hobby.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hobbyFindUniqueOrThrowArgs>(args: SelectSubset<T, hobbyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hobbyClient<$Result.GetResult<Prisma.$hobbyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobbyFindFirstArgs} args - Arguments to find a Hobby
     * @example
     * // Get one Hobby
     * const hobby = await prisma.hobby.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hobbyFindFirstArgs>(args?: SelectSubset<T, hobbyFindFirstArgs<ExtArgs>>): Prisma__hobbyClient<$Result.GetResult<Prisma.$hobbyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobbyFindFirstOrThrowArgs} args - Arguments to find a Hobby
     * @example
     * // Get one Hobby
     * const hobby = await prisma.hobby.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hobbyFindFirstOrThrowArgs>(args?: SelectSubset<T, hobbyFindFirstOrThrowArgs<ExtArgs>>): Prisma__hobbyClient<$Result.GetResult<Prisma.$hobbyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hobbies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobbyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hobbies
     * const hobbies = await prisma.hobby.findMany()
     * 
     * // Get first 10 Hobbies
     * const hobbies = await prisma.hobby.findMany({ take: 10 })
     * 
     * // Only select the `hobby_id`
     * const hobbyWithHobby_idOnly = await prisma.hobby.findMany({ select: { hobby_id: true } })
     * 
     */
    findMany<T extends hobbyFindManyArgs>(args?: SelectSubset<T, hobbyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hobbyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hobby.
     * @param {hobbyCreateArgs} args - Arguments to create a Hobby.
     * @example
     * // Create one Hobby
     * const Hobby = await prisma.hobby.create({
     *   data: {
     *     // ... data to create a Hobby
     *   }
     * })
     * 
     */
    create<T extends hobbyCreateArgs>(args: SelectSubset<T, hobbyCreateArgs<ExtArgs>>): Prisma__hobbyClient<$Result.GetResult<Prisma.$hobbyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hobbies.
     * @param {hobbyCreateManyArgs} args - Arguments to create many Hobbies.
     * @example
     * // Create many Hobbies
     * const hobby = await prisma.hobby.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hobbyCreateManyArgs>(args?: SelectSubset<T, hobbyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hobby.
     * @param {hobbyDeleteArgs} args - Arguments to delete one Hobby.
     * @example
     * // Delete one Hobby
     * const Hobby = await prisma.hobby.delete({
     *   where: {
     *     // ... filter to delete one Hobby
     *   }
     * })
     * 
     */
    delete<T extends hobbyDeleteArgs>(args: SelectSubset<T, hobbyDeleteArgs<ExtArgs>>): Prisma__hobbyClient<$Result.GetResult<Prisma.$hobbyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hobby.
     * @param {hobbyUpdateArgs} args - Arguments to update one Hobby.
     * @example
     * // Update one Hobby
     * const hobby = await prisma.hobby.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hobbyUpdateArgs>(args: SelectSubset<T, hobbyUpdateArgs<ExtArgs>>): Prisma__hobbyClient<$Result.GetResult<Prisma.$hobbyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hobbies.
     * @param {hobbyDeleteManyArgs} args - Arguments to filter Hobbies to delete.
     * @example
     * // Delete a few Hobbies
     * const { count } = await prisma.hobby.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hobbyDeleteManyArgs>(args?: SelectSubset<T, hobbyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hobbies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobbyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hobbies
     * const hobby = await prisma.hobby.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hobbyUpdateManyArgs>(args: SelectSubset<T, hobbyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hobby.
     * @param {hobbyUpsertArgs} args - Arguments to update or create a Hobby.
     * @example
     * // Update or create a Hobby
     * const hobby = await prisma.hobby.upsert({
     *   create: {
     *     // ... data to create a Hobby
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hobby we want to update
     *   }
     * })
     */
    upsert<T extends hobbyUpsertArgs>(args: SelectSubset<T, hobbyUpsertArgs<ExtArgs>>): Prisma__hobbyClient<$Result.GetResult<Prisma.$hobbyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hobbies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobbyCountArgs} args - Arguments to filter Hobbies to count.
     * @example
     * // Count the number of Hobbies
     * const count = await prisma.hobby.count({
     *   where: {
     *     // ... the filter for the Hobbies we want to count
     *   }
     * })
    **/
    count<T extends hobbyCountArgs>(
      args?: Subset<T, hobbyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HobbyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hobby.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HobbyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HobbyAggregateArgs>(args: Subset<T, HobbyAggregateArgs>): Prisma.PrismaPromise<GetHobbyAggregateType<T>>

    /**
     * Group by Hobby.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobbyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hobbyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hobbyGroupByArgs['orderBy'] }
        : { orderBy?: hobbyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hobbyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHobbyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hobby model
   */
  readonly fields: hobbyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hobby.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hobbyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hobby model
   */
  interface hobbyFieldRefs {
    readonly hobby_id: FieldRef<"hobby", 'BigInt'>
    readonly user_id: FieldRef<"hobby", 'BigInt'>
    readonly hobby_category_id: FieldRef<"hobby", 'BigInt'>
    readonly hobby_name: FieldRef<"hobby", 'String'>
    readonly hobby_group_id: FieldRef<"hobby", 'BigInt'>
    readonly created_at: FieldRef<"hobby", 'DateTime'>
    readonly created_by: FieldRef<"hobby", 'BigInt'>
    readonly modified_at: FieldRef<"hobby", 'DateTime'>
    readonly modified_by: FieldRef<"hobby", 'BigInt'>
    readonly deleted: FieldRef<"hobby", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * hobby findUnique
   */
  export type hobbyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby
     */
    select?: hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby
     */
    omit?: hobbyOmit<ExtArgs> | null
    /**
     * Filter, which hobby to fetch.
     */
    where: hobbyWhereUniqueInput
  }

  /**
   * hobby findUniqueOrThrow
   */
  export type hobbyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby
     */
    select?: hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby
     */
    omit?: hobbyOmit<ExtArgs> | null
    /**
     * Filter, which hobby to fetch.
     */
    where: hobbyWhereUniqueInput
  }

  /**
   * hobby findFirst
   */
  export type hobbyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby
     */
    select?: hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby
     */
    omit?: hobbyOmit<ExtArgs> | null
    /**
     * Filter, which hobby to fetch.
     */
    where?: hobbyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobbies to fetch.
     */
    orderBy?: hobbyOrderByWithRelationInput | hobbyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobbies.
     */
    cursor?: hobbyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobbies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobbies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobbies.
     */
    distinct?: HobbyScalarFieldEnum | HobbyScalarFieldEnum[]
  }

  /**
   * hobby findFirstOrThrow
   */
  export type hobbyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby
     */
    select?: hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby
     */
    omit?: hobbyOmit<ExtArgs> | null
    /**
     * Filter, which hobby to fetch.
     */
    where?: hobbyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobbies to fetch.
     */
    orderBy?: hobbyOrderByWithRelationInput | hobbyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobbies.
     */
    cursor?: hobbyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobbies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobbies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobbies.
     */
    distinct?: HobbyScalarFieldEnum | HobbyScalarFieldEnum[]
  }

  /**
   * hobby findMany
   */
  export type hobbyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby
     */
    select?: hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby
     */
    omit?: hobbyOmit<ExtArgs> | null
    /**
     * Filter, which hobbies to fetch.
     */
    where?: hobbyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobbies to fetch.
     */
    orderBy?: hobbyOrderByWithRelationInput | hobbyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hobbies.
     */
    cursor?: hobbyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobbies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobbies.
     */
    skip?: number
    distinct?: HobbyScalarFieldEnum | HobbyScalarFieldEnum[]
  }

  /**
   * hobby create
   */
  export type hobbyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby
     */
    select?: hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby
     */
    omit?: hobbyOmit<ExtArgs> | null
    /**
     * The data needed to create a hobby.
     */
    data: XOR<hobbyCreateInput, hobbyUncheckedCreateInput>
  }

  /**
   * hobby createMany
   */
  export type hobbyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hobbies.
     */
    data: hobbyCreateManyInput | hobbyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hobby update
   */
  export type hobbyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby
     */
    select?: hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby
     */
    omit?: hobbyOmit<ExtArgs> | null
    /**
     * The data needed to update a hobby.
     */
    data: XOR<hobbyUpdateInput, hobbyUncheckedUpdateInput>
    /**
     * Choose, which hobby to update.
     */
    where: hobbyWhereUniqueInput
  }

  /**
   * hobby updateMany
   */
  export type hobbyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hobbies.
     */
    data: XOR<hobbyUpdateManyMutationInput, hobbyUncheckedUpdateManyInput>
    /**
     * Filter which hobbies to update
     */
    where?: hobbyWhereInput
    /**
     * Limit how many hobbies to update.
     */
    limit?: number
  }

  /**
   * hobby upsert
   */
  export type hobbyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby
     */
    select?: hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby
     */
    omit?: hobbyOmit<ExtArgs> | null
    /**
     * The filter to search for the hobby to update in case it exists.
     */
    where: hobbyWhereUniqueInput
    /**
     * In case the hobby found by the `where` argument doesn't exist, create a new hobby with this data.
     */
    create: XOR<hobbyCreateInput, hobbyUncheckedCreateInput>
    /**
     * In case the hobby was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hobbyUpdateInput, hobbyUncheckedUpdateInput>
  }

  /**
   * hobby delete
   */
  export type hobbyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby
     */
    select?: hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby
     */
    omit?: hobbyOmit<ExtArgs> | null
    /**
     * Filter which hobby to delete.
     */
    where: hobbyWhereUniqueInput
  }

  /**
   * hobby deleteMany
   */
  export type hobbyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobbies to delete
     */
    where?: hobbyWhereInput
    /**
     * Limit how many hobbies to delete.
     */
    limit?: number
  }

  /**
   * hobby without action
   */
  export type hobbyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby
     */
    select?: hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby
     */
    omit?: hobbyOmit<ExtArgs> | null
  }


  /**
   * Model hobby_category
   */

  export type AggregateHobby_category = {
    _count: Hobby_categoryCountAggregateOutputType | null
    _avg: Hobby_categoryAvgAggregateOutputType | null
    _sum: Hobby_categorySumAggregateOutputType | null
    _min: Hobby_categoryMinAggregateOutputType | null
    _max: Hobby_categoryMaxAggregateOutputType | null
  }

  export type Hobby_categoryAvgAggregateOutputType = {
    hobby_category_id: number | null
  }

  export type Hobby_categorySumAggregateOutputType = {
    hobby_category_id: bigint | null
  }

  export type Hobby_categoryMinAggregateOutputType = {
    hobby_category_id: bigint | null
    hobby_category_name: $Enums.hobby_category_hobby_category_name | null
    hobby_category_thumbnail: string | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type Hobby_categoryMaxAggregateOutputType = {
    hobby_category_id: bigint | null
    hobby_category_name: $Enums.hobby_category_hobby_category_name | null
    hobby_category_thumbnail: string | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type Hobby_categoryCountAggregateOutputType = {
    hobby_category_id: number
    hobby_category_name: number
    hobby_category_thumbnail: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type Hobby_categoryAvgAggregateInputType = {
    hobby_category_id?: true
  }

  export type Hobby_categorySumAggregateInputType = {
    hobby_category_id?: true
  }

  export type Hobby_categoryMinAggregateInputType = {
    hobby_category_id?: true
    hobby_category_name?: true
    hobby_category_thumbnail?: true
    created_at?: true
    modified_at?: true
  }

  export type Hobby_categoryMaxAggregateInputType = {
    hobby_category_id?: true
    hobby_category_name?: true
    hobby_category_thumbnail?: true
    created_at?: true
    modified_at?: true
  }

  export type Hobby_categoryCountAggregateInputType = {
    hobby_category_id?: true
    hobby_category_name?: true
    hobby_category_thumbnail?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type Hobby_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_category to aggregate.
     */
    where?: hobby_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_categories to fetch.
     */
    orderBy?: hobby_categoryOrderByWithRelationInput | hobby_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hobby_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hobby_categories
    **/
    _count?: true | Hobby_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hobby_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hobby_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hobby_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hobby_categoryMaxAggregateInputType
  }

  export type GetHobby_categoryAggregateType<T extends Hobby_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateHobby_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHobby_category[P]>
      : GetScalarType<T[P], AggregateHobby_category[P]>
  }




  export type hobby_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hobby_categoryWhereInput
    orderBy?: hobby_categoryOrderByWithAggregationInput | hobby_categoryOrderByWithAggregationInput[]
    by: Hobby_categoryScalarFieldEnum[] | Hobby_categoryScalarFieldEnum
    having?: hobby_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hobby_categoryCountAggregateInputType | true
    _avg?: Hobby_categoryAvgAggregateInputType
    _sum?: Hobby_categorySumAggregateInputType
    _min?: Hobby_categoryMinAggregateInputType
    _max?: Hobby_categoryMaxAggregateInputType
  }

  export type Hobby_categoryGroupByOutputType = {
    hobby_category_id: bigint
    hobby_category_name: $Enums.hobby_category_hobby_category_name
    hobby_category_thumbnail: string
    created_at: Date
    modified_at: Date
    _count: Hobby_categoryCountAggregateOutputType | null
    _avg: Hobby_categoryAvgAggregateOutputType | null
    _sum: Hobby_categorySumAggregateOutputType | null
    _min: Hobby_categoryMinAggregateOutputType | null
    _max: Hobby_categoryMaxAggregateOutputType | null
  }

  type GetHobby_categoryGroupByPayload<T extends hobby_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Hobby_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hobby_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hobby_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Hobby_categoryGroupByOutputType[P]>
        }
      >
    >


  export type hobby_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hobby_category_id?: boolean
    hobby_category_name?: boolean
    hobby_category_thumbnail?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["hobby_category"]>



  export type hobby_categorySelectScalar = {
    hobby_category_id?: boolean
    hobby_category_name?: boolean
    hobby_category_thumbnail?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type hobby_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hobby_category_id" | "hobby_category_name" | "hobby_category_thumbnail" | "created_at" | "modified_at", ExtArgs["result"]["hobby_category"]>

  export type $hobby_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hobby_category"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      hobby_category_id: bigint
      hobby_category_name: $Enums.hobby_category_hobby_category_name
      hobby_category_thumbnail: string
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["hobby_category"]>
    composites: {}
  }

  type hobby_categoryGetPayload<S extends boolean | null | undefined | hobby_categoryDefaultArgs> = $Result.GetResult<Prisma.$hobby_categoryPayload, S>

  type hobby_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hobby_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Hobby_categoryCountAggregateInputType | true
    }

  export interface hobby_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hobby_category'], meta: { name: 'hobby_category' } }
    /**
     * Find zero or one Hobby_category that matches the filter.
     * @param {hobby_categoryFindUniqueArgs} args - Arguments to find a Hobby_category
     * @example
     * // Get one Hobby_category
     * const hobby_category = await prisma.hobby_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hobby_categoryFindUniqueArgs>(args: SelectSubset<T, hobby_categoryFindUniqueArgs<ExtArgs>>): Prisma__hobby_categoryClient<$Result.GetResult<Prisma.$hobby_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hobby_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hobby_categoryFindUniqueOrThrowArgs} args - Arguments to find a Hobby_category
     * @example
     * // Get one Hobby_category
     * const hobby_category = await prisma.hobby_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hobby_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, hobby_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hobby_categoryClient<$Result.GetResult<Prisma.$hobby_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_categoryFindFirstArgs} args - Arguments to find a Hobby_category
     * @example
     * // Get one Hobby_category
     * const hobby_category = await prisma.hobby_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hobby_categoryFindFirstArgs>(args?: SelectSubset<T, hobby_categoryFindFirstArgs<ExtArgs>>): Prisma__hobby_categoryClient<$Result.GetResult<Prisma.$hobby_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_categoryFindFirstOrThrowArgs} args - Arguments to find a Hobby_category
     * @example
     * // Get one Hobby_category
     * const hobby_category = await prisma.hobby_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hobby_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, hobby_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__hobby_categoryClient<$Result.GetResult<Prisma.$hobby_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hobby_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hobby_categories
     * const hobby_categories = await prisma.hobby_category.findMany()
     * 
     * // Get first 10 Hobby_categories
     * const hobby_categories = await prisma.hobby_category.findMany({ take: 10 })
     * 
     * // Only select the `hobby_category_id`
     * const hobby_categoryWithHobby_category_idOnly = await prisma.hobby_category.findMany({ select: { hobby_category_id: true } })
     * 
     */
    findMany<T extends hobby_categoryFindManyArgs>(args?: SelectSubset<T, hobby_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hobby_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hobby_category.
     * @param {hobby_categoryCreateArgs} args - Arguments to create a Hobby_category.
     * @example
     * // Create one Hobby_category
     * const Hobby_category = await prisma.hobby_category.create({
     *   data: {
     *     // ... data to create a Hobby_category
     *   }
     * })
     * 
     */
    create<T extends hobby_categoryCreateArgs>(args: SelectSubset<T, hobby_categoryCreateArgs<ExtArgs>>): Prisma__hobby_categoryClient<$Result.GetResult<Prisma.$hobby_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hobby_categories.
     * @param {hobby_categoryCreateManyArgs} args - Arguments to create many Hobby_categories.
     * @example
     * // Create many Hobby_categories
     * const hobby_category = await prisma.hobby_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hobby_categoryCreateManyArgs>(args?: SelectSubset<T, hobby_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hobby_category.
     * @param {hobby_categoryDeleteArgs} args - Arguments to delete one Hobby_category.
     * @example
     * // Delete one Hobby_category
     * const Hobby_category = await prisma.hobby_category.delete({
     *   where: {
     *     // ... filter to delete one Hobby_category
     *   }
     * })
     * 
     */
    delete<T extends hobby_categoryDeleteArgs>(args: SelectSubset<T, hobby_categoryDeleteArgs<ExtArgs>>): Prisma__hobby_categoryClient<$Result.GetResult<Prisma.$hobby_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hobby_category.
     * @param {hobby_categoryUpdateArgs} args - Arguments to update one Hobby_category.
     * @example
     * // Update one Hobby_category
     * const hobby_category = await prisma.hobby_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hobby_categoryUpdateArgs>(args: SelectSubset<T, hobby_categoryUpdateArgs<ExtArgs>>): Prisma__hobby_categoryClient<$Result.GetResult<Prisma.$hobby_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hobby_categories.
     * @param {hobby_categoryDeleteManyArgs} args - Arguments to filter Hobby_categories to delete.
     * @example
     * // Delete a few Hobby_categories
     * const { count } = await prisma.hobby_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hobby_categoryDeleteManyArgs>(args?: SelectSubset<T, hobby_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hobby_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hobby_categories
     * const hobby_category = await prisma.hobby_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hobby_categoryUpdateManyArgs>(args: SelectSubset<T, hobby_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hobby_category.
     * @param {hobby_categoryUpsertArgs} args - Arguments to update or create a Hobby_category.
     * @example
     * // Update or create a Hobby_category
     * const hobby_category = await prisma.hobby_category.upsert({
     *   create: {
     *     // ... data to create a Hobby_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hobby_category we want to update
     *   }
     * })
     */
    upsert<T extends hobby_categoryUpsertArgs>(args: SelectSubset<T, hobby_categoryUpsertArgs<ExtArgs>>): Prisma__hobby_categoryClient<$Result.GetResult<Prisma.$hobby_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hobby_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_categoryCountArgs} args - Arguments to filter Hobby_categories to count.
     * @example
     * // Count the number of Hobby_categories
     * const count = await prisma.hobby_category.count({
     *   where: {
     *     // ... the filter for the Hobby_categories we want to count
     *   }
     * })
    **/
    count<T extends hobby_categoryCountArgs>(
      args?: Subset<T, hobby_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hobby_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hobby_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hobby_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hobby_categoryAggregateArgs>(args: Subset<T, Hobby_categoryAggregateArgs>): Prisma.PrismaPromise<GetHobby_categoryAggregateType<T>>

    /**
     * Group by Hobby_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hobby_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hobby_categoryGroupByArgs['orderBy'] }
        : { orderBy?: hobby_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hobby_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHobby_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hobby_category model
   */
  readonly fields: hobby_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hobby_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hobby_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hobby_category model
   */
  interface hobby_categoryFieldRefs {
    readonly hobby_category_id: FieldRef<"hobby_category", 'BigInt'>
    readonly hobby_category_name: FieldRef<"hobby_category", 'hobby_category_hobby_category_name'>
    readonly hobby_category_thumbnail: FieldRef<"hobby_category", 'String'>
    readonly created_at: FieldRef<"hobby_category", 'DateTime'>
    readonly modified_at: FieldRef<"hobby_category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * hobby_category findUnique
   */
  export type hobby_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_category
     */
    select?: hobby_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_category
     */
    omit?: hobby_categoryOmit<ExtArgs> | null
    /**
     * Filter, which hobby_category to fetch.
     */
    where: hobby_categoryWhereUniqueInput
  }

  /**
   * hobby_category findUniqueOrThrow
   */
  export type hobby_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_category
     */
    select?: hobby_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_category
     */
    omit?: hobby_categoryOmit<ExtArgs> | null
    /**
     * Filter, which hobby_category to fetch.
     */
    where: hobby_categoryWhereUniqueInput
  }

  /**
   * hobby_category findFirst
   */
  export type hobby_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_category
     */
    select?: hobby_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_category
     */
    omit?: hobby_categoryOmit<ExtArgs> | null
    /**
     * Filter, which hobby_category to fetch.
     */
    where?: hobby_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_categories to fetch.
     */
    orderBy?: hobby_categoryOrderByWithRelationInput | hobby_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_categories.
     */
    cursor?: hobby_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_categories.
     */
    distinct?: Hobby_categoryScalarFieldEnum | Hobby_categoryScalarFieldEnum[]
  }

  /**
   * hobby_category findFirstOrThrow
   */
  export type hobby_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_category
     */
    select?: hobby_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_category
     */
    omit?: hobby_categoryOmit<ExtArgs> | null
    /**
     * Filter, which hobby_category to fetch.
     */
    where?: hobby_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_categories to fetch.
     */
    orderBy?: hobby_categoryOrderByWithRelationInput | hobby_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_categories.
     */
    cursor?: hobby_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_categories.
     */
    distinct?: Hobby_categoryScalarFieldEnum | Hobby_categoryScalarFieldEnum[]
  }

  /**
   * hobby_category findMany
   */
  export type hobby_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_category
     */
    select?: hobby_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_category
     */
    omit?: hobby_categoryOmit<ExtArgs> | null
    /**
     * Filter, which hobby_categories to fetch.
     */
    where?: hobby_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_categories to fetch.
     */
    orderBy?: hobby_categoryOrderByWithRelationInput | hobby_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hobby_categories.
     */
    cursor?: hobby_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_categories.
     */
    skip?: number
    distinct?: Hobby_categoryScalarFieldEnum | Hobby_categoryScalarFieldEnum[]
  }

  /**
   * hobby_category create
   */
  export type hobby_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_category
     */
    select?: hobby_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_category
     */
    omit?: hobby_categoryOmit<ExtArgs> | null
    /**
     * The data needed to create a hobby_category.
     */
    data: XOR<hobby_categoryCreateInput, hobby_categoryUncheckedCreateInput>
  }

  /**
   * hobby_category createMany
   */
  export type hobby_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hobby_categories.
     */
    data: hobby_categoryCreateManyInput | hobby_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hobby_category update
   */
  export type hobby_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_category
     */
    select?: hobby_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_category
     */
    omit?: hobby_categoryOmit<ExtArgs> | null
    /**
     * The data needed to update a hobby_category.
     */
    data: XOR<hobby_categoryUpdateInput, hobby_categoryUncheckedUpdateInput>
    /**
     * Choose, which hobby_category to update.
     */
    where: hobby_categoryWhereUniqueInput
  }

  /**
   * hobby_category updateMany
   */
  export type hobby_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hobby_categories.
     */
    data: XOR<hobby_categoryUpdateManyMutationInput, hobby_categoryUncheckedUpdateManyInput>
    /**
     * Filter which hobby_categories to update
     */
    where?: hobby_categoryWhereInput
    /**
     * Limit how many hobby_categories to update.
     */
    limit?: number
  }

  /**
   * hobby_category upsert
   */
  export type hobby_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_category
     */
    select?: hobby_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_category
     */
    omit?: hobby_categoryOmit<ExtArgs> | null
    /**
     * The filter to search for the hobby_category to update in case it exists.
     */
    where: hobby_categoryWhereUniqueInput
    /**
     * In case the hobby_category found by the `where` argument doesn't exist, create a new hobby_category with this data.
     */
    create: XOR<hobby_categoryCreateInput, hobby_categoryUncheckedCreateInput>
    /**
     * In case the hobby_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hobby_categoryUpdateInput, hobby_categoryUncheckedUpdateInput>
  }

  /**
   * hobby_category delete
   */
  export type hobby_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_category
     */
    select?: hobby_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_category
     */
    omit?: hobby_categoryOmit<ExtArgs> | null
    /**
     * Filter which hobby_category to delete.
     */
    where: hobby_categoryWhereUniqueInput
  }

  /**
   * hobby_category deleteMany
   */
  export type hobby_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_categories to delete
     */
    where?: hobby_categoryWhereInput
    /**
     * Limit how many hobby_categories to delete.
     */
    limit?: number
  }

  /**
   * hobby_category without action
   */
  export type hobby_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_category
     */
    select?: hobby_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_category
     */
    omit?: hobby_categoryOmit<ExtArgs> | null
  }


  /**
   * Model hobby_comment
   */

  export type AggregateHobby_comment = {
    _count: Hobby_commentCountAggregateOutputType | null
    _avg: Hobby_commentAvgAggregateOutputType | null
    _sum: Hobby_commentSumAggregateOutputType | null
    _min: Hobby_commentMinAggregateOutputType | null
    _max: Hobby_commentMaxAggregateOutputType | null
  }

  export type Hobby_commentAvgAggregateOutputType = {
    comment_id: number | null
    post_id: number | null
    created_by: number | null
    modified_by: number | null
  }

  export type Hobby_commentSumAggregateOutputType = {
    comment_id: bigint | null
    post_id: bigint | null
    created_by: bigint | null
    modified_by: bigint | null
  }

  export type Hobby_commentMinAggregateOutputType = {
    comment_id: bigint | null
    post_id: bigint | null
    comment: string | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
    deleted_at: Date | null
  }

  export type Hobby_commentMaxAggregateOutputType = {
    comment_id: bigint | null
    post_id: bigint | null
    comment: string | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
    deleted_at: Date | null
  }

  export type Hobby_commentCountAggregateOutputType = {
    comment_id: number
    post_id: number
    comment: number
    created_at: number
    created_by: number
    modified_at: number
    modified_by: number
    deleted: number
    deleted_at: number
    _all: number
  }


  export type Hobby_commentAvgAggregateInputType = {
    comment_id?: true
    post_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_commentSumAggregateInputType = {
    comment_id?: true
    post_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_commentMinAggregateInputType = {
    comment_id?: true
    post_id?: true
    comment?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
    deleted_at?: true
  }

  export type Hobby_commentMaxAggregateInputType = {
    comment_id?: true
    post_id?: true
    comment?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
    deleted_at?: true
  }

  export type Hobby_commentCountAggregateInputType = {
    comment_id?: true
    post_id?: true
    comment?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
    deleted_at?: true
    _all?: true
  }

  export type Hobby_commentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_comment to aggregate.
     */
    where?: hobby_commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_comments to fetch.
     */
    orderBy?: hobby_commentOrderByWithRelationInput | hobby_commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hobby_commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hobby_comments
    **/
    _count?: true | Hobby_commentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hobby_commentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hobby_commentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hobby_commentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hobby_commentMaxAggregateInputType
  }

  export type GetHobby_commentAggregateType<T extends Hobby_commentAggregateArgs> = {
        [P in keyof T & keyof AggregateHobby_comment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHobby_comment[P]>
      : GetScalarType<T[P], AggregateHobby_comment[P]>
  }




  export type hobby_commentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hobby_commentWhereInput
    orderBy?: hobby_commentOrderByWithAggregationInput | hobby_commentOrderByWithAggregationInput[]
    by: Hobby_commentScalarFieldEnum[] | Hobby_commentScalarFieldEnum
    having?: hobby_commentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hobby_commentCountAggregateInputType | true
    _avg?: Hobby_commentAvgAggregateInputType
    _sum?: Hobby_commentSumAggregateInputType
    _min?: Hobby_commentMinAggregateInputType
    _max?: Hobby_commentMaxAggregateInputType
  }

  export type Hobby_commentGroupByOutputType = {
    comment_id: bigint
    post_id: bigint
    comment: string
    created_at: Date
    created_by: bigint
    modified_at: Date
    modified_by: bigint
    deleted: boolean
    deleted_at: Date | null
    _count: Hobby_commentCountAggregateOutputType | null
    _avg: Hobby_commentAvgAggregateOutputType | null
    _sum: Hobby_commentSumAggregateOutputType | null
    _min: Hobby_commentMinAggregateOutputType | null
    _max: Hobby_commentMaxAggregateOutputType | null
  }

  type GetHobby_commentGroupByPayload<T extends hobby_commentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Hobby_commentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hobby_commentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hobby_commentGroupByOutputType[P]>
            : GetScalarType<T[P], Hobby_commentGroupByOutputType[P]>
        }
      >
    >


  export type hobby_commentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    post_id?: boolean
    comment?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["hobby_comment"]>



  export type hobby_commentSelectScalar = {
    comment_id?: boolean
    post_id?: boolean
    comment?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
    deleted_at?: boolean
  }

  export type hobby_commentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"comment_id" | "post_id" | "comment" | "created_at" | "created_by" | "modified_at" | "modified_by" | "deleted" | "deleted_at", ExtArgs["result"]["hobby_comment"]>

  export type $hobby_commentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hobby_comment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      comment_id: bigint
      post_id: bigint
      comment: string
      created_at: Date
      created_by: bigint
      modified_at: Date
      modified_by: bigint
      deleted: boolean
      deleted_at: Date | null
    }, ExtArgs["result"]["hobby_comment"]>
    composites: {}
  }

  type hobby_commentGetPayload<S extends boolean | null | undefined | hobby_commentDefaultArgs> = $Result.GetResult<Prisma.$hobby_commentPayload, S>

  type hobby_commentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hobby_commentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Hobby_commentCountAggregateInputType | true
    }

  export interface hobby_commentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hobby_comment'], meta: { name: 'hobby_comment' } }
    /**
     * Find zero or one Hobby_comment that matches the filter.
     * @param {hobby_commentFindUniqueArgs} args - Arguments to find a Hobby_comment
     * @example
     * // Get one Hobby_comment
     * const hobby_comment = await prisma.hobby_comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hobby_commentFindUniqueArgs>(args: SelectSubset<T, hobby_commentFindUniqueArgs<ExtArgs>>): Prisma__hobby_commentClient<$Result.GetResult<Prisma.$hobby_commentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hobby_comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hobby_commentFindUniqueOrThrowArgs} args - Arguments to find a Hobby_comment
     * @example
     * // Get one Hobby_comment
     * const hobby_comment = await prisma.hobby_comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hobby_commentFindUniqueOrThrowArgs>(args: SelectSubset<T, hobby_commentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hobby_commentClient<$Result.GetResult<Prisma.$hobby_commentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_commentFindFirstArgs} args - Arguments to find a Hobby_comment
     * @example
     * // Get one Hobby_comment
     * const hobby_comment = await prisma.hobby_comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hobby_commentFindFirstArgs>(args?: SelectSubset<T, hobby_commentFindFirstArgs<ExtArgs>>): Prisma__hobby_commentClient<$Result.GetResult<Prisma.$hobby_commentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_commentFindFirstOrThrowArgs} args - Arguments to find a Hobby_comment
     * @example
     * // Get one Hobby_comment
     * const hobby_comment = await prisma.hobby_comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hobby_commentFindFirstOrThrowArgs>(args?: SelectSubset<T, hobby_commentFindFirstOrThrowArgs<ExtArgs>>): Prisma__hobby_commentClient<$Result.GetResult<Prisma.$hobby_commentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hobby_comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_commentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hobby_comments
     * const hobby_comments = await prisma.hobby_comment.findMany()
     * 
     * // Get first 10 Hobby_comments
     * const hobby_comments = await prisma.hobby_comment.findMany({ take: 10 })
     * 
     * // Only select the `comment_id`
     * const hobby_commentWithComment_idOnly = await prisma.hobby_comment.findMany({ select: { comment_id: true } })
     * 
     */
    findMany<T extends hobby_commentFindManyArgs>(args?: SelectSubset<T, hobby_commentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hobby_commentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hobby_comment.
     * @param {hobby_commentCreateArgs} args - Arguments to create a Hobby_comment.
     * @example
     * // Create one Hobby_comment
     * const Hobby_comment = await prisma.hobby_comment.create({
     *   data: {
     *     // ... data to create a Hobby_comment
     *   }
     * })
     * 
     */
    create<T extends hobby_commentCreateArgs>(args: SelectSubset<T, hobby_commentCreateArgs<ExtArgs>>): Prisma__hobby_commentClient<$Result.GetResult<Prisma.$hobby_commentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hobby_comments.
     * @param {hobby_commentCreateManyArgs} args - Arguments to create many Hobby_comments.
     * @example
     * // Create many Hobby_comments
     * const hobby_comment = await prisma.hobby_comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hobby_commentCreateManyArgs>(args?: SelectSubset<T, hobby_commentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hobby_comment.
     * @param {hobby_commentDeleteArgs} args - Arguments to delete one Hobby_comment.
     * @example
     * // Delete one Hobby_comment
     * const Hobby_comment = await prisma.hobby_comment.delete({
     *   where: {
     *     // ... filter to delete one Hobby_comment
     *   }
     * })
     * 
     */
    delete<T extends hobby_commentDeleteArgs>(args: SelectSubset<T, hobby_commentDeleteArgs<ExtArgs>>): Prisma__hobby_commentClient<$Result.GetResult<Prisma.$hobby_commentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hobby_comment.
     * @param {hobby_commentUpdateArgs} args - Arguments to update one Hobby_comment.
     * @example
     * // Update one Hobby_comment
     * const hobby_comment = await prisma.hobby_comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hobby_commentUpdateArgs>(args: SelectSubset<T, hobby_commentUpdateArgs<ExtArgs>>): Prisma__hobby_commentClient<$Result.GetResult<Prisma.$hobby_commentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hobby_comments.
     * @param {hobby_commentDeleteManyArgs} args - Arguments to filter Hobby_comments to delete.
     * @example
     * // Delete a few Hobby_comments
     * const { count } = await prisma.hobby_comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hobby_commentDeleteManyArgs>(args?: SelectSubset<T, hobby_commentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hobby_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_commentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hobby_comments
     * const hobby_comment = await prisma.hobby_comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hobby_commentUpdateManyArgs>(args: SelectSubset<T, hobby_commentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hobby_comment.
     * @param {hobby_commentUpsertArgs} args - Arguments to update or create a Hobby_comment.
     * @example
     * // Update or create a Hobby_comment
     * const hobby_comment = await prisma.hobby_comment.upsert({
     *   create: {
     *     // ... data to create a Hobby_comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hobby_comment we want to update
     *   }
     * })
     */
    upsert<T extends hobby_commentUpsertArgs>(args: SelectSubset<T, hobby_commentUpsertArgs<ExtArgs>>): Prisma__hobby_commentClient<$Result.GetResult<Prisma.$hobby_commentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hobby_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_commentCountArgs} args - Arguments to filter Hobby_comments to count.
     * @example
     * // Count the number of Hobby_comments
     * const count = await prisma.hobby_comment.count({
     *   where: {
     *     // ... the filter for the Hobby_comments we want to count
     *   }
     * })
    **/
    count<T extends hobby_commentCountArgs>(
      args?: Subset<T, hobby_commentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hobby_commentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hobby_comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hobby_commentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hobby_commentAggregateArgs>(args: Subset<T, Hobby_commentAggregateArgs>): Prisma.PrismaPromise<GetHobby_commentAggregateType<T>>

    /**
     * Group by Hobby_comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_commentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hobby_commentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hobby_commentGroupByArgs['orderBy'] }
        : { orderBy?: hobby_commentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hobby_commentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHobby_commentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hobby_comment model
   */
  readonly fields: hobby_commentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hobby_comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hobby_commentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hobby_comment model
   */
  interface hobby_commentFieldRefs {
    readonly comment_id: FieldRef<"hobby_comment", 'BigInt'>
    readonly post_id: FieldRef<"hobby_comment", 'BigInt'>
    readonly comment: FieldRef<"hobby_comment", 'String'>
    readonly created_at: FieldRef<"hobby_comment", 'DateTime'>
    readonly created_by: FieldRef<"hobby_comment", 'BigInt'>
    readonly modified_at: FieldRef<"hobby_comment", 'DateTime'>
    readonly modified_by: FieldRef<"hobby_comment", 'BigInt'>
    readonly deleted: FieldRef<"hobby_comment", 'Boolean'>
    readonly deleted_at: FieldRef<"hobby_comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * hobby_comment findUnique
   */
  export type hobby_commentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_comment
     */
    select?: hobby_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_comment
     */
    omit?: hobby_commentOmit<ExtArgs> | null
    /**
     * Filter, which hobby_comment to fetch.
     */
    where: hobby_commentWhereUniqueInput
  }

  /**
   * hobby_comment findUniqueOrThrow
   */
  export type hobby_commentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_comment
     */
    select?: hobby_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_comment
     */
    omit?: hobby_commentOmit<ExtArgs> | null
    /**
     * Filter, which hobby_comment to fetch.
     */
    where: hobby_commentWhereUniqueInput
  }

  /**
   * hobby_comment findFirst
   */
  export type hobby_commentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_comment
     */
    select?: hobby_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_comment
     */
    omit?: hobby_commentOmit<ExtArgs> | null
    /**
     * Filter, which hobby_comment to fetch.
     */
    where?: hobby_commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_comments to fetch.
     */
    orderBy?: hobby_commentOrderByWithRelationInput | hobby_commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_comments.
     */
    cursor?: hobby_commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_comments.
     */
    distinct?: Hobby_commentScalarFieldEnum | Hobby_commentScalarFieldEnum[]
  }

  /**
   * hobby_comment findFirstOrThrow
   */
  export type hobby_commentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_comment
     */
    select?: hobby_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_comment
     */
    omit?: hobby_commentOmit<ExtArgs> | null
    /**
     * Filter, which hobby_comment to fetch.
     */
    where?: hobby_commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_comments to fetch.
     */
    orderBy?: hobby_commentOrderByWithRelationInput | hobby_commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_comments.
     */
    cursor?: hobby_commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_comments.
     */
    distinct?: Hobby_commentScalarFieldEnum | Hobby_commentScalarFieldEnum[]
  }

  /**
   * hobby_comment findMany
   */
  export type hobby_commentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_comment
     */
    select?: hobby_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_comment
     */
    omit?: hobby_commentOmit<ExtArgs> | null
    /**
     * Filter, which hobby_comments to fetch.
     */
    where?: hobby_commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_comments to fetch.
     */
    orderBy?: hobby_commentOrderByWithRelationInput | hobby_commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hobby_comments.
     */
    cursor?: hobby_commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_comments.
     */
    skip?: number
    distinct?: Hobby_commentScalarFieldEnum | Hobby_commentScalarFieldEnum[]
  }

  /**
   * hobby_comment create
   */
  export type hobby_commentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_comment
     */
    select?: hobby_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_comment
     */
    omit?: hobby_commentOmit<ExtArgs> | null
    /**
     * The data needed to create a hobby_comment.
     */
    data: XOR<hobby_commentCreateInput, hobby_commentUncheckedCreateInput>
  }

  /**
   * hobby_comment createMany
   */
  export type hobby_commentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hobby_comments.
     */
    data: hobby_commentCreateManyInput | hobby_commentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hobby_comment update
   */
  export type hobby_commentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_comment
     */
    select?: hobby_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_comment
     */
    omit?: hobby_commentOmit<ExtArgs> | null
    /**
     * The data needed to update a hobby_comment.
     */
    data: XOR<hobby_commentUpdateInput, hobby_commentUncheckedUpdateInput>
    /**
     * Choose, which hobby_comment to update.
     */
    where: hobby_commentWhereUniqueInput
  }

  /**
   * hobby_comment updateMany
   */
  export type hobby_commentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hobby_comments.
     */
    data: XOR<hobby_commentUpdateManyMutationInput, hobby_commentUncheckedUpdateManyInput>
    /**
     * Filter which hobby_comments to update
     */
    where?: hobby_commentWhereInput
    /**
     * Limit how many hobby_comments to update.
     */
    limit?: number
  }

  /**
   * hobby_comment upsert
   */
  export type hobby_commentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_comment
     */
    select?: hobby_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_comment
     */
    omit?: hobby_commentOmit<ExtArgs> | null
    /**
     * The filter to search for the hobby_comment to update in case it exists.
     */
    where: hobby_commentWhereUniqueInput
    /**
     * In case the hobby_comment found by the `where` argument doesn't exist, create a new hobby_comment with this data.
     */
    create: XOR<hobby_commentCreateInput, hobby_commentUncheckedCreateInput>
    /**
     * In case the hobby_comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hobby_commentUpdateInput, hobby_commentUncheckedUpdateInput>
  }

  /**
   * hobby_comment delete
   */
  export type hobby_commentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_comment
     */
    select?: hobby_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_comment
     */
    omit?: hobby_commentOmit<ExtArgs> | null
    /**
     * Filter which hobby_comment to delete.
     */
    where: hobby_commentWhereUniqueInput
  }

  /**
   * hobby_comment deleteMany
   */
  export type hobby_commentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_comments to delete
     */
    where?: hobby_commentWhereInput
    /**
     * Limit how many hobby_comments to delete.
     */
    limit?: number
  }

  /**
   * hobby_comment without action
   */
  export type hobby_commentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_comment
     */
    select?: hobby_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_comment
     */
    omit?: hobby_commentOmit<ExtArgs> | null
  }


  /**
   * Model hobby_group
   */

  export type AggregateHobby_group = {
    _count: Hobby_groupCountAggregateOutputType | null
    _avg: Hobby_groupAvgAggregateOutputType | null
    _sum: Hobby_groupSumAggregateOutputType | null
    _min: Hobby_groupMinAggregateOutputType | null
    _max: Hobby_groupMaxAggregateOutputType | null
  }

  export type Hobby_groupAvgAggregateOutputType = {
    hobby_group_id: number | null
    user_id: number | null
    created_by: number | null
    modified_by: number | null
  }

  export type Hobby_groupSumAggregateOutputType = {
    hobby_group_id: bigint | null
    user_id: bigint | null
    created_by: bigint | null
    modified_by: bigint | null
  }

  export type Hobby_groupMinAggregateOutputType = {
    hobby_group_id: bigint | null
    user_id: bigint | null
    hobby_group_title: string | null
    deleted: boolean | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted_at: Date | null
  }

  export type Hobby_groupMaxAggregateOutputType = {
    hobby_group_id: bigint | null
    user_id: bigint | null
    hobby_group_title: string | null
    deleted: boolean | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted_at: Date | null
  }

  export type Hobby_groupCountAggregateOutputType = {
    hobby_group_id: number
    user_id: number
    hobby_group_title: number
    deleted: number
    created_at: number
    created_by: number
    modified_at: number
    modified_by: number
    deleted_at: number
    _all: number
  }


  export type Hobby_groupAvgAggregateInputType = {
    hobby_group_id?: true
    user_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_groupSumAggregateInputType = {
    hobby_group_id?: true
    user_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_groupMinAggregateInputType = {
    hobby_group_id?: true
    user_id?: true
    hobby_group_title?: true
    deleted?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted_at?: true
  }

  export type Hobby_groupMaxAggregateInputType = {
    hobby_group_id?: true
    user_id?: true
    hobby_group_title?: true
    deleted?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted_at?: true
  }

  export type Hobby_groupCountAggregateInputType = {
    hobby_group_id?: true
    user_id?: true
    hobby_group_title?: true
    deleted?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted_at?: true
    _all?: true
  }

  export type Hobby_groupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_group to aggregate.
     */
    where?: hobby_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_groups to fetch.
     */
    orderBy?: hobby_groupOrderByWithRelationInput | hobby_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hobby_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hobby_groups
    **/
    _count?: true | Hobby_groupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hobby_groupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hobby_groupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hobby_groupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hobby_groupMaxAggregateInputType
  }

  export type GetHobby_groupAggregateType<T extends Hobby_groupAggregateArgs> = {
        [P in keyof T & keyof AggregateHobby_group]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHobby_group[P]>
      : GetScalarType<T[P], AggregateHobby_group[P]>
  }




  export type hobby_groupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hobby_groupWhereInput
    orderBy?: hobby_groupOrderByWithAggregationInput | hobby_groupOrderByWithAggregationInput[]
    by: Hobby_groupScalarFieldEnum[] | Hobby_groupScalarFieldEnum
    having?: hobby_groupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hobby_groupCountAggregateInputType | true
    _avg?: Hobby_groupAvgAggregateInputType
    _sum?: Hobby_groupSumAggregateInputType
    _min?: Hobby_groupMinAggregateInputType
    _max?: Hobby_groupMaxAggregateInputType
  }

  export type Hobby_groupGroupByOutputType = {
    hobby_group_id: bigint
    user_id: bigint
    hobby_group_title: string
    deleted: boolean
    created_at: Date
    created_by: bigint
    modified_at: Date
    modified_by: bigint
    deleted_at: Date | null
    _count: Hobby_groupCountAggregateOutputType | null
    _avg: Hobby_groupAvgAggregateOutputType | null
    _sum: Hobby_groupSumAggregateOutputType | null
    _min: Hobby_groupMinAggregateOutputType | null
    _max: Hobby_groupMaxAggregateOutputType | null
  }

  type GetHobby_groupGroupByPayload<T extends hobby_groupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Hobby_groupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hobby_groupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hobby_groupGroupByOutputType[P]>
            : GetScalarType<T[P], Hobby_groupGroupByOutputType[P]>
        }
      >
    >


  export type hobby_groupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hobby_group_id?: boolean
    user_id?: boolean
    hobby_group_title?: boolean
    deleted?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["hobby_group"]>



  export type hobby_groupSelectScalar = {
    hobby_group_id?: boolean
    user_id?: boolean
    hobby_group_title?: boolean
    deleted?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted_at?: boolean
  }

  export type hobby_groupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hobby_group_id" | "user_id" | "hobby_group_title" | "deleted" | "created_at" | "created_by" | "modified_at" | "modified_by" | "deleted_at", ExtArgs["result"]["hobby_group"]>

  export type $hobby_groupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hobby_group"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      hobby_group_id: bigint
      user_id: bigint
      hobby_group_title: string
      deleted: boolean
      created_at: Date
      created_by: bigint
      modified_at: Date
      modified_by: bigint
      deleted_at: Date | null
    }, ExtArgs["result"]["hobby_group"]>
    composites: {}
  }

  type hobby_groupGetPayload<S extends boolean | null | undefined | hobby_groupDefaultArgs> = $Result.GetResult<Prisma.$hobby_groupPayload, S>

  type hobby_groupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hobby_groupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Hobby_groupCountAggregateInputType | true
    }

  export interface hobby_groupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hobby_group'], meta: { name: 'hobby_group' } }
    /**
     * Find zero or one Hobby_group that matches the filter.
     * @param {hobby_groupFindUniqueArgs} args - Arguments to find a Hobby_group
     * @example
     * // Get one Hobby_group
     * const hobby_group = await prisma.hobby_group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hobby_groupFindUniqueArgs>(args: SelectSubset<T, hobby_groupFindUniqueArgs<ExtArgs>>): Prisma__hobby_groupClient<$Result.GetResult<Prisma.$hobby_groupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hobby_group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hobby_groupFindUniqueOrThrowArgs} args - Arguments to find a Hobby_group
     * @example
     * // Get one Hobby_group
     * const hobby_group = await prisma.hobby_group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hobby_groupFindUniqueOrThrowArgs>(args: SelectSubset<T, hobby_groupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hobby_groupClient<$Result.GetResult<Prisma.$hobby_groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_groupFindFirstArgs} args - Arguments to find a Hobby_group
     * @example
     * // Get one Hobby_group
     * const hobby_group = await prisma.hobby_group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hobby_groupFindFirstArgs>(args?: SelectSubset<T, hobby_groupFindFirstArgs<ExtArgs>>): Prisma__hobby_groupClient<$Result.GetResult<Prisma.$hobby_groupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_groupFindFirstOrThrowArgs} args - Arguments to find a Hobby_group
     * @example
     * // Get one Hobby_group
     * const hobby_group = await prisma.hobby_group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hobby_groupFindFirstOrThrowArgs>(args?: SelectSubset<T, hobby_groupFindFirstOrThrowArgs<ExtArgs>>): Prisma__hobby_groupClient<$Result.GetResult<Prisma.$hobby_groupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hobby_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_groupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hobby_groups
     * const hobby_groups = await prisma.hobby_group.findMany()
     * 
     * // Get first 10 Hobby_groups
     * const hobby_groups = await prisma.hobby_group.findMany({ take: 10 })
     * 
     * // Only select the `hobby_group_id`
     * const hobby_groupWithHobby_group_idOnly = await prisma.hobby_group.findMany({ select: { hobby_group_id: true } })
     * 
     */
    findMany<T extends hobby_groupFindManyArgs>(args?: SelectSubset<T, hobby_groupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hobby_groupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hobby_group.
     * @param {hobby_groupCreateArgs} args - Arguments to create a Hobby_group.
     * @example
     * // Create one Hobby_group
     * const Hobby_group = await prisma.hobby_group.create({
     *   data: {
     *     // ... data to create a Hobby_group
     *   }
     * })
     * 
     */
    create<T extends hobby_groupCreateArgs>(args: SelectSubset<T, hobby_groupCreateArgs<ExtArgs>>): Prisma__hobby_groupClient<$Result.GetResult<Prisma.$hobby_groupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hobby_groups.
     * @param {hobby_groupCreateManyArgs} args - Arguments to create many Hobby_groups.
     * @example
     * // Create many Hobby_groups
     * const hobby_group = await prisma.hobby_group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hobby_groupCreateManyArgs>(args?: SelectSubset<T, hobby_groupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hobby_group.
     * @param {hobby_groupDeleteArgs} args - Arguments to delete one Hobby_group.
     * @example
     * // Delete one Hobby_group
     * const Hobby_group = await prisma.hobby_group.delete({
     *   where: {
     *     // ... filter to delete one Hobby_group
     *   }
     * })
     * 
     */
    delete<T extends hobby_groupDeleteArgs>(args: SelectSubset<T, hobby_groupDeleteArgs<ExtArgs>>): Prisma__hobby_groupClient<$Result.GetResult<Prisma.$hobby_groupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hobby_group.
     * @param {hobby_groupUpdateArgs} args - Arguments to update one Hobby_group.
     * @example
     * // Update one Hobby_group
     * const hobby_group = await prisma.hobby_group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hobby_groupUpdateArgs>(args: SelectSubset<T, hobby_groupUpdateArgs<ExtArgs>>): Prisma__hobby_groupClient<$Result.GetResult<Prisma.$hobby_groupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hobby_groups.
     * @param {hobby_groupDeleteManyArgs} args - Arguments to filter Hobby_groups to delete.
     * @example
     * // Delete a few Hobby_groups
     * const { count } = await prisma.hobby_group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hobby_groupDeleteManyArgs>(args?: SelectSubset<T, hobby_groupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hobby_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_groupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hobby_groups
     * const hobby_group = await prisma.hobby_group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hobby_groupUpdateManyArgs>(args: SelectSubset<T, hobby_groupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hobby_group.
     * @param {hobby_groupUpsertArgs} args - Arguments to update or create a Hobby_group.
     * @example
     * // Update or create a Hobby_group
     * const hobby_group = await prisma.hobby_group.upsert({
     *   create: {
     *     // ... data to create a Hobby_group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hobby_group we want to update
     *   }
     * })
     */
    upsert<T extends hobby_groupUpsertArgs>(args: SelectSubset<T, hobby_groupUpsertArgs<ExtArgs>>): Prisma__hobby_groupClient<$Result.GetResult<Prisma.$hobby_groupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hobby_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_groupCountArgs} args - Arguments to filter Hobby_groups to count.
     * @example
     * // Count the number of Hobby_groups
     * const count = await prisma.hobby_group.count({
     *   where: {
     *     // ... the filter for the Hobby_groups we want to count
     *   }
     * })
    **/
    count<T extends hobby_groupCountArgs>(
      args?: Subset<T, hobby_groupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hobby_groupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hobby_group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hobby_groupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hobby_groupAggregateArgs>(args: Subset<T, Hobby_groupAggregateArgs>): Prisma.PrismaPromise<GetHobby_groupAggregateType<T>>

    /**
     * Group by Hobby_group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_groupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hobby_groupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hobby_groupGroupByArgs['orderBy'] }
        : { orderBy?: hobby_groupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hobby_groupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHobby_groupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hobby_group model
   */
  readonly fields: hobby_groupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hobby_group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hobby_groupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hobby_group model
   */
  interface hobby_groupFieldRefs {
    readonly hobby_group_id: FieldRef<"hobby_group", 'BigInt'>
    readonly user_id: FieldRef<"hobby_group", 'BigInt'>
    readonly hobby_group_title: FieldRef<"hobby_group", 'String'>
    readonly deleted: FieldRef<"hobby_group", 'Boolean'>
    readonly created_at: FieldRef<"hobby_group", 'DateTime'>
    readonly created_by: FieldRef<"hobby_group", 'BigInt'>
    readonly modified_at: FieldRef<"hobby_group", 'DateTime'>
    readonly modified_by: FieldRef<"hobby_group", 'BigInt'>
    readonly deleted_at: FieldRef<"hobby_group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * hobby_group findUnique
   */
  export type hobby_groupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_group
     */
    select?: hobby_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_group
     */
    omit?: hobby_groupOmit<ExtArgs> | null
    /**
     * Filter, which hobby_group to fetch.
     */
    where: hobby_groupWhereUniqueInput
  }

  /**
   * hobby_group findUniqueOrThrow
   */
  export type hobby_groupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_group
     */
    select?: hobby_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_group
     */
    omit?: hobby_groupOmit<ExtArgs> | null
    /**
     * Filter, which hobby_group to fetch.
     */
    where: hobby_groupWhereUniqueInput
  }

  /**
   * hobby_group findFirst
   */
  export type hobby_groupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_group
     */
    select?: hobby_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_group
     */
    omit?: hobby_groupOmit<ExtArgs> | null
    /**
     * Filter, which hobby_group to fetch.
     */
    where?: hobby_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_groups to fetch.
     */
    orderBy?: hobby_groupOrderByWithRelationInput | hobby_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_groups.
     */
    cursor?: hobby_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_groups.
     */
    distinct?: Hobby_groupScalarFieldEnum | Hobby_groupScalarFieldEnum[]
  }

  /**
   * hobby_group findFirstOrThrow
   */
  export type hobby_groupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_group
     */
    select?: hobby_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_group
     */
    omit?: hobby_groupOmit<ExtArgs> | null
    /**
     * Filter, which hobby_group to fetch.
     */
    where?: hobby_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_groups to fetch.
     */
    orderBy?: hobby_groupOrderByWithRelationInput | hobby_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_groups.
     */
    cursor?: hobby_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_groups.
     */
    distinct?: Hobby_groupScalarFieldEnum | Hobby_groupScalarFieldEnum[]
  }

  /**
   * hobby_group findMany
   */
  export type hobby_groupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_group
     */
    select?: hobby_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_group
     */
    omit?: hobby_groupOmit<ExtArgs> | null
    /**
     * Filter, which hobby_groups to fetch.
     */
    where?: hobby_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_groups to fetch.
     */
    orderBy?: hobby_groupOrderByWithRelationInput | hobby_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hobby_groups.
     */
    cursor?: hobby_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_groups.
     */
    skip?: number
    distinct?: Hobby_groupScalarFieldEnum | Hobby_groupScalarFieldEnum[]
  }

  /**
   * hobby_group create
   */
  export type hobby_groupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_group
     */
    select?: hobby_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_group
     */
    omit?: hobby_groupOmit<ExtArgs> | null
    /**
     * The data needed to create a hobby_group.
     */
    data: XOR<hobby_groupCreateInput, hobby_groupUncheckedCreateInput>
  }

  /**
   * hobby_group createMany
   */
  export type hobby_groupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hobby_groups.
     */
    data: hobby_groupCreateManyInput | hobby_groupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hobby_group update
   */
  export type hobby_groupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_group
     */
    select?: hobby_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_group
     */
    omit?: hobby_groupOmit<ExtArgs> | null
    /**
     * The data needed to update a hobby_group.
     */
    data: XOR<hobby_groupUpdateInput, hobby_groupUncheckedUpdateInput>
    /**
     * Choose, which hobby_group to update.
     */
    where: hobby_groupWhereUniqueInput
  }

  /**
   * hobby_group updateMany
   */
  export type hobby_groupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hobby_groups.
     */
    data: XOR<hobby_groupUpdateManyMutationInput, hobby_groupUncheckedUpdateManyInput>
    /**
     * Filter which hobby_groups to update
     */
    where?: hobby_groupWhereInput
    /**
     * Limit how many hobby_groups to update.
     */
    limit?: number
  }

  /**
   * hobby_group upsert
   */
  export type hobby_groupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_group
     */
    select?: hobby_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_group
     */
    omit?: hobby_groupOmit<ExtArgs> | null
    /**
     * The filter to search for the hobby_group to update in case it exists.
     */
    where: hobby_groupWhereUniqueInput
    /**
     * In case the hobby_group found by the `where` argument doesn't exist, create a new hobby_group with this data.
     */
    create: XOR<hobby_groupCreateInput, hobby_groupUncheckedCreateInput>
    /**
     * In case the hobby_group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hobby_groupUpdateInput, hobby_groupUncheckedUpdateInput>
  }

  /**
   * hobby_group delete
   */
  export type hobby_groupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_group
     */
    select?: hobby_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_group
     */
    omit?: hobby_groupOmit<ExtArgs> | null
    /**
     * Filter which hobby_group to delete.
     */
    where: hobby_groupWhereUniqueInput
  }

  /**
   * hobby_group deleteMany
   */
  export type hobby_groupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_groups to delete
     */
    where?: hobby_groupWhereInput
    /**
     * Limit how many hobby_groups to delete.
     */
    limit?: number
  }

  /**
   * hobby_group without action
   */
  export type hobby_groupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_group
     */
    select?: hobby_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_group
     */
    omit?: hobby_groupOmit<ExtArgs> | null
  }


  /**
   * Model hobby_like
   */

  export type AggregateHobby_like = {
    _count: Hobby_likeCountAggregateOutputType | null
    _avg: Hobby_likeAvgAggregateOutputType | null
    _sum: Hobby_likeSumAggregateOutputType | null
    _min: Hobby_likeMinAggregateOutputType | null
    _max: Hobby_likeMaxAggregateOutputType | null
  }

  export type Hobby_likeAvgAggregateOutputType = {
    hobby_like_id: number | null
    user_id: number | null
    hobby_post_id: number | null
    created_by: number | null
    modified_by: number | null
  }

  export type Hobby_likeSumAggregateOutputType = {
    hobby_like_id: bigint | null
    user_id: bigint | null
    hobby_post_id: bigint | null
    created_by: bigint | null
    modified_by: bigint | null
  }

  export type Hobby_likeMinAggregateOutputType = {
    hobby_like_id: bigint | null
    user_id: bigint | null
    hobby_post_id: bigint | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
  }

  export type Hobby_likeMaxAggregateOutputType = {
    hobby_like_id: bigint | null
    user_id: bigint | null
    hobby_post_id: bigint | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
  }

  export type Hobby_likeCountAggregateOutputType = {
    hobby_like_id: number
    user_id: number
    hobby_post_id: number
    created_at: number
    created_by: number
    modified_at: number
    modified_by: number
    deleted: number
    _all: number
  }


  export type Hobby_likeAvgAggregateInputType = {
    hobby_like_id?: true
    user_id?: true
    hobby_post_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_likeSumAggregateInputType = {
    hobby_like_id?: true
    user_id?: true
    hobby_post_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_likeMinAggregateInputType = {
    hobby_like_id?: true
    user_id?: true
    hobby_post_id?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
  }

  export type Hobby_likeMaxAggregateInputType = {
    hobby_like_id?: true
    user_id?: true
    hobby_post_id?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
  }

  export type Hobby_likeCountAggregateInputType = {
    hobby_like_id?: true
    user_id?: true
    hobby_post_id?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
    _all?: true
  }

  export type Hobby_likeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_like to aggregate.
     */
    where?: hobby_likeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_likes to fetch.
     */
    orderBy?: hobby_likeOrderByWithRelationInput | hobby_likeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hobby_likeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hobby_likes
    **/
    _count?: true | Hobby_likeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hobby_likeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hobby_likeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hobby_likeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hobby_likeMaxAggregateInputType
  }

  export type GetHobby_likeAggregateType<T extends Hobby_likeAggregateArgs> = {
        [P in keyof T & keyof AggregateHobby_like]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHobby_like[P]>
      : GetScalarType<T[P], AggregateHobby_like[P]>
  }




  export type hobby_likeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hobby_likeWhereInput
    orderBy?: hobby_likeOrderByWithAggregationInput | hobby_likeOrderByWithAggregationInput[]
    by: Hobby_likeScalarFieldEnum[] | Hobby_likeScalarFieldEnum
    having?: hobby_likeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hobby_likeCountAggregateInputType | true
    _avg?: Hobby_likeAvgAggregateInputType
    _sum?: Hobby_likeSumAggregateInputType
    _min?: Hobby_likeMinAggregateInputType
    _max?: Hobby_likeMaxAggregateInputType
  }

  export type Hobby_likeGroupByOutputType = {
    hobby_like_id: bigint
    user_id: bigint
    hobby_post_id: bigint
    created_at: Date
    created_by: bigint
    modified_at: Date
    modified_by: bigint
    deleted: boolean
    _count: Hobby_likeCountAggregateOutputType | null
    _avg: Hobby_likeAvgAggregateOutputType | null
    _sum: Hobby_likeSumAggregateOutputType | null
    _min: Hobby_likeMinAggregateOutputType | null
    _max: Hobby_likeMaxAggregateOutputType | null
  }

  type GetHobby_likeGroupByPayload<T extends hobby_likeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Hobby_likeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hobby_likeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hobby_likeGroupByOutputType[P]>
            : GetScalarType<T[P], Hobby_likeGroupByOutputType[P]>
        }
      >
    >


  export type hobby_likeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hobby_like_id?: boolean
    user_id?: boolean
    hobby_post_id?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["hobby_like"]>



  export type hobby_likeSelectScalar = {
    hobby_like_id?: boolean
    user_id?: boolean
    hobby_post_id?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
  }

  export type hobby_likeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hobby_like_id" | "user_id" | "hobby_post_id" | "created_at" | "created_by" | "modified_at" | "modified_by" | "deleted", ExtArgs["result"]["hobby_like"]>

  export type $hobby_likePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hobby_like"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      hobby_like_id: bigint
      user_id: bigint
      hobby_post_id: bigint
      created_at: Date
      created_by: bigint
      modified_at: Date
      modified_by: bigint
      deleted: boolean
    }, ExtArgs["result"]["hobby_like"]>
    composites: {}
  }

  type hobby_likeGetPayload<S extends boolean | null | undefined | hobby_likeDefaultArgs> = $Result.GetResult<Prisma.$hobby_likePayload, S>

  type hobby_likeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hobby_likeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Hobby_likeCountAggregateInputType | true
    }

  export interface hobby_likeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hobby_like'], meta: { name: 'hobby_like' } }
    /**
     * Find zero or one Hobby_like that matches the filter.
     * @param {hobby_likeFindUniqueArgs} args - Arguments to find a Hobby_like
     * @example
     * // Get one Hobby_like
     * const hobby_like = await prisma.hobby_like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hobby_likeFindUniqueArgs>(args: SelectSubset<T, hobby_likeFindUniqueArgs<ExtArgs>>): Prisma__hobby_likeClient<$Result.GetResult<Prisma.$hobby_likePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hobby_like that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hobby_likeFindUniqueOrThrowArgs} args - Arguments to find a Hobby_like
     * @example
     * // Get one Hobby_like
     * const hobby_like = await prisma.hobby_like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hobby_likeFindUniqueOrThrowArgs>(args: SelectSubset<T, hobby_likeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hobby_likeClient<$Result.GetResult<Prisma.$hobby_likePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_likeFindFirstArgs} args - Arguments to find a Hobby_like
     * @example
     * // Get one Hobby_like
     * const hobby_like = await prisma.hobby_like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hobby_likeFindFirstArgs>(args?: SelectSubset<T, hobby_likeFindFirstArgs<ExtArgs>>): Prisma__hobby_likeClient<$Result.GetResult<Prisma.$hobby_likePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_likeFindFirstOrThrowArgs} args - Arguments to find a Hobby_like
     * @example
     * // Get one Hobby_like
     * const hobby_like = await prisma.hobby_like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hobby_likeFindFirstOrThrowArgs>(args?: SelectSubset<T, hobby_likeFindFirstOrThrowArgs<ExtArgs>>): Prisma__hobby_likeClient<$Result.GetResult<Prisma.$hobby_likePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hobby_likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_likeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hobby_likes
     * const hobby_likes = await prisma.hobby_like.findMany()
     * 
     * // Get first 10 Hobby_likes
     * const hobby_likes = await prisma.hobby_like.findMany({ take: 10 })
     * 
     * // Only select the `hobby_like_id`
     * const hobby_likeWithHobby_like_idOnly = await prisma.hobby_like.findMany({ select: { hobby_like_id: true } })
     * 
     */
    findMany<T extends hobby_likeFindManyArgs>(args?: SelectSubset<T, hobby_likeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hobby_likePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hobby_like.
     * @param {hobby_likeCreateArgs} args - Arguments to create a Hobby_like.
     * @example
     * // Create one Hobby_like
     * const Hobby_like = await prisma.hobby_like.create({
     *   data: {
     *     // ... data to create a Hobby_like
     *   }
     * })
     * 
     */
    create<T extends hobby_likeCreateArgs>(args: SelectSubset<T, hobby_likeCreateArgs<ExtArgs>>): Prisma__hobby_likeClient<$Result.GetResult<Prisma.$hobby_likePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hobby_likes.
     * @param {hobby_likeCreateManyArgs} args - Arguments to create many Hobby_likes.
     * @example
     * // Create many Hobby_likes
     * const hobby_like = await prisma.hobby_like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hobby_likeCreateManyArgs>(args?: SelectSubset<T, hobby_likeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hobby_like.
     * @param {hobby_likeDeleteArgs} args - Arguments to delete one Hobby_like.
     * @example
     * // Delete one Hobby_like
     * const Hobby_like = await prisma.hobby_like.delete({
     *   where: {
     *     // ... filter to delete one Hobby_like
     *   }
     * })
     * 
     */
    delete<T extends hobby_likeDeleteArgs>(args: SelectSubset<T, hobby_likeDeleteArgs<ExtArgs>>): Prisma__hobby_likeClient<$Result.GetResult<Prisma.$hobby_likePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hobby_like.
     * @param {hobby_likeUpdateArgs} args - Arguments to update one Hobby_like.
     * @example
     * // Update one Hobby_like
     * const hobby_like = await prisma.hobby_like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hobby_likeUpdateArgs>(args: SelectSubset<T, hobby_likeUpdateArgs<ExtArgs>>): Prisma__hobby_likeClient<$Result.GetResult<Prisma.$hobby_likePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hobby_likes.
     * @param {hobby_likeDeleteManyArgs} args - Arguments to filter Hobby_likes to delete.
     * @example
     * // Delete a few Hobby_likes
     * const { count } = await prisma.hobby_like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hobby_likeDeleteManyArgs>(args?: SelectSubset<T, hobby_likeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hobby_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_likeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hobby_likes
     * const hobby_like = await prisma.hobby_like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hobby_likeUpdateManyArgs>(args: SelectSubset<T, hobby_likeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hobby_like.
     * @param {hobby_likeUpsertArgs} args - Arguments to update or create a Hobby_like.
     * @example
     * // Update or create a Hobby_like
     * const hobby_like = await prisma.hobby_like.upsert({
     *   create: {
     *     // ... data to create a Hobby_like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hobby_like we want to update
     *   }
     * })
     */
    upsert<T extends hobby_likeUpsertArgs>(args: SelectSubset<T, hobby_likeUpsertArgs<ExtArgs>>): Prisma__hobby_likeClient<$Result.GetResult<Prisma.$hobby_likePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hobby_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_likeCountArgs} args - Arguments to filter Hobby_likes to count.
     * @example
     * // Count the number of Hobby_likes
     * const count = await prisma.hobby_like.count({
     *   where: {
     *     // ... the filter for the Hobby_likes we want to count
     *   }
     * })
    **/
    count<T extends hobby_likeCountArgs>(
      args?: Subset<T, hobby_likeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hobby_likeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hobby_like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hobby_likeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hobby_likeAggregateArgs>(args: Subset<T, Hobby_likeAggregateArgs>): Prisma.PrismaPromise<GetHobby_likeAggregateType<T>>

    /**
     * Group by Hobby_like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_likeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hobby_likeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hobby_likeGroupByArgs['orderBy'] }
        : { orderBy?: hobby_likeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hobby_likeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHobby_likeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hobby_like model
   */
  readonly fields: hobby_likeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hobby_like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hobby_likeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hobby_like model
   */
  interface hobby_likeFieldRefs {
    readonly hobby_like_id: FieldRef<"hobby_like", 'BigInt'>
    readonly user_id: FieldRef<"hobby_like", 'BigInt'>
    readonly hobby_post_id: FieldRef<"hobby_like", 'BigInt'>
    readonly created_at: FieldRef<"hobby_like", 'DateTime'>
    readonly created_by: FieldRef<"hobby_like", 'BigInt'>
    readonly modified_at: FieldRef<"hobby_like", 'DateTime'>
    readonly modified_by: FieldRef<"hobby_like", 'BigInt'>
    readonly deleted: FieldRef<"hobby_like", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * hobby_like findUnique
   */
  export type hobby_likeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_like
     */
    select?: hobby_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_like
     */
    omit?: hobby_likeOmit<ExtArgs> | null
    /**
     * Filter, which hobby_like to fetch.
     */
    where: hobby_likeWhereUniqueInput
  }

  /**
   * hobby_like findUniqueOrThrow
   */
  export type hobby_likeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_like
     */
    select?: hobby_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_like
     */
    omit?: hobby_likeOmit<ExtArgs> | null
    /**
     * Filter, which hobby_like to fetch.
     */
    where: hobby_likeWhereUniqueInput
  }

  /**
   * hobby_like findFirst
   */
  export type hobby_likeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_like
     */
    select?: hobby_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_like
     */
    omit?: hobby_likeOmit<ExtArgs> | null
    /**
     * Filter, which hobby_like to fetch.
     */
    where?: hobby_likeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_likes to fetch.
     */
    orderBy?: hobby_likeOrderByWithRelationInput | hobby_likeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_likes.
     */
    cursor?: hobby_likeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_likes.
     */
    distinct?: Hobby_likeScalarFieldEnum | Hobby_likeScalarFieldEnum[]
  }

  /**
   * hobby_like findFirstOrThrow
   */
  export type hobby_likeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_like
     */
    select?: hobby_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_like
     */
    omit?: hobby_likeOmit<ExtArgs> | null
    /**
     * Filter, which hobby_like to fetch.
     */
    where?: hobby_likeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_likes to fetch.
     */
    orderBy?: hobby_likeOrderByWithRelationInput | hobby_likeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_likes.
     */
    cursor?: hobby_likeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_likes.
     */
    distinct?: Hobby_likeScalarFieldEnum | Hobby_likeScalarFieldEnum[]
  }

  /**
   * hobby_like findMany
   */
  export type hobby_likeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_like
     */
    select?: hobby_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_like
     */
    omit?: hobby_likeOmit<ExtArgs> | null
    /**
     * Filter, which hobby_likes to fetch.
     */
    where?: hobby_likeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_likes to fetch.
     */
    orderBy?: hobby_likeOrderByWithRelationInput | hobby_likeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hobby_likes.
     */
    cursor?: hobby_likeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_likes.
     */
    skip?: number
    distinct?: Hobby_likeScalarFieldEnum | Hobby_likeScalarFieldEnum[]
  }

  /**
   * hobby_like create
   */
  export type hobby_likeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_like
     */
    select?: hobby_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_like
     */
    omit?: hobby_likeOmit<ExtArgs> | null
    /**
     * The data needed to create a hobby_like.
     */
    data: XOR<hobby_likeCreateInput, hobby_likeUncheckedCreateInput>
  }

  /**
   * hobby_like createMany
   */
  export type hobby_likeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hobby_likes.
     */
    data: hobby_likeCreateManyInput | hobby_likeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hobby_like update
   */
  export type hobby_likeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_like
     */
    select?: hobby_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_like
     */
    omit?: hobby_likeOmit<ExtArgs> | null
    /**
     * The data needed to update a hobby_like.
     */
    data: XOR<hobby_likeUpdateInput, hobby_likeUncheckedUpdateInput>
    /**
     * Choose, which hobby_like to update.
     */
    where: hobby_likeWhereUniqueInput
  }

  /**
   * hobby_like updateMany
   */
  export type hobby_likeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hobby_likes.
     */
    data: XOR<hobby_likeUpdateManyMutationInput, hobby_likeUncheckedUpdateManyInput>
    /**
     * Filter which hobby_likes to update
     */
    where?: hobby_likeWhereInput
    /**
     * Limit how many hobby_likes to update.
     */
    limit?: number
  }

  /**
   * hobby_like upsert
   */
  export type hobby_likeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_like
     */
    select?: hobby_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_like
     */
    omit?: hobby_likeOmit<ExtArgs> | null
    /**
     * The filter to search for the hobby_like to update in case it exists.
     */
    where: hobby_likeWhereUniqueInput
    /**
     * In case the hobby_like found by the `where` argument doesn't exist, create a new hobby_like with this data.
     */
    create: XOR<hobby_likeCreateInput, hobby_likeUncheckedCreateInput>
    /**
     * In case the hobby_like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hobby_likeUpdateInput, hobby_likeUncheckedUpdateInput>
  }

  /**
   * hobby_like delete
   */
  export type hobby_likeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_like
     */
    select?: hobby_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_like
     */
    omit?: hobby_likeOmit<ExtArgs> | null
    /**
     * Filter which hobby_like to delete.
     */
    where: hobby_likeWhereUniqueInput
  }

  /**
   * hobby_like deleteMany
   */
  export type hobby_likeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_likes to delete
     */
    where?: hobby_likeWhereInput
    /**
     * Limit how many hobby_likes to delete.
     */
    limit?: number
  }

  /**
   * hobby_like without action
   */
  export type hobby_likeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_like
     */
    select?: hobby_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_like
     */
    omit?: hobby_likeOmit<ExtArgs> | null
  }


  /**
   * Model hobby_photo
   */

  export type AggregateHobby_photo = {
    _count: Hobby_photoCountAggregateOutputType | null
    _avg: Hobby_photoAvgAggregateOutputType | null
    _sum: Hobby_photoSumAggregateOutputType | null
    _min: Hobby_photoMinAggregateOutputType | null
    _max: Hobby_photoMaxAggregateOutputType | null
  }

  export type Hobby_photoAvgAggregateOutputType = {
    hobby_photo_id: number | null
    hobby_post_id: number | null
    created_by: number | null
    modified_by: number | null
  }

  export type Hobby_photoSumAggregateOutputType = {
    hobby_photo_id: bigint | null
    hobby_post_id: bigint | null
    created_by: bigint | null
    modified_by: bigint | null
  }

  export type Hobby_photoMinAggregateOutputType = {
    hobby_photo_id: bigint | null
    hobby_post_id: bigint | null
    hobby_photo_path: string | null
    deleted: boolean | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
  }

  export type Hobby_photoMaxAggregateOutputType = {
    hobby_photo_id: bigint | null
    hobby_post_id: bigint | null
    hobby_photo_path: string | null
    deleted: boolean | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
  }

  export type Hobby_photoCountAggregateOutputType = {
    hobby_photo_id: number
    hobby_post_id: number
    hobby_photo_path: number
    deleted: number
    created_at: number
    created_by: number
    modified_at: number
    modified_by: number
    _all: number
  }


  export type Hobby_photoAvgAggregateInputType = {
    hobby_photo_id?: true
    hobby_post_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_photoSumAggregateInputType = {
    hobby_photo_id?: true
    hobby_post_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_photoMinAggregateInputType = {
    hobby_photo_id?: true
    hobby_post_id?: true
    hobby_photo_path?: true
    deleted?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
  }

  export type Hobby_photoMaxAggregateInputType = {
    hobby_photo_id?: true
    hobby_post_id?: true
    hobby_photo_path?: true
    deleted?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
  }

  export type Hobby_photoCountAggregateInputType = {
    hobby_photo_id?: true
    hobby_post_id?: true
    hobby_photo_path?: true
    deleted?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    _all?: true
  }

  export type Hobby_photoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_photo to aggregate.
     */
    where?: hobby_photoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_photos to fetch.
     */
    orderBy?: hobby_photoOrderByWithRelationInput | hobby_photoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hobby_photoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hobby_photos
    **/
    _count?: true | Hobby_photoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hobby_photoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hobby_photoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hobby_photoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hobby_photoMaxAggregateInputType
  }

  export type GetHobby_photoAggregateType<T extends Hobby_photoAggregateArgs> = {
        [P in keyof T & keyof AggregateHobby_photo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHobby_photo[P]>
      : GetScalarType<T[P], AggregateHobby_photo[P]>
  }




  export type hobby_photoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hobby_photoWhereInput
    orderBy?: hobby_photoOrderByWithAggregationInput | hobby_photoOrderByWithAggregationInput[]
    by: Hobby_photoScalarFieldEnum[] | Hobby_photoScalarFieldEnum
    having?: hobby_photoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hobby_photoCountAggregateInputType | true
    _avg?: Hobby_photoAvgAggregateInputType
    _sum?: Hobby_photoSumAggregateInputType
    _min?: Hobby_photoMinAggregateInputType
    _max?: Hobby_photoMaxAggregateInputType
  }

  export type Hobby_photoGroupByOutputType = {
    hobby_photo_id: bigint
    hobby_post_id: bigint
    hobby_photo_path: string
    deleted: boolean
    created_at: Date
    created_by: bigint
    modified_at: Date
    modified_by: bigint
    _count: Hobby_photoCountAggregateOutputType | null
    _avg: Hobby_photoAvgAggregateOutputType | null
    _sum: Hobby_photoSumAggregateOutputType | null
    _min: Hobby_photoMinAggregateOutputType | null
    _max: Hobby_photoMaxAggregateOutputType | null
  }

  type GetHobby_photoGroupByPayload<T extends hobby_photoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Hobby_photoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hobby_photoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hobby_photoGroupByOutputType[P]>
            : GetScalarType<T[P], Hobby_photoGroupByOutputType[P]>
        }
      >
    >


  export type hobby_photoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hobby_photo_id?: boolean
    hobby_post_id?: boolean
    hobby_photo_path?: boolean
    deleted?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
  }, ExtArgs["result"]["hobby_photo"]>



  export type hobby_photoSelectScalar = {
    hobby_photo_id?: boolean
    hobby_post_id?: boolean
    hobby_photo_path?: boolean
    deleted?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
  }

  export type hobby_photoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hobby_photo_id" | "hobby_post_id" | "hobby_photo_path" | "deleted" | "created_at" | "created_by" | "modified_at" | "modified_by", ExtArgs["result"]["hobby_photo"]>

  export type $hobby_photoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hobby_photo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      hobby_photo_id: bigint
      hobby_post_id: bigint
      hobby_photo_path: string
      deleted: boolean
      created_at: Date
      created_by: bigint
      modified_at: Date
      modified_by: bigint
    }, ExtArgs["result"]["hobby_photo"]>
    composites: {}
  }

  type hobby_photoGetPayload<S extends boolean | null | undefined | hobby_photoDefaultArgs> = $Result.GetResult<Prisma.$hobby_photoPayload, S>

  type hobby_photoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hobby_photoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Hobby_photoCountAggregateInputType | true
    }

  export interface hobby_photoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hobby_photo'], meta: { name: 'hobby_photo' } }
    /**
     * Find zero or one Hobby_photo that matches the filter.
     * @param {hobby_photoFindUniqueArgs} args - Arguments to find a Hobby_photo
     * @example
     * // Get one Hobby_photo
     * const hobby_photo = await prisma.hobby_photo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hobby_photoFindUniqueArgs>(args: SelectSubset<T, hobby_photoFindUniqueArgs<ExtArgs>>): Prisma__hobby_photoClient<$Result.GetResult<Prisma.$hobby_photoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hobby_photo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hobby_photoFindUniqueOrThrowArgs} args - Arguments to find a Hobby_photo
     * @example
     * // Get one Hobby_photo
     * const hobby_photo = await prisma.hobby_photo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hobby_photoFindUniqueOrThrowArgs>(args: SelectSubset<T, hobby_photoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hobby_photoClient<$Result.GetResult<Prisma.$hobby_photoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_photo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_photoFindFirstArgs} args - Arguments to find a Hobby_photo
     * @example
     * // Get one Hobby_photo
     * const hobby_photo = await prisma.hobby_photo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hobby_photoFindFirstArgs>(args?: SelectSubset<T, hobby_photoFindFirstArgs<ExtArgs>>): Prisma__hobby_photoClient<$Result.GetResult<Prisma.$hobby_photoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_photo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_photoFindFirstOrThrowArgs} args - Arguments to find a Hobby_photo
     * @example
     * // Get one Hobby_photo
     * const hobby_photo = await prisma.hobby_photo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hobby_photoFindFirstOrThrowArgs>(args?: SelectSubset<T, hobby_photoFindFirstOrThrowArgs<ExtArgs>>): Prisma__hobby_photoClient<$Result.GetResult<Prisma.$hobby_photoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hobby_photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_photoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hobby_photos
     * const hobby_photos = await prisma.hobby_photo.findMany()
     * 
     * // Get first 10 Hobby_photos
     * const hobby_photos = await prisma.hobby_photo.findMany({ take: 10 })
     * 
     * // Only select the `hobby_photo_id`
     * const hobby_photoWithHobby_photo_idOnly = await prisma.hobby_photo.findMany({ select: { hobby_photo_id: true } })
     * 
     */
    findMany<T extends hobby_photoFindManyArgs>(args?: SelectSubset<T, hobby_photoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hobby_photoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hobby_photo.
     * @param {hobby_photoCreateArgs} args - Arguments to create a Hobby_photo.
     * @example
     * // Create one Hobby_photo
     * const Hobby_photo = await prisma.hobby_photo.create({
     *   data: {
     *     // ... data to create a Hobby_photo
     *   }
     * })
     * 
     */
    create<T extends hobby_photoCreateArgs>(args: SelectSubset<T, hobby_photoCreateArgs<ExtArgs>>): Prisma__hobby_photoClient<$Result.GetResult<Prisma.$hobby_photoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hobby_photos.
     * @param {hobby_photoCreateManyArgs} args - Arguments to create many Hobby_photos.
     * @example
     * // Create many Hobby_photos
     * const hobby_photo = await prisma.hobby_photo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hobby_photoCreateManyArgs>(args?: SelectSubset<T, hobby_photoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hobby_photo.
     * @param {hobby_photoDeleteArgs} args - Arguments to delete one Hobby_photo.
     * @example
     * // Delete one Hobby_photo
     * const Hobby_photo = await prisma.hobby_photo.delete({
     *   where: {
     *     // ... filter to delete one Hobby_photo
     *   }
     * })
     * 
     */
    delete<T extends hobby_photoDeleteArgs>(args: SelectSubset<T, hobby_photoDeleteArgs<ExtArgs>>): Prisma__hobby_photoClient<$Result.GetResult<Prisma.$hobby_photoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hobby_photo.
     * @param {hobby_photoUpdateArgs} args - Arguments to update one Hobby_photo.
     * @example
     * // Update one Hobby_photo
     * const hobby_photo = await prisma.hobby_photo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hobby_photoUpdateArgs>(args: SelectSubset<T, hobby_photoUpdateArgs<ExtArgs>>): Prisma__hobby_photoClient<$Result.GetResult<Prisma.$hobby_photoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hobby_photos.
     * @param {hobby_photoDeleteManyArgs} args - Arguments to filter Hobby_photos to delete.
     * @example
     * // Delete a few Hobby_photos
     * const { count } = await prisma.hobby_photo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hobby_photoDeleteManyArgs>(args?: SelectSubset<T, hobby_photoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hobby_photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_photoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hobby_photos
     * const hobby_photo = await prisma.hobby_photo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hobby_photoUpdateManyArgs>(args: SelectSubset<T, hobby_photoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hobby_photo.
     * @param {hobby_photoUpsertArgs} args - Arguments to update or create a Hobby_photo.
     * @example
     * // Update or create a Hobby_photo
     * const hobby_photo = await prisma.hobby_photo.upsert({
     *   create: {
     *     // ... data to create a Hobby_photo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hobby_photo we want to update
     *   }
     * })
     */
    upsert<T extends hobby_photoUpsertArgs>(args: SelectSubset<T, hobby_photoUpsertArgs<ExtArgs>>): Prisma__hobby_photoClient<$Result.GetResult<Prisma.$hobby_photoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hobby_photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_photoCountArgs} args - Arguments to filter Hobby_photos to count.
     * @example
     * // Count the number of Hobby_photos
     * const count = await prisma.hobby_photo.count({
     *   where: {
     *     // ... the filter for the Hobby_photos we want to count
     *   }
     * })
    **/
    count<T extends hobby_photoCountArgs>(
      args?: Subset<T, hobby_photoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hobby_photoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hobby_photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hobby_photoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hobby_photoAggregateArgs>(args: Subset<T, Hobby_photoAggregateArgs>): Prisma.PrismaPromise<GetHobby_photoAggregateType<T>>

    /**
     * Group by Hobby_photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_photoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hobby_photoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hobby_photoGroupByArgs['orderBy'] }
        : { orderBy?: hobby_photoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hobby_photoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHobby_photoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hobby_photo model
   */
  readonly fields: hobby_photoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hobby_photo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hobby_photoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hobby_photo model
   */
  interface hobby_photoFieldRefs {
    readonly hobby_photo_id: FieldRef<"hobby_photo", 'BigInt'>
    readonly hobby_post_id: FieldRef<"hobby_photo", 'BigInt'>
    readonly hobby_photo_path: FieldRef<"hobby_photo", 'String'>
    readonly deleted: FieldRef<"hobby_photo", 'Boolean'>
    readonly created_at: FieldRef<"hobby_photo", 'DateTime'>
    readonly created_by: FieldRef<"hobby_photo", 'BigInt'>
    readonly modified_at: FieldRef<"hobby_photo", 'DateTime'>
    readonly modified_by: FieldRef<"hobby_photo", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * hobby_photo findUnique
   */
  export type hobby_photoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_photo
     */
    select?: hobby_photoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_photo
     */
    omit?: hobby_photoOmit<ExtArgs> | null
    /**
     * Filter, which hobby_photo to fetch.
     */
    where: hobby_photoWhereUniqueInput
  }

  /**
   * hobby_photo findUniqueOrThrow
   */
  export type hobby_photoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_photo
     */
    select?: hobby_photoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_photo
     */
    omit?: hobby_photoOmit<ExtArgs> | null
    /**
     * Filter, which hobby_photo to fetch.
     */
    where: hobby_photoWhereUniqueInput
  }

  /**
   * hobby_photo findFirst
   */
  export type hobby_photoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_photo
     */
    select?: hobby_photoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_photo
     */
    omit?: hobby_photoOmit<ExtArgs> | null
    /**
     * Filter, which hobby_photo to fetch.
     */
    where?: hobby_photoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_photos to fetch.
     */
    orderBy?: hobby_photoOrderByWithRelationInput | hobby_photoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_photos.
     */
    cursor?: hobby_photoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_photos.
     */
    distinct?: Hobby_photoScalarFieldEnum | Hobby_photoScalarFieldEnum[]
  }

  /**
   * hobby_photo findFirstOrThrow
   */
  export type hobby_photoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_photo
     */
    select?: hobby_photoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_photo
     */
    omit?: hobby_photoOmit<ExtArgs> | null
    /**
     * Filter, which hobby_photo to fetch.
     */
    where?: hobby_photoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_photos to fetch.
     */
    orderBy?: hobby_photoOrderByWithRelationInput | hobby_photoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_photos.
     */
    cursor?: hobby_photoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_photos.
     */
    distinct?: Hobby_photoScalarFieldEnum | Hobby_photoScalarFieldEnum[]
  }

  /**
   * hobby_photo findMany
   */
  export type hobby_photoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_photo
     */
    select?: hobby_photoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_photo
     */
    omit?: hobby_photoOmit<ExtArgs> | null
    /**
     * Filter, which hobby_photos to fetch.
     */
    where?: hobby_photoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_photos to fetch.
     */
    orderBy?: hobby_photoOrderByWithRelationInput | hobby_photoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hobby_photos.
     */
    cursor?: hobby_photoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_photos.
     */
    skip?: number
    distinct?: Hobby_photoScalarFieldEnum | Hobby_photoScalarFieldEnum[]
  }

  /**
   * hobby_photo create
   */
  export type hobby_photoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_photo
     */
    select?: hobby_photoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_photo
     */
    omit?: hobby_photoOmit<ExtArgs> | null
    /**
     * The data needed to create a hobby_photo.
     */
    data: XOR<hobby_photoCreateInput, hobby_photoUncheckedCreateInput>
  }

  /**
   * hobby_photo createMany
   */
  export type hobby_photoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hobby_photos.
     */
    data: hobby_photoCreateManyInput | hobby_photoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hobby_photo update
   */
  export type hobby_photoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_photo
     */
    select?: hobby_photoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_photo
     */
    omit?: hobby_photoOmit<ExtArgs> | null
    /**
     * The data needed to update a hobby_photo.
     */
    data: XOR<hobby_photoUpdateInput, hobby_photoUncheckedUpdateInput>
    /**
     * Choose, which hobby_photo to update.
     */
    where: hobby_photoWhereUniqueInput
  }

  /**
   * hobby_photo updateMany
   */
  export type hobby_photoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hobby_photos.
     */
    data: XOR<hobby_photoUpdateManyMutationInput, hobby_photoUncheckedUpdateManyInput>
    /**
     * Filter which hobby_photos to update
     */
    where?: hobby_photoWhereInput
    /**
     * Limit how many hobby_photos to update.
     */
    limit?: number
  }

  /**
   * hobby_photo upsert
   */
  export type hobby_photoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_photo
     */
    select?: hobby_photoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_photo
     */
    omit?: hobby_photoOmit<ExtArgs> | null
    /**
     * The filter to search for the hobby_photo to update in case it exists.
     */
    where: hobby_photoWhereUniqueInput
    /**
     * In case the hobby_photo found by the `where` argument doesn't exist, create a new hobby_photo with this data.
     */
    create: XOR<hobby_photoCreateInput, hobby_photoUncheckedCreateInput>
    /**
     * In case the hobby_photo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hobby_photoUpdateInput, hobby_photoUncheckedUpdateInput>
  }

  /**
   * hobby_photo delete
   */
  export type hobby_photoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_photo
     */
    select?: hobby_photoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_photo
     */
    omit?: hobby_photoOmit<ExtArgs> | null
    /**
     * Filter which hobby_photo to delete.
     */
    where: hobby_photoWhereUniqueInput
  }

  /**
   * hobby_photo deleteMany
   */
  export type hobby_photoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_photos to delete
     */
    where?: hobby_photoWhereInput
    /**
     * Limit how many hobby_photos to delete.
     */
    limit?: number
  }

  /**
   * hobby_photo without action
   */
  export type hobby_photoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_photo
     */
    select?: hobby_photoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_photo
     */
    omit?: hobby_photoOmit<ExtArgs> | null
  }


  /**
   * Model hobby_post
   */

  export type AggregateHobby_post = {
    _count: Hobby_postCountAggregateOutputType | null
    _avg: Hobby_postAvgAggregateOutputType | null
    _sum: Hobby_postSumAggregateOutputType | null
    _min: Hobby_postMinAggregateOutputType | null
    _max: Hobby_postMaxAggregateOutputType | null
  }

  export type Hobby_postAvgAggregateOutputType = {
    hobby_post_id: number | null
    user_id: number | null
    hobby_id: number | null
    created_by: number | null
    modified_by: number | null
  }

  export type Hobby_postSumAggregateOutputType = {
    hobby_post_id: bigint | null
    user_id: bigint | null
    hobby_id: bigint | null
    created_by: bigint | null
    modified_by: bigint | null
  }

  export type Hobby_postMinAggregateOutputType = {
    hobby_post_id: bigint | null
    user_id: bigint | null
    hobby_id: bigint | null
    hobby_post_content: string | null
    hobby_post_thumbnail: string | null
    deleted: boolean | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted_at: Date | null
  }

  export type Hobby_postMaxAggregateOutputType = {
    hobby_post_id: bigint | null
    user_id: bigint | null
    hobby_id: bigint | null
    hobby_post_content: string | null
    hobby_post_thumbnail: string | null
    deleted: boolean | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted_at: Date | null
  }

  export type Hobby_postCountAggregateOutputType = {
    hobby_post_id: number
    user_id: number
    hobby_id: number
    hobby_post_content: number
    hobby_post_thumbnail: number
    deleted: number
    created_at: number
    created_by: number
    modified_at: number
    modified_by: number
    deleted_at: number
    _all: number
  }


  export type Hobby_postAvgAggregateInputType = {
    hobby_post_id?: true
    user_id?: true
    hobby_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_postSumAggregateInputType = {
    hobby_post_id?: true
    user_id?: true
    hobby_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_postMinAggregateInputType = {
    hobby_post_id?: true
    user_id?: true
    hobby_id?: true
    hobby_post_content?: true
    hobby_post_thumbnail?: true
    deleted?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted_at?: true
  }

  export type Hobby_postMaxAggregateInputType = {
    hobby_post_id?: true
    user_id?: true
    hobby_id?: true
    hobby_post_content?: true
    hobby_post_thumbnail?: true
    deleted?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted_at?: true
  }

  export type Hobby_postCountAggregateInputType = {
    hobby_post_id?: true
    user_id?: true
    hobby_id?: true
    hobby_post_content?: true
    hobby_post_thumbnail?: true
    deleted?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted_at?: true
    _all?: true
  }

  export type Hobby_postAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_post to aggregate.
     */
    where?: hobby_postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_posts to fetch.
     */
    orderBy?: hobby_postOrderByWithRelationInput | hobby_postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hobby_postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hobby_posts
    **/
    _count?: true | Hobby_postCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hobby_postAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hobby_postSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hobby_postMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hobby_postMaxAggregateInputType
  }

  export type GetHobby_postAggregateType<T extends Hobby_postAggregateArgs> = {
        [P in keyof T & keyof AggregateHobby_post]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHobby_post[P]>
      : GetScalarType<T[P], AggregateHobby_post[P]>
  }




  export type hobby_postGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hobby_postWhereInput
    orderBy?: hobby_postOrderByWithAggregationInput | hobby_postOrderByWithAggregationInput[]
    by: Hobby_postScalarFieldEnum[] | Hobby_postScalarFieldEnum
    having?: hobby_postScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hobby_postCountAggregateInputType | true
    _avg?: Hobby_postAvgAggregateInputType
    _sum?: Hobby_postSumAggregateInputType
    _min?: Hobby_postMinAggregateInputType
    _max?: Hobby_postMaxAggregateInputType
  }

  export type Hobby_postGroupByOutputType = {
    hobby_post_id: bigint
    user_id: bigint
    hobby_id: bigint
    hobby_post_content: string
    hobby_post_thumbnail: string
    deleted: boolean
    created_at: Date
    created_by: bigint
    modified_at: Date
    modified_by: bigint
    deleted_at: Date | null
    _count: Hobby_postCountAggregateOutputType | null
    _avg: Hobby_postAvgAggregateOutputType | null
    _sum: Hobby_postSumAggregateOutputType | null
    _min: Hobby_postMinAggregateOutputType | null
    _max: Hobby_postMaxAggregateOutputType | null
  }

  type GetHobby_postGroupByPayload<T extends hobby_postGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Hobby_postGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hobby_postGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hobby_postGroupByOutputType[P]>
            : GetScalarType<T[P], Hobby_postGroupByOutputType[P]>
        }
      >
    >


  export type hobby_postSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hobby_post_id?: boolean
    user_id?: boolean
    hobby_id?: boolean
    hobby_post_content?: boolean
    hobby_post_thumbnail?: boolean
    deleted?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["hobby_post"]>



  export type hobby_postSelectScalar = {
    hobby_post_id?: boolean
    user_id?: boolean
    hobby_id?: boolean
    hobby_post_content?: boolean
    hobby_post_thumbnail?: boolean
    deleted?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted_at?: boolean
  }

  export type hobby_postOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hobby_post_id" | "user_id" | "hobby_id" | "hobby_post_content" | "hobby_post_thumbnail" | "deleted" | "created_at" | "created_by" | "modified_at" | "modified_by" | "deleted_at", ExtArgs["result"]["hobby_post"]>

  export type $hobby_postPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hobby_post"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      hobby_post_id: bigint
      user_id: bigint
      hobby_id: bigint
      hobby_post_content: string
      hobby_post_thumbnail: string
      deleted: boolean
      created_at: Date
      created_by: bigint
      modified_at: Date
      modified_by: bigint
      deleted_at: Date | null
    }, ExtArgs["result"]["hobby_post"]>
    composites: {}
  }

  type hobby_postGetPayload<S extends boolean | null | undefined | hobby_postDefaultArgs> = $Result.GetResult<Prisma.$hobby_postPayload, S>

  type hobby_postCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hobby_postFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Hobby_postCountAggregateInputType | true
    }

  export interface hobby_postDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hobby_post'], meta: { name: 'hobby_post' } }
    /**
     * Find zero or one Hobby_post that matches the filter.
     * @param {hobby_postFindUniqueArgs} args - Arguments to find a Hobby_post
     * @example
     * // Get one Hobby_post
     * const hobby_post = await prisma.hobby_post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hobby_postFindUniqueArgs>(args: SelectSubset<T, hobby_postFindUniqueArgs<ExtArgs>>): Prisma__hobby_postClient<$Result.GetResult<Prisma.$hobby_postPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hobby_post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hobby_postFindUniqueOrThrowArgs} args - Arguments to find a Hobby_post
     * @example
     * // Get one Hobby_post
     * const hobby_post = await prisma.hobby_post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hobby_postFindUniqueOrThrowArgs>(args: SelectSubset<T, hobby_postFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hobby_postClient<$Result.GetResult<Prisma.$hobby_postPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_postFindFirstArgs} args - Arguments to find a Hobby_post
     * @example
     * // Get one Hobby_post
     * const hobby_post = await prisma.hobby_post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hobby_postFindFirstArgs>(args?: SelectSubset<T, hobby_postFindFirstArgs<ExtArgs>>): Prisma__hobby_postClient<$Result.GetResult<Prisma.$hobby_postPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_postFindFirstOrThrowArgs} args - Arguments to find a Hobby_post
     * @example
     * // Get one Hobby_post
     * const hobby_post = await prisma.hobby_post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hobby_postFindFirstOrThrowArgs>(args?: SelectSubset<T, hobby_postFindFirstOrThrowArgs<ExtArgs>>): Prisma__hobby_postClient<$Result.GetResult<Prisma.$hobby_postPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hobby_posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_postFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hobby_posts
     * const hobby_posts = await prisma.hobby_post.findMany()
     * 
     * // Get first 10 Hobby_posts
     * const hobby_posts = await prisma.hobby_post.findMany({ take: 10 })
     * 
     * // Only select the `hobby_post_id`
     * const hobby_postWithHobby_post_idOnly = await prisma.hobby_post.findMany({ select: { hobby_post_id: true } })
     * 
     */
    findMany<T extends hobby_postFindManyArgs>(args?: SelectSubset<T, hobby_postFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hobby_postPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hobby_post.
     * @param {hobby_postCreateArgs} args - Arguments to create a Hobby_post.
     * @example
     * // Create one Hobby_post
     * const Hobby_post = await prisma.hobby_post.create({
     *   data: {
     *     // ... data to create a Hobby_post
     *   }
     * })
     * 
     */
    create<T extends hobby_postCreateArgs>(args: SelectSubset<T, hobby_postCreateArgs<ExtArgs>>): Prisma__hobby_postClient<$Result.GetResult<Prisma.$hobby_postPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hobby_posts.
     * @param {hobby_postCreateManyArgs} args - Arguments to create many Hobby_posts.
     * @example
     * // Create many Hobby_posts
     * const hobby_post = await prisma.hobby_post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hobby_postCreateManyArgs>(args?: SelectSubset<T, hobby_postCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hobby_post.
     * @param {hobby_postDeleteArgs} args - Arguments to delete one Hobby_post.
     * @example
     * // Delete one Hobby_post
     * const Hobby_post = await prisma.hobby_post.delete({
     *   where: {
     *     // ... filter to delete one Hobby_post
     *   }
     * })
     * 
     */
    delete<T extends hobby_postDeleteArgs>(args: SelectSubset<T, hobby_postDeleteArgs<ExtArgs>>): Prisma__hobby_postClient<$Result.GetResult<Prisma.$hobby_postPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hobby_post.
     * @param {hobby_postUpdateArgs} args - Arguments to update one Hobby_post.
     * @example
     * // Update one Hobby_post
     * const hobby_post = await prisma.hobby_post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hobby_postUpdateArgs>(args: SelectSubset<T, hobby_postUpdateArgs<ExtArgs>>): Prisma__hobby_postClient<$Result.GetResult<Prisma.$hobby_postPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hobby_posts.
     * @param {hobby_postDeleteManyArgs} args - Arguments to filter Hobby_posts to delete.
     * @example
     * // Delete a few Hobby_posts
     * const { count } = await prisma.hobby_post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hobby_postDeleteManyArgs>(args?: SelectSubset<T, hobby_postDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hobby_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_postUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hobby_posts
     * const hobby_post = await prisma.hobby_post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hobby_postUpdateManyArgs>(args: SelectSubset<T, hobby_postUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hobby_post.
     * @param {hobby_postUpsertArgs} args - Arguments to update or create a Hobby_post.
     * @example
     * // Update or create a Hobby_post
     * const hobby_post = await prisma.hobby_post.upsert({
     *   create: {
     *     // ... data to create a Hobby_post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hobby_post we want to update
     *   }
     * })
     */
    upsert<T extends hobby_postUpsertArgs>(args: SelectSubset<T, hobby_postUpsertArgs<ExtArgs>>): Prisma__hobby_postClient<$Result.GetResult<Prisma.$hobby_postPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hobby_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_postCountArgs} args - Arguments to filter Hobby_posts to count.
     * @example
     * // Count the number of Hobby_posts
     * const count = await prisma.hobby_post.count({
     *   where: {
     *     // ... the filter for the Hobby_posts we want to count
     *   }
     * })
    **/
    count<T extends hobby_postCountArgs>(
      args?: Subset<T, hobby_postCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hobby_postCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hobby_post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hobby_postAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hobby_postAggregateArgs>(args: Subset<T, Hobby_postAggregateArgs>): Prisma.PrismaPromise<GetHobby_postAggregateType<T>>

    /**
     * Group by Hobby_post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_postGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hobby_postGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hobby_postGroupByArgs['orderBy'] }
        : { orderBy?: hobby_postGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hobby_postGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHobby_postGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hobby_post model
   */
  readonly fields: hobby_postFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hobby_post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hobby_postClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hobby_post model
   */
  interface hobby_postFieldRefs {
    readonly hobby_post_id: FieldRef<"hobby_post", 'BigInt'>
    readonly user_id: FieldRef<"hobby_post", 'BigInt'>
    readonly hobby_id: FieldRef<"hobby_post", 'BigInt'>
    readonly hobby_post_content: FieldRef<"hobby_post", 'String'>
    readonly hobby_post_thumbnail: FieldRef<"hobby_post", 'String'>
    readonly deleted: FieldRef<"hobby_post", 'Boolean'>
    readonly created_at: FieldRef<"hobby_post", 'DateTime'>
    readonly created_by: FieldRef<"hobby_post", 'BigInt'>
    readonly modified_at: FieldRef<"hobby_post", 'DateTime'>
    readonly modified_by: FieldRef<"hobby_post", 'BigInt'>
    readonly deleted_at: FieldRef<"hobby_post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * hobby_post findUnique
   */
  export type hobby_postFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_post
     */
    select?: hobby_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_post
     */
    omit?: hobby_postOmit<ExtArgs> | null
    /**
     * Filter, which hobby_post to fetch.
     */
    where: hobby_postWhereUniqueInput
  }

  /**
   * hobby_post findUniqueOrThrow
   */
  export type hobby_postFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_post
     */
    select?: hobby_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_post
     */
    omit?: hobby_postOmit<ExtArgs> | null
    /**
     * Filter, which hobby_post to fetch.
     */
    where: hobby_postWhereUniqueInput
  }

  /**
   * hobby_post findFirst
   */
  export type hobby_postFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_post
     */
    select?: hobby_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_post
     */
    omit?: hobby_postOmit<ExtArgs> | null
    /**
     * Filter, which hobby_post to fetch.
     */
    where?: hobby_postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_posts to fetch.
     */
    orderBy?: hobby_postOrderByWithRelationInput | hobby_postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_posts.
     */
    cursor?: hobby_postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_posts.
     */
    distinct?: Hobby_postScalarFieldEnum | Hobby_postScalarFieldEnum[]
  }

  /**
   * hobby_post findFirstOrThrow
   */
  export type hobby_postFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_post
     */
    select?: hobby_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_post
     */
    omit?: hobby_postOmit<ExtArgs> | null
    /**
     * Filter, which hobby_post to fetch.
     */
    where?: hobby_postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_posts to fetch.
     */
    orderBy?: hobby_postOrderByWithRelationInput | hobby_postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_posts.
     */
    cursor?: hobby_postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_posts.
     */
    distinct?: Hobby_postScalarFieldEnum | Hobby_postScalarFieldEnum[]
  }

  /**
   * hobby_post findMany
   */
  export type hobby_postFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_post
     */
    select?: hobby_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_post
     */
    omit?: hobby_postOmit<ExtArgs> | null
    /**
     * Filter, which hobby_posts to fetch.
     */
    where?: hobby_postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_posts to fetch.
     */
    orderBy?: hobby_postOrderByWithRelationInput | hobby_postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hobby_posts.
     */
    cursor?: hobby_postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_posts.
     */
    skip?: number
    distinct?: Hobby_postScalarFieldEnum | Hobby_postScalarFieldEnum[]
  }

  /**
   * hobby_post create
   */
  export type hobby_postCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_post
     */
    select?: hobby_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_post
     */
    omit?: hobby_postOmit<ExtArgs> | null
    /**
     * The data needed to create a hobby_post.
     */
    data: XOR<hobby_postCreateInput, hobby_postUncheckedCreateInput>
  }

  /**
   * hobby_post createMany
   */
  export type hobby_postCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hobby_posts.
     */
    data: hobby_postCreateManyInput | hobby_postCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hobby_post update
   */
  export type hobby_postUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_post
     */
    select?: hobby_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_post
     */
    omit?: hobby_postOmit<ExtArgs> | null
    /**
     * The data needed to update a hobby_post.
     */
    data: XOR<hobby_postUpdateInput, hobby_postUncheckedUpdateInput>
    /**
     * Choose, which hobby_post to update.
     */
    where: hobby_postWhereUniqueInput
  }

  /**
   * hobby_post updateMany
   */
  export type hobby_postUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hobby_posts.
     */
    data: XOR<hobby_postUpdateManyMutationInput, hobby_postUncheckedUpdateManyInput>
    /**
     * Filter which hobby_posts to update
     */
    where?: hobby_postWhereInput
    /**
     * Limit how many hobby_posts to update.
     */
    limit?: number
  }

  /**
   * hobby_post upsert
   */
  export type hobby_postUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_post
     */
    select?: hobby_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_post
     */
    omit?: hobby_postOmit<ExtArgs> | null
    /**
     * The filter to search for the hobby_post to update in case it exists.
     */
    where: hobby_postWhereUniqueInput
    /**
     * In case the hobby_post found by the `where` argument doesn't exist, create a new hobby_post with this data.
     */
    create: XOR<hobby_postCreateInput, hobby_postUncheckedCreateInput>
    /**
     * In case the hobby_post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hobby_postUpdateInput, hobby_postUncheckedUpdateInput>
  }

  /**
   * hobby_post delete
   */
  export type hobby_postDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_post
     */
    select?: hobby_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_post
     */
    omit?: hobby_postOmit<ExtArgs> | null
    /**
     * Filter which hobby_post to delete.
     */
    where: hobby_postWhereUniqueInput
  }

  /**
   * hobby_post deleteMany
   */
  export type hobby_postDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_posts to delete
     */
    where?: hobby_postWhereInput
    /**
     * Limit how many hobby_posts to delete.
     */
    limit?: number
  }

  /**
   * hobby_post without action
   */
  export type hobby_postDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_post
     */
    select?: hobby_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_post
     */
    omit?: hobby_postOmit<ExtArgs> | null
  }


  /**
   * Model hobby_sub_comment
   */

  export type AggregateHobby_sub_comment = {
    _count: Hobby_sub_commentCountAggregateOutputType | null
    _avg: Hobby_sub_commentAvgAggregateOutputType | null
    _sum: Hobby_sub_commentSumAggregateOutputType | null
    _min: Hobby_sub_commentMinAggregateOutputType | null
    _max: Hobby_sub_commentMaxAggregateOutputType | null
  }

  export type Hobby_sub_commentAvgAggregateOutputType = {
    sub_comment_id: number | null
    comment_id: number | null
    post_id: number | null
    created_by: number | null
    modified_by: number | null
  }

  export type Hobby_sub_commentSumAggregateOutputType = {
    sub_comment_id: bigint | null
    comment_id: bigint | null
    post_id: bigint | null
    created_by: bigint | null
    modified_by: bigint | null
  }

  export type Hobby_sub_commentMinAggregateOutputType = {
    sub_comment_id: bigint | null
    comment_id: bigint | null
    post_id: bigint | null
    sub_comment: string | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
    deleted_at: Date | null
  }

  export type Hobby_sub_commentMaxAggregateOutputType = {
    sub_comment_id: bigint | null
    comment_id: bigint | null
    post_id: bigint | null
    sub_comment: string | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
    deleted_at: Date | null
  }

  export type Hobby_sub_commentCountAggregateOutputType = {
    sub_comment_id: number
    comment_id: number
    post_id: number
    sub_comment: number
    created_at: number
    created_by: number
    modified_at: number
    modified_by: number
    deleted: number
    deleted_at: number
    _all: number
  }


  export type Hobby_sub_commentAvgAggregateInputType = {
    sub_comment_id?: true
    comment_id?: true
    post_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_sub_commentSumAggregateInputType = {
    sub_comment_id?: true
    comment_id?: true
    post_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_sub_commentMinAggregateInputType = {
    sub_comment_id?: true
    comment_id?: true
    post_id?: true
    sub_comment?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
    deleted_at?: true
  }

  export type Hobby_sub_commentMaxAggregateInputType = {
    sub_comment_id?: true
    comment_id?: true
    post_id?: true
    sub_comment?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
    deleted_at?: true
  }

  export type Hobby_sub_commentCountAggregateInputType = {
    sub_comment_id?: true
    comment_id?: true
    post_id?: true
    sub_comment?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
    deleted_at?: true
    _all?: true
  }

  export type Hobby_sub_commentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_sub_comment to aggregate.
     */
    where?: hobby_sub_commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_sub_comments to fetch.
     */
    orderBy?: hobby_sub_commentOrderByWithRelationInput | hobby_sub_commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hobby_sub_commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_sub_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_sub_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hobby_sub_comments
    **/
    _count?: true | Hobby_sub_commentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hobby_sub_commentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hobby_sub_commentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hobby_sub_commentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hobby_sub_commentMaxAggregateInputType
  }

  export type GetHobby_sub_commentAggregateType<T extends Hobby_sub_commentAggregateArgs> = {
        [P in keyof T & keyof AggregateHobby_sub_comment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHobby_sub_comment[P]>
      : GetScalarType<T[P], AggregateHobby_sub_comment[P]>
  }




  export type hobby_sub_commentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hobby_sub_commentWhereInput
    orderBy?: hobby_sub_commentOrderByWithAggregationInput | hobby_sub_commentOrderByWithAggregationInput[]
    by: Hobby_sub_commentScalarFieldEnum[] | Hobby_sub_commentScalarFieldEnum
    having?: hobby_sub_commentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hobby_sub_commentCountAggregateInputType | true
    _avg?: Hobby_sub_commentAvgAggregateInputType
    _sum?: Hobby_sub_commentSumAggregateInputType
    _min?: Hobby_sub_commentMinAggregateInputType
    _max?: Hobby_sub_commentMaxAggregateInputType
  }

  export type Hobby_sub_commentGroupByOutputType = {
    sub_comment_id: bigint
    comment_id: bigint
    post_id: bigint
    sub_comment: string
    created_at: Date
    created_by: bigint
    modified_at: Date
    modified_by: bigint
    deleted: boolean
    deleted_at: Date | null
    _count: Hobby_sub_commentCountAggregateOutputType | null
    _avg: Hobby_sub_commentAvgAggregateOutputType | null
    _sum: Hobby_sub_commentSumAggregateOutputType | null
    _min: Hobby_sub_commentMinAggregateOutputType | null
    _max: Hobby_sub_commentMaxAggregateOutputType | null
  }

  type GetHobby_sub_commentGroupByPayload<T extends hobby_sub_commentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Hobby_sub_commentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hobby_sub_commentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hobby_sub_commentGroupByOutputType[P]>
            : GetScalarType<T[P], Hobby_sub_commentGroupByOutputType[P]>
        }
      >
    >


  export type hobby_sub_commentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sub_comment_id?: boolean
    comment_id?: boolean
    post_id?: boolean
    sub_comment?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["hobby_sub_comment"]>



  export type hobby_sub_commentSelectScalar = {
    sub_comment_id?: boolean
    comment_id?: boolean
    post_id?: boolean
    sub_comment?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
    deleted_at?: boolean
  }

  export type hobby_sub_commentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sub_comment_id" | "comment_id" | "post_id" | "sub_comment" | "created_at" | "created_by" | "modified_at" | "modified_by" | "deleted" | "deleted_at", ExtArgs["result"]["hobby_sub_comment"]>

  export type $hobby_sub_commentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hobby_sub_comment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      sub_comment_id: bigint
      comment_id: bigint
      post_id: bigint
      sub_comment: string
      created_at: Date
      created_by: bigint
      modified_at: Date
      modified_by: bigint
      deleted: boolean
      deleted_at: Date | null
    }, ExtArgs["result"]["hobby_sub_comment"]>
    composites: {}
  }

  type hobby_sub_commentGetPayload<S extends boolean | null | undefined | hobby_sub_commentDefaultArgs> = $Result.GetResult<Prisma.$hobby_sub_commentPayload, S>

  type hobby_sub_commentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hobby_sub_commentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Hobby_sub_commentCountAggregateInputType | true
    }

  export interface hobby_sub_commentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hobby_sub_comment'], meta: { name: 'hobby_sub_comment' } }
    /**
     * Find zero or one Hobby_sub_comment that matches the filter.
     * @param {hobby_sub_commentFindUniqueArgs} args - Arguments to find a Hobby_sub_comment
     * @example
     * // Get one Hobby_sub_comment
     * const hobby_sub_comment = await prisma.hobby_sub_comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hobby_sub_commentFindUniqueArgs>(args: SelectSubset<T, hobby_sub_commentFindUniqueArgs<ExtArgs>>): Prisma__hobby_sub_commentClient<$Result.GetResult<Prisma.$hobby_sub_commentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hobby_sub_comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hobby_sub_commentFindUniqueOrThrowArgs} args - Arguments to find a Hobby_sub_comment
     * @example
     * // Get one Hobby_sub_comment
     * const hobby_sub_comment = await prisma.hobby_sub_comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hobby_sub_commentFindUniqueOrThrowArgs>(args: SelectSubset<T, hobby_sub_commentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hobby_sub_commentClient<$Result.GetResult<Prisma.$hobby_sub_commentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_sub_comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_sub_commentFindFirstArgs} args - Arguments to find a Hobby_sub_comment
     * @example
     * // Get one Hobby_sub_comment
     * const hobby_sub_comment = await prisma.hobby_sub_comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hobby_sub_commentFindFirstArgs>(args?: SelectSubset<T, hobby_sub_commentFindFirstArgs<ExtArgs>>): Prisma__hobby_sub_commentClient<$Result.GetResult<Prisma.$hobby_sub_commentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_sub_comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_sub_commentFindFirstOrThrowArgs} args - Arguments to find a Hobby_sub_comment
     * @example
     * // Get one Hobby_sub_comment
     * const hobby_sub_comment = await prisma.hobby_sub_comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hobby_sub_commentFindFirstOrThrowArgs>(args?: SelectSubset<T, hobby_sub_commentFindFirstOrThrowArgs<ExtArgs>>): Prisma__hobby_sub_commentClient<$Result.GetResult<Prisma.$hobby_sub_commentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hobby_sub_comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_sub_commentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hobby_sub_comments
     * const hobby_sub_comments = await prisma.hobby_sub_comment.findMany()
     * 
     * // Get first 10 Hobby_sub_comments
     * const hobby_sub_comments = await prisma.hobby_sub_comment.findMany({ take: 10 })
     * 
     * // Only select the `sub_comment_id`
     * const hobby_sub_commentWithSub_comment_idOnly = await prisma.hobby_sub_comment.findMany({ select: { sub_comment_id: true } })
     * 
     */
    findMany<T extends hobby_sub_commentFindManyArgs>(args?: SelectSubset<T, hobby_sub_commentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hobby_sub_commentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hobby_sub_comment.
     * @param {hobby_sub_commentCreateArgs} args - Arguments to create a Hobby_sub_comment.
     * @example
     * // Create one Hobby_sub_comment
     * const Hobby_sub_comment = await prisma.hobby_sub_comment.create({
     *   data: {
     *     // ... data to create a Hobby_sub_comment
     *   }
     * })
     * 
     */
    create<T extends hobby_sub_commentCreateArgs>(args: SelectSubset<T, hobby_sub_commentCreateArgs<ExtArgs>>): Prisma__hobby_sub_commentClient<$Result.GetResult<Prisma.$hobby_sub_commentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hobby_sub_comments.
     * @param {hobby_sub_commentCreateManyArgs} args - Arguments to create many Hobby_sub_comments.
     * @example
     * // Create many Hobby_sub_comments
     * const hobby_sub_comment = await prisma.hobby_sub_comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hobby_sub_commentCreateManyArgs>(args?: SelectSubset<T, hobby_sub_commentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hobby_sub_comment.
     * @param {hobby_sub_commentDeleteArgs} args - Arguments to delete one Hobby_sub_comment.
     * @example
     * // Delete one Hobby_sub_comment
     * const Hobby_sub_comment = await prisma.hobby_sub_comment.delete({
     *   where: {
     *     // ... filter to delete one Hobby_sub_comment
     *   }
     * })
     * 
     */
    delete<T extends hobby_sub_commentDeleteArgs>(args: SelectSubset<T, hobby_sub_commentDeleteArgs<ExtArgs>>): Prisma__hobby_sub_commentClient<$Result.GetResult<Prisma.$hobby_sub_commentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hobby_sub_comment.
     * @param {hobby_sub_commentUpdateArgs} args - Arguments to update one Hobby_sub_comment.
     * @example
     * // Update one Hobby_sub_comment
     * const hobby_sub_comment = await prisma.hobby_sub_comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hobby_sub_commentUpdateArgs>(args: SelectSubset<T, hobby_sub_commentUpdateArgs<ExtArgs>>): Prisma__hobby_sub_commentClient<$Result.GetResult<Prisma.$hobby_sub_commentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hobby_sub_comments.
     * @param {hobby_sub_commentDeleteManyArgs} args - Arguments to filter Hobby_sub_comments to delete.
     * @example
     * // Delete a few Hobby_sub_comments
     * const { count } = await prisma.hobby_sub_comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hobby_sub_commentDeleteManyArgs>(args?: SelectSubset<T, hobby_sub_commentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hobby_sub_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_sub_commentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hobby_sub_comments
     * const hobby_sub_comment = await prisma.hobby_sub_comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hobby_sub_commentUpdateManyArgs>(args: SelectSubset<T, hobby_sub_commentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hobby_sub_comment.
     * @param {hobby_sub_commentUpsertArgs} args - Arguments to update or create a Hobby_sub_comment.
     * @example
     * // Update or create a Hobby_sub_comment
     * const hobby_sub_comment = await prisma.hobby_sub_comment.upsert({
     *   create: {
     *     // ... data to create a Hobby_sub_comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hobby_sub_comment we want to update
     *   }
     * })
     */
    upsert<T extends hobby_sub_commentUpsertArgs>(args: SelectSubset<T, hobby_sub_commentUpsertArgs<ExtArgs>>): Prisma__hobby_sub_commentClient<$Result.GetResult<Prisma.$hobby_sub_commentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hobby_sub_comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_sub_commentCountArgs} args - Arguments to filter Hobby_sub_comments to count.
     * @example
     * // Count the number of Hobby_sub_comments
     * const count = await prisma.hobby_sub_comment.count({
     *   where: {
     *     // ... the filter for the Hobby_sub_comments we want to count
     *   }
     * })
    **/
    count<T extends hobby_sub_commentCountArgs>(
      args?: Subset<T, hobby_sub_commentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hobby_sub_commentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hobby_sub_comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hobby_sub_commentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hobby_sub_commentAggregateArgs>(args: Subset<T, Hobby_sub_commentAggregateArgs>): Prisma.PrismaPromise<GetHobby_sub_commentAggregateType<T>>

    /**
     * Group by Hobby_sub_comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_sub_commentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hobby_sub_commentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hobby_sub_commentGroupByArgs['orderBy'] }
        : { orderBy?: hobby_sub_commentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hobby_sub_commentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHobby_sub_commentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hobby_sub_comment model
   */
  readonly fields: hobby_sub_commentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hobby_sub_comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hobby_sub_commentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hobby_sub_comment model
   */
  interface hobby_sub_commentFieldRefs {
    readonly sub_comment_id: FieldRef<"hobby_sub_comment", 'BigInt'>
    readonly comment_id: FieldRef<"hobby_sub_comment", 'BigInt'>
    readonly post_id: FieldRef<"hobby_sub_comment", 'BigInt'>
    readonly sub_comment: FieldRef<"hobby_sub_comment", 'String'>
    readonly created_at: FieldRef<"hobby_sub_comment", 'DateTime'>
    readonly created_by: FieldRef<"hobby_sub_comment", 'BigInt'>
    readonly modified_at: FieldRef<"hobby_sub_comment", 'DateTime'>
    readonly modified_by: FieldRef<"hobby_sub_comment", 'BigInt'>
    readonly deleted: FieldRef<"hobby_sub_comment", 'Boolean'>
    readonly deleted_at: FieldRef<"hobby_sub_comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * hobby_sub_comment findUnique
   */
  export type hobby_sub_commentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_sub_comment
     */
    select?: hobby_sub_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_sub_comment
     */
    omit?: hobby_sub_commentOmit<ExtArgs> | null
    /**
     * Filter, which hobby_sub_comment to fetch.
     */
    where: hobby_sub_commentWhereUniqueInput
  }

  /**
   * hobby_sub_comment findUniqueOrThrow
   */
  export type hobby_sub_commentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_sub_comment
     */
    select?: hobby_sub_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_sub_comment
     */
    omit?: hobby_sub_commentOmit<ExtArgs> | null
    /**
     * Filter, which hobby_sub_comment to fetch.
     */
    where: hobby_sub_commentWhereUniqueInput
  }

  /**
   * hobby_sub_comment findFirst
   */
  export type hobby_sub_commentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_sub_comment
     */
    select?: hobby_sub_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_sub_comment
     */
    omit?: hobby_sub_commentOmit<ExtArgs> | null
    /**
     * Filter, which hobby_sub_comment to fetch.
     */
    where?: hobby_sub_commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_sub_comments to fetch.
     */
    orderBy?: hobby_sub_commentOrderByWithRelationInput | hobby_sub_commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_sub_comments.
     */
    cursor?: hobby_sub_commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_sub_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_sub_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_sub_comments.
     */
    distinct?: Hobby_sub_commentScalarFieldEnum | Hobby_sub_commentScalarFieldEnum[]
  }

  /**
   * hobby_sub_comment findFirstOrThrow
   */
  export type hobby_sub_commentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_sub_comment
     */
    select?: hobby_sub_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_sub_comment
     */
    omit?: hobby_sub_commentOmit<ExtArgs> | null
    /**
     * Filter, which hobby_sub_comment to fetch.
     */
    where?: hobby_sub_commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_sub_comments to fetch.
     */
    orderBy?: hobby_sub_commentOrderByWithRelationInput | hobby_sub_commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_sub_comments.
     */
    cursor?: hobby_sub_commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_sub_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_sub_comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_sub_comments.
     */
    distinct?: Hobby_sub_commentScalarFieldEnum | Hobby_sub_commentScalarFieldEnum[]
  }

  /**
   * hobby_sub_comment findMany
   */
  export type hobby_sub_commentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_sub_comment
     */
    select?: hobby_sub_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_sub_comment
     */
    omit?: hobby_sub_commentOmit<ExtArgs> | null
    /**
     * Filter, which hobby_sub_comments to fetch.
     */
    where?: hobby_sub_commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_sub_comments to fetch.
     */
    orderBy?: hobby_sub_commentOrderByWithRelationInput | hobby_sub_commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hobby_sub_comments.
     */
    cursor?: hobby_sub_commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_sub_comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_sub_comments.
     */
    skip?: number
    distinct?: Hobby_sub_commentScalarFieldEnum | Hobby_sub_commentScalarFieldEnum[]
  }

  /**
   * hobby_sub_comment create
   */
  export type hobby_sub_commentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_sub_comment
     */
    select?: hobby_sub_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_sub_comment
     */
    omit?: hobby_sub_commentOmit<ExtArgs> | null
    /**
     * The data needed to create a hobby_sub_comment.
     */
    data: XOR<hobby_sub_commentCreateInput, hobby_sub_commentUncheckedCreateInput>
  }

  /**
   * hobby_sub_comment createMany
   */
  export type hobby_sub_commentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hobby_sub_comments.
     */
    data: hobby_sub_commentCreateManyInput | hobby_sub_commentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hobby_sub_comment update
   */
  export type hobby_sub_commentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_sub_comment
     */
    select?: hobby_sub_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_sub_comment
     */
    omit?: hobby_sub_commentOmit<ExtArgs> | null
    /**
     * The data needed to update a hobby_sub_comment.
     */
    data: XOR<hobby_sub_commentUpdateInput, hobby_sub_commentUncheckedUpdateInput>
    /**
     * Choose, which hobby_sub_comment to update.
     */
    where: hobby_sub_commentWhereUniqueInput
  }

  /**
   * hobby_sub_comment updateMany
   */
  export type hobby_sub_commentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hobby_sub_comments.
     */
    data: XOR<hobby_sub_commentUpdateManyMutationInput, hobby_sub_commentUncheckedUpdateManyInput>
    /**
     * Filter which hobby_sub_comments to update
     */
    where?: hobby_sub_commentWhereInput
    /**
     * Limit how many hobby_sub_comments to update.
     */
    limit?: number
  }

  /**
   * hobby_sub_comment upsert
   */
  export type hobby_sub_commentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_sub_comment
     */
    select?: hobby_sub_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_sub_comment
     */
    omit?: hobby_sub_commentOmit<ExtArgs> | null
    /**
     * The filter to search for the hobby_sub_comment to update in case it exists.
     */
    where: hobby_sub_commentWhereUniqueInput
    /**
     * In case the hobby_sub_comment found by the `where` argument doesn't exist, create a new hobby_sub_comment with this data.
     */
    create: XOR<hobby_sub_commentCreateInput, hobby_sub_commentUncheckedCreateInput>
    /**
     * In case the hobby_sub_comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hobby_sub_commentUpdateInput, hobby_sub_commentUncheckedUpdateInput>
  }

  /**
   * hobby_sub_comment delete
   */
  export type hobby_sub_commentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_sub_comment
     */
    select?: hobby_sub_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_sub_comment
     */
    omit?: hobby_sub_commentOmit<ExtArgs> | null
    /**
     * Filter which hobby_sub_comment to delete.
     */
    where: hobby_sub_commentWhereUniqueInput
  }

  /**
   * hobby_sub_comment deleteMany
   */
  export type hobby_sub_commentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_sub_comments to delete
     */
    where?: hobby_sub_commentWhereInput
    /**
     * Limit how many hobby_sub_comments to delete.
     */
    limit?: number
  }

  /**
   * hobby_sub_comment without action
   */
  export type hobby_sub_commentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_sub_comment
     */
    select?: hobby_sub_commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_sub_comment
     */
    omit?: hobby_sub_commentOmit<ExtArgs> | null
  }


  /**
   * Model hobby_top_ten
   */

  export type AggregateHobby_top_ten = {
    _count: Hobby_top_tenCountAggregateOutputType | null
    _avg: Hobby_top_tenAvgAggregateOutputType | null
    _sum: Hobby_top_tenSumAggregateOutputType | null
    _min: Hobby_top_tenMinAggregateOutputType | null
    _max: Hobby_top_tenMaxAggregateOutputType | null
  }

  export type Hobby_top_tenAvgAggregateOutputType = {
    hobby_top_ten_id: number | null
    hobby_post_id: number | null
    view_count: number | null
  }

  export type Hobby_top_tenSumAggregateOutputType = {
    hobby_top_ten_id: bigint | null
    hobby_post_id: bigint | null
    view_count: bigint | null
  }

  export type Hobby_top_tenMinAggregateOutputType = {
    hobby_top_ten_id: bigint | null
    hobby_post_id: bigint | null
    view_count: bigint | null
    category: $Enums.hobby_top_ten_category | null
    created_at: Date | null
  }

  export type Hobby_top_tenMaxAggregateOutputType = {
    hobby_top_ten_id: bigint | null
    hobby_post_id: bigint | null
    view_count: bigint | null
    category: $Enums.hobby_top_ten_category | null
    created_at: Date | null
  }

  export type Hobby_top_tenCountAggregateOutputType = {
    hobby_top_ten_id: number
    hobby_post_id: number
    view_count: number
    category: number
    created_at: number
    _all: number
  }


  export type Hobby_top_tenAvgAggregateInputType = {
    hobby_top_ten_id?: true
    hobby_post_id?: true
    view_count?: true
  }

  export type Hobby_top_tenSumAggregateInputType = {
    hobby_top_ten_id?: true
    hobby_post_id?: true
    view_count?: true
  }

  export type Hobby_top_tenMinAggregateInputType = {
    hobby_top_ten_id?: true
    hobby_post_id?: true
    view_count?: true
    category?: true
    created_at?: true
  }

  export type Hobby_top_tenMaxAggregateInputType = {
    hobby_top_ten_id?: true
    hobby_post_id?: true
    view_count?: true
    category?: true
    created_at?: true
  }

  export type Hobby_top_tenCountAggregateInputType = {
    hobby_top_ten_id?: true
    hobby_post_id?: true
    view_count?: true
    category?: true
    created_at?: true
    _all?: true
  }

  export type Hobby_top_tenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_top_ten to aggregate.
     */
    where?: hobby_top_tenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_top_tens to fetch.
     */
    orderBy?: hobby_top_tenOrderByWithRelationInput | hobby_top_tenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hobby_top_tenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_top_tens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_top_tens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hobby_top_tens
    **/
    _count?: true | Hobby_top_tenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hobby_top_tenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hobby_top_tenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hobby_top_tenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hobby_top_tenMaxAggregateInputType
  }

  export type GetHobby_top_tenAggregateType<T extends Hobby_top_tenAggregateArgs> = {
        [P in keyof T & keyof AggregateHobby_top_ten]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHobby_top_ten[P]>
      : GetScalarType<T[P], AggregateHobby_top_ten[P]>
  }




  export type hobby_top_tenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hobby_top_tenWhereInput
    orderBy?: hobby_top_tenOrderByWithAggregationInput | hobby_top_tenOrderByWithAggregationInput[]
    by: Hobby_top_tenScalarFieldEnum[] | Hobby_top_tenScalarFieldEnum
    having?: hobby_top_tenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hobby_top_tenCountAggregateInputType | true
    _avg?: Hobby_top_tenAvgAggregateInputType
    _sum?: Hobby_top_tenSumAggregateInputType
    _min?: Hobby_top_tenMinAggregateInputType
    _max?: Hobby_top_tenMaxAggregateInputType
  }

  export type Hobby_top_tenGroupByOutputType = {
    hobby_top_ten_id: bigint
    hobby_post_id: bigint
    view_count: bigint
    category: $Enums.hobby_top_ten_category
    created_at: Date
    _count: Hobby_top_tenCountAggregateOutputType | null
    _avg: Hobby_top_tenAvgAggregateOutputType | null
    _sum: Hobby_top_tenSumAggregateOutputType | null
    _min: Hobby_top_tenMinAggregateOutputType | null
    _max: Hobby_top_tenMaxAggregateOutputType | null
  }

  type GetHobby_top_tenGroupByPayload<T extends hobby_top_tenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Hobby_top_tenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hobby_top_tenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hobby_top_tenGroupByOutputType[P]>
            : GetScalarType<T[P], Hobby_top_tenGroupByOutputType[P]>
        }
      >
    >


  export type hobby_top_tenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hobby_top_ten_id?: boolean
    hobby_post_id?: boolean
    view_count?: boolean
    category?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["hobby_top_ten"]>



  export type hobby_top_tenSelectScalar = {
    hobby_top_ten_id?: boolean
    hobby_post_id?: boolean
    view_count?: boolean
    category?: boolean
    created_at?: boolean
  }

  export type hobby_top_tenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hobby_top_ten_id" | "hobby_post_id" | "view_count" | "category" | "created_at", ExtArgs["result"]["hobby_top_ten"]>

  export type $hobby_top_tenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hobby_top_ten"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      hobby_top_ten_id: bigint
      hobby_post_id: bigint
      view_count: bigint
      category: $Enums.hobby_top_ten_category
      created_at: Date
    }, ExtArgs["result"]["hobby_top_ten"]>
    composites: {}
  }

  type hobby_top_tenGetPayload<S extends boolean | null | undefined | hobby_top_tenDefaultArgs> = $Result.GetResult<Prisma.$hobby_top_tenPayload, S>

  type hobby_top_tenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hobby_top_tenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Hobby_top_tenCountAggregateInputType | true
    }

  export interface hobby_top_tenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hobby_top_ten'], meta: { name: 'hobby_top_ten' } }
    /**
     * Find zero or one Hobby_top_ten that matches the filter.
     * @param {hobby_top_tenFindUniqueArgs} args - Arguments to find a Hobby_top_ten
     * @example
     * // Get one Hobby_top_ten
     * const hobby_top_ten = await prisma.hobby_top_ten.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hobby_top_tenFindUniqueArgs>(args: SelectSubset<T, hobby_top_tenFindUniqueArgs<ExtArgs>>): Prisma__hobby_top_tenClient<$Result.GetResult<Prisma.$hobby_top_tenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hobby_top_ten that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hobby_top_tenFindUniqueOrThrowArgs} args - Arguments to find a Hobby_top_ten
     * @example
     * // Get one Hobby_top_ten
     * const hobby_top_ten = await prisma.hobby_top_ten.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hobby_top_tenFindUniqueOrThrowArgs>(args: SelectSubset<T, hobby_top_tenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hobby_top_tenClient<$Result.GetResult<Prisma.$hobby_top_tenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_top_ten that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_top_tenFindFirstArgs} args - Arguments to find a Hobby_top_ten
     * @example
     * // Get one Hobby_top_ten
     * const hobby_top_ten = await prisma.hobby_top_ten.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hobby_top_tenFindFirstArgs>(args?: SelectSubset<T, hobby_top_tenFindFirstArgs<ExtArgs>>): Prisma__hobby_top_tenClient<$Result.GetResult<Prisma.$hobby_top_tenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_top_ten that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_top_tenFindFirstOrThrowArgs} args - Arguments to find a Hobby_top_ten
     * @example
     * // Get one Hobby_top_ten
     * const hobby_top_ten = await prisma.hobby_top_ten.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hobby_top_tenFindFirstOrThrowArgs>(args?: SelectSubset<T, hobby_top_tenFindFirstOrThrowArgs<ExtArgs>>): Prisma__hobby_top_tenClient<$Result.GetResult<Prisma.$hobby_top_tenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hobby_top_tens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_top_tenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hobby_top_tens
     * const hobby_top_tens = await prisma.hobby_top_ten.findMany()
     * 
     * // Get first 10 Hobby_top_tens
     * const hobby_top_tens = await prisma.hobby_top_ten.findMany({ take: 10 })
     * 
     * // Only select the `hobby_top_ten_id`
     * const hobby_top_tenWithHobby_top_ten_idOnly = await prisma.hobby_top_ten.findMany({ select: { hobby_top_ten_id: true } })
     * 
     */
    findMany<T extends hobby_top_tenFindManyArgs>(args?: SelectSubset<T, hobby_top_tenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hobby_top_tenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hobby_top_ten.
     * @param {hobby_top_tenCreateArgs} args - Arguments to create a Hobby_top_ten.
     * @example
     * // Create one Hobby_top_ten
     * const Hobby_top_ten = await prisma.hobby_top_ten.create({
     *   data: {
     *     // ... data to create a Hobby_top_ten
     *   }
     * })
     * 
     */
    create<T extends hobby_top_tenCreateArgs>(args: SelectSubset<T, hobby_top_tenCreateArgs<ExtArgs>>): Prisma__hobby_top_tenClient<$Result.GetResult<Prisma.$hobby_top_tenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hobby_top_tens.
     * @param {hobby_top_tenCreateManyArgs} args - Arguments to create many Hobby_top_tens.
     * @example
     * // Create many Hobby_top_tens
     * const hobby_top_ten = await prisma.hobby_top_ten.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hobby_top_tenCreateManyArgs>(args?: SelectSubset<T, hobby_top_tenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hobby_top_ten.
     * @param {hobby_top_tenDeleteArgs} args - Arguments to delete one Hobby_top_ten.
     * @example
     * // Delete one Hobby_top_ten
     * const Hobby_top_ten = await prisma.hobby_top_ten.delete({
     *   where: {
     *     // ... filter to delete one Hobby_top_ten
     *   }
     * })
     * 
     */
    delete<T extends hobby_top_tenDeleteArgs>(args: SelectSubset<T, hobby_top_tenDeleteArgs<ExtArgs>>): Prisma__hobby_top_tenClient<$Result.GetResult<Prisma.$hobby_top_tenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hobby_top_ten.
     * @param {hobby_top_tenUpdateArgs} args - Arguments to update one Hobby_top_ten.
     * @example
     * // Update one Hobby_top_ten
     * const hobby_top_ten = await prisma.hobby_top_ten.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hobby_top_tenUpdateArgs>(args: SelectSubset<T, hobby_top_tenUpdateArgs<ExtArgs>>): Prisma__hobby_top_tenClient<$Result.GetResult<Prisma.$hobby_top_tenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hobby_top_tens.
     * @param {hobby_top_tenDeleteManyArgs} args - Arguments to filter Hobby_top_tens to delete.
     * @example
     * // Delete a few Hobby_top_tens
     * const { count } = await prisma.hobby_top_ten.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hobby_top_tenDeleteManyArgs>(args?: SelectSubset<T, hobby_top_tenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hobby_top_tens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_top_tenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hobby_top_tens
     * const hobby_top_ten = await prisma.hobby_top_ten.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hobby_top_tenUpdateManyArgs>(args: SelectSubset<T, hobby_top_tenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hobby_top_ten.
     * @param {hobby_top_tenUpsertArgs} args - Arguments to update or create a Hobby_top_ten.
     * @example
     * // Update or create a Hobby_top_ten
     * const hobby_top_ten = await prisma.hobby_top_ten.upsert({
     *   create: {
     *     // ... data to create a Hobby_top_ten
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hobby_top_ten we want to update
     *   }
     * })
     */
    upsert<T extends hobby_top_tenUpsertArgs>(args: SelectSubset<T, hobby_top_tenUpsertArgs<ExtArgs>>): Prisma__hobby_top_tenClient<$Result.GetResult<Prisma.$hobby_top_tenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hobby_top_tens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_top_tenCountArgs} args - Arguments to filter Hobby_top_tens to count.
     * @example
     * // Count the number of Hobby_top_tens
     * const count = await prisma.hobby_top_ten.count({
     *   where: {
     *     // ... the filter for the Hobby_top_tens we want to count
     *   }
     * })
    **/
    count<T extends hobby_top_tenCountArgs>(
      args?: Subset<T, hobby_top_tenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hobby_top_tenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hobby_top_ten.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hobby_top_tenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hobby_top_tenAggregateArgs>(args: Subset<T, Hobby_top_tenAggregateArgs>): Prisma.PrismaPromise<GetHobby_top_tenAggregateType<T>>

    /**
     * Group by Hobby_top_ten.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_top_tenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hobby_top_tenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hobby_top_tenGroupByArgs['orderBy'] }
        : { orderBy?: hobby_top_tenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hobby_top_tenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHobby_top_tenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hobby_top_ten model
   */
  readonly fields: hobby_top_tenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hobby_top_ten.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hobby_top_tenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hobby_top_ten model
   */
  interface hobby_top_tenFieldRefs {
    readonly hobby_top_ten_id: FieldRef<"hobby_top_ten", 'BigInt'>
    readonly hobby_post_id: FieldRef<"hobby_top_ten", 'BigInt'>
    readonly view_count: FieldRef<"hobby_top_ten", 'BigInt'>
    readonly category: FieldRef<"hobby_top_ten", 'hobby_top_ten_category'>
    readonly created_at: FieldRef<"hobby_top_ten", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * hobby_top_ten findUnique
   */
  export type hobby_top_tenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_top_ten
     */
    select?: hobby_top_tenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_top_ten
     */
    omit?: hobby_top_tenOmit<ExtArgs> | null
    /**
     * Filter, which hobby_top_ten to fetch.
     */
    where: hobby_top_tenWhereUniqueInput
  }

  /**
   * hobby_top_ten findUniqueOrThrow
   */
  export type hobby_top_tenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_top_ten
     */
    select?: hobby_top_tenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_top_ten
     */
    omit?: hobby_top_tenOmit<ExtArgs> | null
    /**
     * Filter, which hobby_top_ten to fetch.
     */
    where: hobby_top_tenWhereUniqueInput
  }

  /**
   * hobby_top_ten findFirst
   */
  export type hobby_top_tenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_top_ten
     */
    select?: hobby_top_tenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_top_ten
     */
    omit?: hobby_top_tenOmit<ExtArgs> | null
    /**
     * Filter, which hobby_top_ten to fetch.
     */
    where?: hobby_top_tenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_top_tens to fetch.
     */
    orderBy?: hobby_top_tenOrderByWithRelationInput | hobby_top_tenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_top_tens.
     */
    cursor?: hobby_top_tenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_top_tens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_top_tens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_top_tens.
     */
    distinct?: Hobby_top_tenScalarFieldEnum | Hobby_top_tenScalarFieldEnum[]
  }

  /**
   * hobby_top_ten findFirstOrThrow
   */
  export type hobby_top_tenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_top_ten
     */
    select?: hobby_top_tenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_top_ten
     */
    omit?: hobby_top_tenOmit<ExtArgs> | null
    /**
     * Filter, which hobby_top_ten to fetch.
     */
    where?: hobby_top_tenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_top_tens to fetch.
     */
    orderBy?: hobby_top_tenOrderByWithRelationInput | hobby_top_tenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_top_tens.
     */
    cursor?: hobby_top_tenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_top_tens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_top_tens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_top_tens.
     */
    distinct?: Hobby_top_tenScalarFieldEnum | Hobby_top_tenScalarFieldEnum[]
  }

  /**
   * hobby_top_ten findMany
   */
  export type hobby_top_tenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_top_ten
     */
    select?: hobby_top_tenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_top_ten
     */
    omit?: hobby_top_tenOmit<ExtArgs> | null
    /**
     * Filter, which hobby_top_tens to fetch.
     */
    where?: hobby_top_tenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_top_tens to fetch.
     */
    orderBy?: hobby_top_tenOrderByWithRelationInput | hobby_top_tenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hobby_top_tens.
     */
    cursor?: hobby_top_tenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_top_tens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_top_tens.
     */
    skip?: number
    distinct?: Hobby_top_tenScalarFieldEnum | Hobby_top_tenScalarFieldEnum[]
  }

  /**
   * hobby_top_ten create
   */
  export type hobby_top_tenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_top_ten
     */
    select?: hobby_top_tenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_top_ten
     */
    omit?: hobby_top_tenOmit<ExtArgs> | null
    /**
     * The data needed to create a hobby_top_ten.
     */
    data: XOR<hobby_top_tenCreateInput, hobby_top_tenUncheckedCreateInput>
  }

  /**
   * hobby_top_ten createMany
   */
  export type hobby_top_tenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hobby_top_tens.
     */
    data: hobby_top_tenCreateManyInput | hobby_top_tenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hobby_top_ten update
   */
  export type hobby_top_tenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_top_ten
     */
    select?: hobby_top_tenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_top_ten
     */
    omit?: hobby_top_tenOmit<ExtArgs> | null
    /**
     * The data needed to update a hobby_top_ten.
     */
    data: XOR<hobby_top_tenUpdateInput, hobby_top_tenUncheckedUpdateInput>
    /**
     * Choose, which hobby_top_ten to update.
     */
    where: hobby_top_tenWhereUniqueInput
  }

  /**
   * hobby_top_ten updateMany
   */
  export type hobby_top_tenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hobby_top_tens.
     */
    data: XOR<hobby_top_tenUpdateManyMutationInput, hobby_top_tenUncheckedUpdateManyInput>
    /**
     * Filter which hobby_top_tens to update
     */
    where?: hobby_top_tenWhereInput
    /**
     * Limit how many hobby_top_tens to update.
     */
    limit?: number
  }

  /**
   * hobby_top_ten upsert
   */
  export type hobby_top_tenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_top_ten
     */
    select?: hobby_top_tenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_top_ten
     */
    omit?: hobby_top_tenOmit<ExtArgs> | null
    /**
     * The filter to search for the hobby_top_ten to update in case it exists.
     */
    where: hobby_top_tenWhereUniqueInput
    /**
     * In case the hobby_top_ten found by the `where` argument doesn't exist, create a new hobby_top_ten with this data.
     */
    create: XOR<hobby_top_tenCreateInput, hobby_top_tenUncheckedCreateInput>
    /**
     * In case the hobby_top_ten was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hobby_top_tenUpdateInput, hobby_top_tenUncheckedUpdateInput>
  }

  /**
   * hobby_top_ten delete
   */
  export type hobby_top_tenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_top_ten
     */
    select?: hobby_top_tenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_top_ten
     */
    omit?: hobby_top_tenOmit<ExtArgs> | null
    /**
     * Filter which hobby_top_ten to delete.
     */
    where: hobby_top_tenWhereUniqueInput
  }

  /**
   * hobby_top_ten deleteMany
   */
  export type hobby_top_tenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_top_tens to delete
     */
    where?: hobby_top_tenWhereInput
    /**
     * Limit how many hobby_top_tens to delete.
     */
    limit?: number
  }

  /**
   * hobby_top_ten without action
   */
  export type hobby_top_tenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_top_ten
     */
    select?: hobby_top_tenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_top_ten
     */
    omit?: hobby_top_tenOmit<ExtArgs> | null
  }


  /**
   * Model hobby_view_history
   */

  export type AggregateHobby_view_history = {
    _count: Hobby_view_historyCountAggregateOutputType | null
    _avg: Hobby_view_historyAvgAggregateOutputType | null
    _sum: Hobby_view_historySumAggregateOutputType | null
    _min: Hobby_view_historyMinAggregateOutputType | null
    _max: Hobby_view_historyMaxAggregateOutputType | null
  }

  export type Hobby_view_historyAvgAggregateOutputType = {
    hobby_view_history_id: number | null
    hobby_post_id: number | null
    user_id: number | null
    created_by: number | null
    modified_by: number | null
  }

  export type Hobby_view_historySumAggregateOutputType = {
    hobby_view_history_id: bigint | null
    hobby_post_id: bigint | null
    user_id: bigint | null
    created_by: bigint | null
    modified_by: bigint | null
  }

  export type Hobby_view_historyMinAggregateOutputType = {
    hobby_view_history_id: bigint | null
    hobby_post_id: bigint | null
    user_id: bigint | null
    category: $Enums.hobby_view_history_category | null
    created_at: Date | null
    modified_at: Date | null
    created_by: bigint | null
    modified_by: bigint | null
    deleted: boolean | null
  }

  export type Hobby_view_historyMaxAggregateOutputType = {
    hobby_view_history_id: bigint | null
    hobby_post_id: bigint | null
    user_id: bigint | null
    category: $Enums.hobby_view_history_category | null
    created_at: Date | null
    modified_at: Date | null
    created_by: bigint | null
    modified_by: bigint | null
    deleted: boolean | null
  }

  export type Hobby_view_historyCountAggregateOutputType = {
    hobby_view_history_id: number
    hobby_post_id: number
    user_id: number
    category: number
    created_at: number
    modified_at: number
    created_by: number
    modified_by: number
    deleted: number
    _all: number
  }


  export type Hobby_view_historyAvgAggregateInputType = {
    hobby_view_history_id?: true
    hobby_post_id?: true
    user_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_view_historySumAggregateInputType = {
    hobby_view_history_id?: true
    hobby_post_id?: true
    user_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Hobby_view_historyMinAggregateInputType = {
    hobby_view_history_id?: true
    hobby_post_id?: true
    user_id?: true
    category?: true
    created_at?: true
    modified_at?: true
    created_by?: true
    modified_by?: true
    deleted?: true
  }

  export type Hobby_view_historyMaxAggregateInputType = {
    hobby_view_history_id?: true
    hobby_post_id?: true
    user_id?: true
    category?: true
    created_at?: true
    modified_at?: true
    created_by?: true
    modified_by?: true
    deleted?: true
  }

  export type Hobby_view_historyCountAggregateInputType = {
    hobby_view_history_id?: true
    hobby_post_id?: true
    user_id?: true
    category?: true
    created_at?: true
    modified_at?: true
    created_by?: true
    modified_by?: true
    deleted?: true
    _all?: true
  }

  export type Hobby_view_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_view_history to aggregate.
     */
    where?: hobby_view_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_view_histories to fetch.
     */
    orderBy?: hobby_view_historyOrderByWithRelationInput | hobby_view_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hobby_view_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_view_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_view_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hobby_view_histories
    **/
    _count?: true | Hobby_view_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hobby_view_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hobby_view_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hobby_view_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hobby_view_historyMaxAggregateInputType
  }

  export type GetHobby_view_historyAggregateType<T extends Hobby_view_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateHobby_view_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHobby_view_history[P]>
      : GetScalarType<T[P], AggregateHobby_view_history[P]>
  }




  export type hobby_view_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hobby_view_historyWhereInput
    orderBy?: hobby_view_historyOrderByWithAggregationInput | hobby_view_historyOrderByWithAggregationInput[]
    by: Hobby_view_historyScalarFieldEnum[] | Hobby_view_historyScalarFieldEnum
    having?: hobby_view_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hobby_view_historyCountAggregateInputType | true
    _avg?: Hobby_view_historyAvgAggregateInputType
    _sum?: Hobby_view_historySumAggregateInputType
    _min?: Hobby_view_historyMinAggregateInputType
    _max?: Hobby_view_historyMaxAggregateInputType
  }

  export type Hobby_view_historyGroupByOutputType = {
    hobby_view_history_id: bigint
    hobby_post_id: bigint
    user_id: bigint
    category: $Enums.hobby_view_history_category
    created_at: Date
    modified_at: Date
    created_by: bigint
    modified_by: bigint
    deleted: boolean
    _count: Hobby_view_historyCountAggregateOutputType | null
    _avg: Hobby_view_historyAvgAggregateOutputType | null
    _sum: Hobby_view_historySumAggregateOutputType | null
    _min: Hobby_view_historyMinAggregateOutputType | null
    _max: Hobby_view_historyMaxAggregateOutputType | null
  }

  type GetHobby_view_historyGroupByPayload<T extends hobby_view_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Hobby_view_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hobby_view_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hobby_view_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Hobby_view_historyGroupByOutputType[P]>
        }
      >
    >


  export type hobby_view_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hobby_view_history_id?: boolean
    hobby_post_id?: boolean
    user_id?: boolean
    category?: boolean
    created_at?: boolean
    modified_at?: boolean
    created_by?: boolean
    modified_by?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["hobby_view_history"]>



  export type hobby_view_historySelectScalar = {
    hobby_view_history_id?: boolean
    hobby_post_id?: boolean
    user_id?: boolean
    category?: boolean
    created_at?: boolean
    modified_at?: boolean
    created_by?: boolean
    modified_by?: boolean
    deleted?: boolean
  }

  export type hobby_view_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hobby_view_history_id" | "hobby_post_id" | "user_id" | "category" | "created_at" | "modified_at" | "created_by" | "modified_by" | "deleted", ExtArgs["result"]["hobby_view_history"]>

  export type $hobby_view_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hobby_view_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      hobby_view_history_id: bigint
      hobby_post_id: bigint
      user_id: bigint
      category: $Enums.hobby_view_history_category
      created_at: Date
      modified_at: Date
      created_by: bigint
      modified_by: bigint
      deleted: boolean
    }, ExtArgs["result"]["hobby_view_history"]>
    composites: {}
  }

  type hobby_view_historyGetPayload<S extends boolean | null | undefined | hobby_view_historyDefaultArgs> = $Result.GetResult<Prisma.$hobby_view_historyPayload, S>

  type hobby_view_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hobby_view_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Hobby_view_historyCountAggregateInputType | true
    }

  export interface hobby_view_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hobby_view_history'], meta: { name: 'hobby_view_history' } }
    /**
     * Find zero or one Hobby_view_history that matches the filter.
     * @param {hobby_view_historyFindUniqueArgs} args - Arguments to find a Hobby_view_history
     * @example
     * // Get one Hobby_view_history
     * const hobby_view_history = await prisma.hobby_view_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hobby_view_historyFindUniqueArgs>(args: SelectSubset<T, hobby_view_historyFindUniqueArgs<ExtArgs>>): Prisma__hobby_view_historyClient<$Result.GetResult<Prisma.$hobby_view_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hobby_view_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hobby_view_historyFindUniqueOrThrowArgs} args - Arguments to find a Hobby_view_history
     * @example
     * // Get one Hobby_view_history
     * const hobby_view_history = await prisma.hobby_view_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hobby_view_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, hobby_view_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hobby_view_historyClient<$Result.GetResult<Prisma.$hobby_view_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_view_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_view_historyFindFirstArgs} args - Arguments to find a Hobby_view_history
     * @example
     * // Get one Hobby_view_history
     * const hobby_view_history = await prisma.hobby_view_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hobby_view_historyFindFirstArgs>(args?: SelectSubset<T, hobby_view_historyFindFirstArgs<ExtArgs>>): Prisma__hobby_view_historyClient<$Result.GetResult<Prisma.$hobby_view_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hobby_view_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_view_historyFindFirstOrThrowArgs} args - Arguments to find a Hobby_view_history
     * @example
     * // Get one Hobby_view_history
     * const hobby_view_history = await prisma.hobby_view_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hobby_view_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, hobby_view_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__hobby_view_historyClient<$Result.GetResult<Prisma.$hobby_view_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hobby_view_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_view_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hobby_view_histories
     * const hobby_view_histories = await prisma.hobby_view_history.findMany()
     * 
     * // Get first 10 Hobby_view_histories
     * const hobby_view_histories = await prisma.hobby_view_history.findMany({ take: 10 })
     * 
     * // Only select the `hobby_view_history_id`
     * const hobby_view_historyWithHobby_view_history_idOnly = await prisma.hobby_view_history.findMany({ select: { hobby_view_history_id: true } })
     * 
     */
    findMany<T extends hobby_view_historyFindManyArgs>(args?: SelectSubset<T, hobby_view_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hobby_view_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hobby_view_history.
     * @param {hobby_view_historyCreateArgs} args - Arguments to create a Hobby_view_history.
     * @example
     * // Create one Hobby_view_history
     * const Hobby_view_history = await prisma.hobby_view_history.create({
     *   data: {
     *     // ... data to create a Hobby_view_history
     *   }
     * })
     * 
     */
    create<T extends hobby_view_historyCreateArgs>(args: SelectSubset<T, hobby_view_historyCreateArgs<ExtArgs>>): Prisma__hobby_view_historyClient<$Result.GetResult<Prisma.$hobby_view_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hobby_view_histories.
     * @param {hobby_view_historyCreateManyArgs} args - Arguments to create many Hobby_view_histories.
     * @example
     * // Create many Hobby_view_histories
     * const hobby_view_history = await prisma.hobby_view_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hobby_view_historyCreateManyArgs>(args?: SelectSubset<T, hobby_view_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hobby_view_history.
     * @param {hobby_view_historyDeleteArgs} args - Arguments to delete one Hobby_view_history.
     * @example
     * // Delete one Hobby_view_history
     * const Hobby_view_history = await prisma.hobby_view_history.delete({
     *   where: {
     *     // ... filter to delete one Hobby_view_history
     *   }
     * })
     * 
     */
    delete<T extends hobby_view_historyDeleteArgs>(args: SelectSubset<T, hobby_view_historyDeleteArgs<ExtArgs>>): Prisma__hobby_view_historyClient<$Result.GetResult<Prisma.$hobby_view_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hobby_view_history.
     * @param {hobby_view_historyUpdateArgs} args - Arguments to update one Hobby_view_history.
     * @example
     * // Update one Hobby_view_history
     * const hobby_view_history = await prisma.hobby_view_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hobby_view_historyUpdateArgs>(args: SelectSubset<T, hobby_view_historyUpdateArgs<ExtArgs>>): Prisma__hobby_view_historyClient<$Result.GetResult<Prisma.$hobby_view_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hobby_view_histories.
     * @param {hobby_view_historyDeleteManyArgs} args - Arguments to filter Hobby_view_histories to delete.
     * @example
     * // Delete a few Hobby_view_histories
     * const { count } = await prisma.hobby_view_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hobby_view_historyDeleteManyArgs>(args?: SelectSubset<T, hobby_view_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hobby_view_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_view_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hobby_view_histories
     * const hobby_view_history = await prisma.hobby_view_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hobby_view_historyUpdateManyArgs>(args: SelectSubset<T, hobby_view_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hobby_view_history.
     * @param {hobby_view_historyUpsertArgs} args - Arguments to update or create a Hobby_view_history.
     * @example
     * // Update or create a Hobby_view_history
     * const hobby_view_history = await prisma.hobby_view_history.upsert({
     *   create: {
     *     // ... data to create a Hobby_view_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hobby_view_history we want to update
     *   }
     * })
     */
    upsert<T extends hobby_view_historyUpsertArgs>(args: SelectSubset<T, hobby_view_historyUpsertArgs<ExtArgs>>): Prisma__hobby_view_historyClient<$Result.GetResult<Prisma.$hobby_view_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hobby_view_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_view_historyCountArgs} args - Arguments to filter Hobby_view_histories to count.
     * @example
     * // Count the number of Hobby_view_histories
     * const count = await prisma.hobby_view_history.count({
     *   where: {
     *     // ... the filter for the Hobby_view_histories we want to count
     *   }
     * })
    **/
    count<T extends hobby_view_historyCountArgs>(
      args?: Subset<T, hobby_view_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hobby_view_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hobby_view_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hobby_view_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hobby_view_historyAggregateArgs>(args: Subset<T, Hobby_view_historyAggregateArgs>): Prisma.PrismaPromise<GetHobby_view_historyAggregateType<T>>

    /**
     * Group by Hobby_view_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hobby_view_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hobby_view_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hobby_view_historyGroupByArgs['orderBy'] }
        : { orderBy?: hobby_view_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hobby_view_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHobby_view_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hobby_view_history model
   */
  readonly fields: hobby_view_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hobby_view_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hobby_view_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hobby_view_history model
   */
  interface hobby_view_historyFieldRefs {
    readonly hobby_view_history_id: FieldRef<"hobby_view_history", 'BigInt'>
    readonly hobby_post_id: FieldRef<"hobby_view_history", 'BigInt'>
    readonly user_id: FieldRef<"hobby_view_history", 'BigInt'>
    readonly category: FieldRef<"hobby_view_history", 'hobby_view_history_category'>
    readonly created_at: FieldRef<"hobby_view_history", 'DateTime'>
    readonly modified_at: FieldRef<"hobby_view_history", 'DateTime'>
    readonly created_by: FieldRef<"hobby_view_history", 'BigInt'>
    readonly modified_by: FieldRef<"hobby_view_history", 'BigInt'>
    readonly deleted: FieldRef<"hobby_view_history", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * hobby_view_history findUnique
   */
  export type hobby_view_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_view_history
     */
    select?: hobby_view_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_view_history
     */
    omit?: hobby_view_historyOmit<ExtArgs> | null
    /**
     * Filter, which hobby_view_history to fetch.
     */
    where: hobby_view_historyWhereUniqueInput
  }

  /**
   * hobby_view_history findUniqueOrThrow
   */
  export type hobby_view_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_view_history
     */
    select?: hobby_view_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_view_history
     */
    omit?: hobby_view_historyOmit<ExtArgs> | null
    /**
     * Filter, which hobby_view_history to fetch.
     */
    where: hobby_view_historyWhereUniqueInput
  }

  /**
   * hobby_view_history findFirst
   */
  export type hobby_view_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_view_history
     */
    select?: hobby_view_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_view_history
     */
    omit?: hobby_view_historyOmit<ExtArgs> | null
    /**
     * Filter, which hobby_view_history to fetch.
     */
    where?: hobby_view_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_view_histories to fetch.
     */
    orderBy?: hobby_view_historyOrderByWithRelationInput | hobby_view_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_view_histories.
     */
    cursor?: hobby_view_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_view_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_view_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_view_histories.
     */
    distinct?: Hobby_view_historyScalarFieldEnum | Hobby_view_historyScalarFieldEnum[]
  }

  /**
   * hobby_view_history findFirstOrThrow
   */
  export type hobby_view_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_view_history
     */
    select?: hobby_view_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_view_history
     */
    omit?: hobby_view_historyOmit<ExtArgs> | null
    /**
     * Filter, which hobby_view_history to fetch.
     */
    where?: hobby_view_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_view_histories to fetch.
     */
    orderBy?: hobby_view_historyOrderByWithRelationInput | hobby_view_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hobby_view_histories.
     */
    cursor?: hobby_view_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_view_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_view_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hobby_view_histories.
     */
    distinct?: Hobby_view_historyScalarFieldEnum | Hobby_view_historyScalarFieldEnum[]
  }

  /**
   * hobby_view_history findMany
   */
  export type hobby_view_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_view_history
     */
    select?: hobby_view_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_view_history
     */
    omit?: hobby_view_historyOmit<ExtArgs> | null
    /**
     * Filter, which hobby_view_histories to fetch.
     */
    where?: hobby_view_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hobby_view_histories to fetch.
     */
    orderBy?: hobby_view_historyOrderByWithRelationInput | hobby_view_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hobby_view_histories.
     */
    cursor?: hobby_view_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hobby_view_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hobby_view_histories.
     */
    skip?: number
    distinct?: Hobby_view_historyScalarFieldEnum | Hobby_view_historyScalarFieldEnum[]
  }

  /**
   * hobby_view_history create
   */
  export type hobby_view_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_view_history
     */
    select?: hobby_view_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_view_history
     */
    omit?: hobby_view_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a hobby_view_history.
     */
    data: XOR<hobby_view_historyCreateInput, hobby_view_historyUncheckedCreateInput>
  }

  /**
   * hobby_view_history createMany
   */
  export type hobby_view_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hobby_view_histories.
     */
    data: hobby_view_historyCreateManyInput | hobby_view_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hobby_view_history update
   */
  export type hobby_view_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_view_history
     */
    select?: hobby_view_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_view_history
     */
    omit?: hobby_view_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a hobby_view_history.
     */
    data: XOR<hobby_view_historyUpdateInput, hobby_view_historyUncheckedUpdateInput>
    /**
     * Choose, which hobby_view_history to update.
     */
    where: hobby_view_historyWhereUniqueInput
  }

  /**
   * hobby_view_history updateMany
   */
  export type hobby_view_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hobby_view_histories.
     */
    data: XOR<hobby_view_historyUpdateManyMutationInput, hobby_view_historyUncheckedUpdateManyInput>
    /**
     * Filter which hobby_view_histories to update
     */
    where?: hobby_view_historyWhereInput
    /**
     * Limit how many hobby_view_histories to update.
     */
    limit?: number
  }

  /**
   * hobby_view_history upsert
   */
  export type hobby_view_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_view_history
     */
    select?: hobby_view_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_view_history
     */
    omit?: hobby_view_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the hobby_view_history to update in case it exists.
     */
    where: hobby_view_historyWhereUniqueInput
    /**
     * In case the hobby_view_history found by the `where` argument doesn't exist, create a new hobby_view_history with this data.
     */
    create: XOR<hobby_view_historyCreateInput, hobby_view_historyUncheckedCreateInput>
    /**
     * In case the hobby_view_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hobby_view_historyUpdateInput, hobby_view_historyUncheckedUpdateInput>
  }

  /**
   * hobby_view_history delete
   */
  export type hobby_view_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_view_history
     */
    select?: hobby_view_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_view_history
     */
    omit?: hobby_view_historyOmit<ExtArgs> | null
    /**
     * Filter which hobby_view_history to delete.
     */
    where: hobby_view_historyWhereUniqueInput
  }

  /**
   * hobby_view_history deleteMany
   */
  export type hobby_view_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hobby_view_histories to delete
     */
    where?: hobby_view_historyWhereInput
    /**
     * Limit how many hobby_view_histories to delete.
     */
    limit?: number
  }

  /**
   * hobby_view_history without action
   */
  export type hobby_view_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hobby_view_history
     */
    select?: hobby_view_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the hobby_view_history
     */
    omit?: hobby_view_historyOmit<ExtArgs> | null
  }


  /**
   * Model item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    item_id: number | null
    bag_id: number | null
  }

  export type ItemSumAggregateOutputType = {
    item_id: bigint | null
    bag_id: bigint | null
  }

  export type ItemMinAggregateOutputType = {
    item_id: bigint | null
    item_name: string | null
    bag_id: bigint | null
  }

  export type ItemMaxAggregateOutputType = {
    item_id: bigint | null
    item_name: string | null
    bag_id: bigint | null
  }

  export type ItemCountAggregateOutputType = {
    item_id: number
    item_name: number
    bag_id: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    item_id?: true
    bag_id?: true
  }

  export type ItemSumAggregateInputType = {
    item_id?: true
    bag_id?: true
  }

  export type ItemMinAggregateInputType = {
    item_id?: true
    item_name?: true
    bag_id?: true
  }

  export type ItemMaxAggregateInputType = {
    item_id?: true
    item_name?: true
    bag_id?: true
  }

  export type ItemCountAggregateInputType = {
    item_id?: true
    item_name?: true
    bag_id?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which item to aggregate.
     */
    where?: itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemOrderByWithRelationInput | itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type itemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemWhereInput
    orderBy?: itemOrderByWithAggregationInput | itemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    item_id: bigint
    item_name: string | null
    bag_id: bigint | null
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type itemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    item_id?: boolean
    item_name?: boolean
    bag_id?: boolean
  }, ExtArgs["result"]["item"]>



  export type itemSelectScalar = {
    item_id?: boolean
    item_name?: boolean
    bag_id?: boolean
  }

  export type itemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"item_id" | "item_name" | "bag_id", ExtArgs["result"]["item"]>

  export type $itemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "item"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      item_id: bigint
      item_name: string | null
      bag_id: bigint | null
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type itemGetPayload<S extends boolean | null | undefined | itemDefaultArgs> = $Result.GetResult<Prisma.$itemPayload, S>

  type itemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<itemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface itemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['item'], meta: { name: 'item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {itemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itemFindUniqueArgs>(args: SelectSubset<T, itemFindUniqueArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {itemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itemFindUniqueOrThrowArgs>(args: SelectSubset<T, itemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itemFindFirstArgs>(args?: SelectSubset<T, itemFindFirstArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itemFindFirstOrThrowArgs>(args?: SelectSubset<T, itemFindFirstOrThrowArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `item_id`
     * const itemWithItem_idOnly = await prisma.item.findMany({ select: { item_id: true } })
     * 
     */
    findMany<T extends itemFindManyArgs>(args?: SelectSubset<T, itemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {itemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends itemCreateArgs>(args: SelectSubset<T, itemCreateArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {itemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends itemCreateManyArgs>(args?: SelectSubset<T, itemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item.
     * @param {itemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends itemDeleteArgs>(args: SelectSubset<T, itemDeleteArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {itemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends itemUpdateArgs>(args: SelectSubset<T, itemUpdateArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {itemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends itemDeleteManyArgs>(args?: SelectSubset<T, itemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends itemUpdateManyArgs>(args: SelectSubset<T, itemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {itemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends itemUpsertArgs>(args: SelectSubset<T, itemUpsertArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends itemCountArgs>(
      args?: Subset<T, itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itemGroupByArgs['orderBy'] }
        : { orderBy?: itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the item model
   */
  readonly fields: itemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the item model
   */
  interface itemFieldRefs {
    readonly item_id: FieldRef<"item", 'BigInt'>
    readonly item_name: FieldRef<"item", 'String'>
    readonly bag_id: FieldRef<"item", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * item findUnique
   */
  export type itemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Filter, which item to fetch.
     */
    where: itemWhereUniqueInput
  }

  /**
   * item findUniqueOrThrow
   */
  export type itemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Filter, which item to fetch.
     */
    where: itemWhereUniqueInput
  }

  /**
   * item findFirst
   */
  export type itemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Filter, which item to fetch.
     */
    where?: itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemOrderByWithRelationInput | itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * item findFirstOrThrow
   */
  export type itemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Filter, which item to fetch.
     */
    where?: itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemOrderByWithRelationInput | itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * item findMany
   */
  export type itemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemOrderByWithRelationInput | itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing items.
     */
    cursor?: itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * item create
   */
  export type itemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * The data needed to create a item.
     */
    data?: XOR<itemCreateInput, itemUncheckedCreateInput>
  }

  /**
   * item createMany
   */
  export type itemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many items.
     */
    data: itemCreateManyInput | itemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * item update
   */
  export type itemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * The data needed to update a item.
     */
    data: XOR<itemUpdateInput, itemUncheckedUpdateInput>
    /**
     * Choose, which item to update.
     */
    where: itemWhereUniqueInput
  }

  /**
   * item updateMany
   */
  export type itemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update items.
     */
    data: XOR<itemUpdateManyMutationInput, itemUncheckedUpdateManyInput>
    /**
     * Filter which items to update
     */
    where?: itemWhereInput
    /**
     * Limit how many items to update.
     */
    limit?: number
  }

  /**
   * item upsert
   */
  export type itemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * The filter to search for the item to update in case it exists.
     */
    where: itemWhereUniqueInput
    /**
     * In case the item found by the `where` argument doesn't exist, create a new item with this data.
     */
    create: XOR<itemCreateInput, itemUncheckedCreateInput>
    /**
     * In case the item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemUpdateInput, itemUncheckedUpdateInput>
  }

  /**
   * item delete
   */
  export type itemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Filter which item to delete.
     */
    where: itemWhereUniqueInput
  }

  /**
   * item deleteMany
   */
  export type itemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items to delete
     */
    where?: itemWhereInput
    /**
     * Limit how many items to delete.
     */
    limit?: number
  }

  /**
   * item without action
   */
  export type itemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
  }


  /**
   * Model member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberAvgAggregateOutputType = {
    studentId: number | null
  }

  export type MemberSumAggregateOutputType = {
    studentId: bigint | null
  }

  export type MemberMinAggregateOutputType = {
    studentId: bigint | null
    studentName: string | null
    studentEmail: string | null
  }

  export type MemberMaxAggregateOutputType = {
    studentId: bigint | null
    studentName: string | null
    studentEmail: string | null
  }

  export type MemberCountAggregateOutputType = {
    studentId: number
    studentName: number
    studentEmail: number
    _all: number
  }


  export type MemberAvgAggregateInputType = {
    studentId?: true
  }

  export type MemberSumAggregateInputType = {
    studentId?: true
  }

  export type MemberMinAggregateInputType = {
    studentId?: true
    studentName?: true
    studentEmail?: true
  }

  export type MemberMaxAggregateInputType = {
    studentId?: true
    studentName?: true
    studentEmail?: true
  }

  export type MemberCountAggregateInputType = {
    studentId?: true
    studentName?: true
    studentEmail?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which member to aggregate.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: memberOrderByWithRelationInput | memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type memberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: memberWhereInput
    orderBy?: memberOrderByWithAggregationInput | memberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: memberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _avg?: MemberAvgAggregateInputType
    _sum?: MemberSumAggregateInputType
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    studentId: bigint
    studentName: string | null
    studentEmail: string | null
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends memberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type memberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    studentId?: boolean
    studentName?: boolean
    studentEmail?: boolean
  }, ExtArgs["result"]["member"]>



  export type memberSelectScalar = {
    studentId?: boolean
    studentName?: boolean
    studentEmail?: boolean
  }

  export type memberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"studentId" | "studentName" | "studentEmail", ExtArgs["result"]["member"]>

  export type $memberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "member"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      studentId: bigint
      studentName: string | null
      studentEmail: string | null
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type memberGetPayload<S extends boolean | null | undefined | memberDefaultArgs> = $Result.GetResult<Prisma.$memberPayload, S>

  type memberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<memberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface memberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['member'], meta: { name: 'member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {memberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends memberFindUniqueArgs>(args: SelectSubset<T, memberFindUniqueArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {memberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends memberFindUniqueOrThrowArgs>(args: SelectSubset<T, memberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends memberFindFirstArgs>(args?: SelectSubset<T, memberFindFirstArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends memberFindFirstOrThrowArgs>(args?: SelectSubset<T, memberFindFirstOrThrowArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `studentId`
     * const memberWithStudentIdOnly = await prisma.member.findMany({ select: { studentId: true } })
     * 
     */
    findMany<T extends memberFindManyArgs>(args?: SelectSubset<T, memberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {memberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends memberCreateArgs>(args: SelectSubset<T, memberCreateArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {memberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends memberCreateManyArgs>(args?: SelectSubset<T, memberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Member.
     * @param {memberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends memberDeleteArgs>(args: SelectSubset<T, memberDeleteArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {memberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends memberUpdateArgs>(args: SelectSubset<T, memberUpdateArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {memberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends memberDeleteManyArgs>(args?: SelectSubset<T, memberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends memberUpdateManyArgs>(args: SelectSubset<T, memberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member.
     * @param {memberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends memberUpsertArgs>(args: SelectSubset<T, memberUpsertArgs<ExtArgs>>): Prisma__memberClient<$Result.GetResult<Prisma.$memberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends memberCountArgs>(
      args?: Subset<T, memberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends memberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: memberGroupByArgs['orderBy'] }
        : { orderBy?: memberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, memberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the member model
   */
  readonly fields: memberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__memberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the member model
   */
  interface memberFieldRefs {
    readonly studentId: FieldRef<"member", 'BigInt'>
    readonly studentName: FieldRef<"member", 'String'>
    readonly studentEmail: FieldRef<"member", 'String'>
  }
    

  // Custom InputTypes
  /**
   * member findUnique
   */
  export type memberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Filter, which member to fetch.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member findUniqueOrThrow
   */
  export type memberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Filter, which member to fetch.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member findFirst
   */
  export type memberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Filter, which member to fetch.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: memberOrderByWithRelationInput | memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for members.
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * member findFirstOrThrow
   */
  export type memberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Filter, which member to fetch.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: memberOrderByWithRelationInput | memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for members.
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * member findMany
   */
  export type memberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Filter, which members to fetch.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: memberOrderByWithRelationInput | memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing members.
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * member create
   */
  export type memberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * The data needed to create a member.
     */
    data?: XOR<memberCreateInput, memberUncheckedCreateInput>
  }

  /**
   * member createMany
   */
  export type memberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many members.
     */
    data: memberCreateManyInput | memberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * member update
   */
  export type memberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * The data needed to update a member.
     */
    data: XOR<memberUpdateInput, memberUncheckedUpdateInput>
    /**
     * Choose, which member to update.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member updateMany
   */
  export type memberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update members.
     */
    data: XOR<memberUpdateManyMutationInput, memberUncheckedUpdateManyInput>
    /**
     * Filter which members to update
     */
    where?: memberWhereInput
    /**
     * Limit how many members to update.
     */
    limit?: number
  }

  /**
   * member upsert
   */
  export type memberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * The filter to search for the member to update in case it exists.
     */
    where: memberWhereUniqueInput
    /**
     * In case the member found by the `where` argument doesn't exist, create a new member with this data.
     */
    create: XOR<memberCreateInput, memberUncheckedCreateInput>
    /**
     * In case the member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<memberUpdateInput, memberUncheckedUpdateInput>
  }

  /**
   * member delete
   */
  export type memberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
    /**
     * Filter which member to delete.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member deleteMany
   */
  export type memberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which members to delete
     */
    where?: memberWhereInput
    /**
     * Limit how many members to delete.
     */
    limit?: number
  }

  /**
   * member without action
   */
  export type memberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the member
     */
    omit?: memberOmit<ExtArgs> | null
  }


  /**
   * Model policy_agree
   */

  export type AggregatePolicy_agree = {
    _count: Policy_agreeCountAggregateOutputType | null
    _avg: Policy_agreeAvgAggregateOutputType | null
    _sum: Policy_agreeSumAggregateOutputType | null
    _min: Policy_agreeMinAggregateOutputType | null
    _max: Policy_agreeMaxAggregateOutputType | null
  }

  export type Policy_agreeAvgAggregateOutputType = {
    policy_agree_id: number | null
    policy_history_id: number | null
    user_id: number | null
  }

  export type Policy_agreeSumAggregateOutputType = {
    policy_agree_id: bigint | null
    policy_history_id: bigint | null
    user_id: bigint | null
  }

  export type Policy_agreeMinAggregateOutputType = {
    policy_agree_id: bigint | null
    policy_type: $Enums.policy_agree_policy_type | null
    policy_history_id: bigint | null
    user_id: bigint | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type Policy_agreeMaxAggregateOutputType = {
    policy_agree_id: bigint | null
    policy_type: $Enums.policy_agree_policy_type | null
    policy_history_id: bigint | null
    user_id: bigint | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type Policy_agreeCountAggregateOutputType = {
    policy_agree_id: number
    policy_type: number
    policy_history_id: number
    user_id: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type Policy_agreeAvgAggregateInputType = {
    policy_agree_id?: true
    policy_history_id?: true
    user_id?: true
  }

  export type Policy_agreeSumAggregateInputType = {
    policy_agree_id?: true
    policy_history_id?: true
    user_id?: true
  }

  export type Policy_agreeMinAggregateInputType = {
    policy_agree_id?: true
    policy_type?: true
    policy_history_id?: true
    user_id?: true
    created_at?: true
    modified_at?: true
  }

  export type Policy_agreeMaxAggregateInputType = {
    policy_agree_id?: true
    policy_type?: true
    policy_history_id?: true
    user_id?: true
    created_at?: true
    modified_at?: true
  }

  export type Policy_agreeCountAggregateInputType = {
    policy_agree_id?: true
    policy_type?: true
    policy_history_id?: true
    user_id?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type Policy_agreeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which policy_agree to aggregate.
     */
    where?: policy_agreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of policy_agrees to fetch.
     */
    orderBy?: policy_agreeOrderByWithRelationInput | policy_agreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: policy_agreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` policy_agrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` policy_agrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned policy_agrees
    **/
    _count?: true | Policy_agreeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Policy_agreeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Policy_agreeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Policy_agreeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Policy_agreeMaxAggregateInputType
  }

  export type GetPolicy_agreeAggregateType<T extends Policy_agreeAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicy_agree]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicy_agree[P]>
      : GetScalarType<T[P], AggregatePolicy_agree[P]>
  }




  export type policy_agreeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: policy_agreeWhereInput
    orderBy?: policy_agreeOrderByWithAggregationInput | policy_agreeOrderByWithAggregationInput[]
    by: Policy_agreeScalarFieldEnum[] | Policy_agreeScalarFieldEnum
    having?: policy_agreeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Policy_agreeCountAggregateInputType | true
    _avg?: Policy_agreeAvgAggregateInputType
    _sum?: Policy_agreeSumAggregateInputType
    _min?: Policy_agreeMinAggregateInputType
    _max?: Policy_agreeMaxAggregateInputType
  }

  export type Policy_agreeGroupByOutputType = {
    policy_agree_id: bigint
    policy_type: $Enums.policy_agree_policy_type
    policy_history_id: bigint
    user_id: bigint
    created_at: Date
    modified_at: Date
    _count: Policy_agreeCountAggregateOutputType | null
    _avg: Policy_agreeAvgAggregateOutputType | null
    _sum: Policy_agreeSumAggregateOutputType | null
    _min: Policy_agreeMinAggregateOutputType | null
    _max: Policy_agreeMaxAggregateOutputType | null
  }

  type GetPolicy_agreeGroupByPayload<T extends policy_agreeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Policy_agreeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Policy_agreeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Policy_agreeGroupByOutputType[P]>
            : GetScalarType<T[P], Policy_agreeGroupByOutputType[P]>
        }
      >
    >


  export type policy_agreeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    policy_agree_id?: boolean
    policy_type?: boolean
    policy_history_id?: boolean
    user_id?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["policy_agree"]>



  export type policy_agreeSelectScalar = {
    policy_agree_id?: boolean
    policy_type?: boolean
    policy_history_id?: boolean
    user_id?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type policy_agreeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"policy_agree_id" | "policy_type" | "policy_history_id" | "user_id" | "created_at" | "modified_at", ExtArgs["result"]["policy_agree"]>

  export type $policy_agreePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "policy_agree"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      policy_agree_id: bigint
      policy_type: $Enums.policy_agree_policy_type
      policy_history_id: bigint
      user_id: bigint
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["policy_agree"]>
    composites: {}
  }

  type policy_agreeGetPayload<S extends boolean | null | undefined | policy_agreeDefaultArgs> = $Result.GetResult<Prisma.$policy_agreePayload, S>

  type policy_agreeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<policy_agreeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Policy_agreeCountAggregateInputType | true
    }

  export interface policy_agreeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['policy_agree'], meta: { name: 'policy_agree' } }
    /**
     * Find zero or one Policy_agree that matches the filter.
     * @param {policy_agreeFindUniqueArgs} args - Arguments to find a Policy_agree
     * @example
     * // Get one Policy_agree
     * const policy_agree = await prisma.policy_agree.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends policy_agreeFindUniqueArgs>(args: SelectSubset<T, policy_agreeFindUniqueArgs<ExtArgs>>): Prisma__policy_agreeClient<$Result.GetResult<Prisma.$policy_agreePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Policy_agree that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {policy_agreeFindUniqueOrThrowArgs} args - Arguments to find a Policy_agree
     * @example
     * // Get one Policy_agree
     * const policy_agree = await prisma.policy_agree.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends policy_agreeFindUniqueOrThrowArgs>(args: SelectSubset<T, policy_agreeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__policy_agreeClient<$Result.GetResult<Prisma.$policy_agreePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Policy_agree that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policy_agreeFindFirstArgs} args - Arguments to find a Policy_agree
     * @example
     * // Get one Policy_agree
     * const policy_agree = await prisma.policy_agree.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends policy_agreeFindFirstArgs>(args?: SelectSubset<T, policy_agreeFindFirstArgs<ExtArgs>>): Prisma__policy_agreeClient<$Result.GetResult<Prisma.$policy_agreePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Policy_agree that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policy_agreeFindFirstOrThrowArgs} args - Arguments to find a Policy_agree
     * @example
     * // Get one Policy_agree
     * const policy_agree = await prisma.policy_agree.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends policy_agreeFindFirstOrThrowArgs>(args?: SelectSubset<T, policy_agreeFindFirstOrThrowArgs<ExtArgs>>): Prisma__policy_agreeClient<$Result.GetResult<Prisma.$policy_agreePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Policy_agrees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policy_agreeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policy_agrees
     * const policy_agrees = await prisma.policy_agree.findMany()
     * 
     * // Get first 10 Policy_agrees
     * const policy_agrees = await prisma.policy_agree.findMany({ take: 10 })
     * 
     * // Only select the `policy_agree_id`
     * const policy_agreeWithPolicy_agree_idOnly = await prisma.policy_agree.findMany({ select: { policy_agree_id: true } })
     * 
     */
    findMany<T extends policy_agreeFindManyArgs>(args?: SelectSubset<T, policy_agreeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$policy_agreePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Policy_agree.
     * @param {policy_agreeCreateArgs} args - Arguments to create a Policy_agree.
     * @example
     * // Create one Policy_agree
     * const Policy_agree = await prisma.policy_agree.create({
     *   data: {
     *     // ... data to create a Policy_agree
     *   }
     * })
     * 
     */
    create<T extends policy_agreeCreateArgs>(args: SelectSubset<T, policy_agreeCreateArgs<ExtArgs>>): Prisma__policy_agreeClient<$Result.GetResult<Prisma.$policy_agreePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Policy_agrees.
     * @param {policy_agreeCreateManyArgs} args - Arguments to create many Policy_agrees.
     * @example
     * // Create many Policy_agrees
     * const policy_agree = await prisma.policy_agree.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends policy_agreeCreateManyArgs>(args?: SelectSubset<T, policy_agreeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Policy_agree.
     * @param {policy_agreeDeleteArgs} args - Arguments to delete one Policy_agree.
     * @example
     * // Delete one Policy_agree
     * const Policy_agree = await prisma.policy_agree.delete({
     *   where: {
     *     // ... filter to delete one Policy_agree
     *   }
     * })
     * 
     */
    delete<T extends policy_agreeDeleteArgs>(args: SelectSubset<T, policy_agreeDeleteArgs<ExtArgs>>): Prisma__policy_agreeClient<$Result.GetResult<Prisma.$policy_agreePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Policy_agree.
     * @param {policy_agreeUpdateArgs} args - Arguments to update one Policy_agree.
     * @example
     * // Update one Policy_agree
     * const policy_agree = await prisma.policy_agree.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends policy_agreeUpdateArgs>(args: SelectSubset<T, policy_agreeUpdateArgs<ExtArgs>>): Prisma__policy_agreeClient<$Result.GetResult<Prisma.$policy_agreePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Policy_agrees.
     * @param {policy_agreeDeleteManyArgs} args - Arguments to filter Policy_agrees to delete.
     * @example
     * // Delete a few Policy_agrees
     * const { count } = await prisma.policy_agree.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends policy_agreeDeleteManyArgs>(args?: SelectSubset<T, policy_agreeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policy_agrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policy_agreeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policy_agrees
     * const policy_agree = await prisma.policy_agree.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends policy_agreeUpdateManyArgs>(args: SelectSubset<T, policy_agreeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Policy_agree.
     * @param {policy_agreeUpsertArgs} args - Arguments to update or create a Policy_agree.
     * @example
     * // Update or create a Policy_agree
     * const policy_agree = await prisma.policy_agree.upsert({
     *   create: {
     *     // ... data to create a Policy_agree
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policy_agree we want to update
     *   }
     * })
     */
    upsert<T extends policy_agreeUpsertArgs>(args: SelectSubset<T, policy_agreeUpsertArgs<ExtArgs>>): Prisma__policy_agreeClient<$Result.GetResult<Prisma.$policy_agreePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Policy_agrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policy_agreeCountArgs} args - Arguments to filter Policy_agrees to count.
     * @example
     * // Count the number of Policy_agrees
     * const count = await prisma.policy_agree.count({
     *   where: {
     *     // ... the filter for the Policy_agrees we want to count
     *   }
     * })
    **/
    count<T extends policy_agreeCountArgs>(
      args?: Subset<T, policy_agreeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Policy_agreeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policy_agree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Policy_agreeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Policy_agreeAggregateArgs>(args: Subset<T, Policy_agreeAggregateArgs>): Prisma.PrismaPromise<GetPolicy_agreeAggregateType<T>>

    /**
     * Group by Policy_agree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policy_agreeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends policy_agreeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: policy_agreeGroupByArgs['orderBy'] }
        : { orderBy?: policy_agreeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, policy_agreeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicy_agreeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the policy_agree model
   */
  readonly fields: policy_agreeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for policy_agree.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__policy_agreeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the policy_agree model
   */
  interface policy_agreeFieldRefs {
    readonly policy_agree_id: FieldRef<"policy_agree", 'BigInt'>
    readonly policy_type: FieldRef<"policy_agree", 'policy_agree_policy_type'>
    readonly policy_history_id: FieldRef<"policy_agree", 'BigInt'>
    readonly user_id: FieldRef<"policy_agree", 'BigInt'>
    readonly created_at: FieldRef<"policy_agree", 'DateTime'>
    readonly modified_at: FieldRef<"policy_agree", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * policy_agree findUnique
   */
  export type policy_agreeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_agree
     */
    select?: policy_agreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_agree
     */
    omit?: policy_agreeOmit<ExtArgs> | null
    /**
     * Filter, which policy_agree to fetch.
     */
    where: policy_agreeWhereUniqueInput
  }

  /**
   * policy_agree findUniqueOrThrow
   */
  export type policy_agreeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_agree
     */
    select?: policy_agreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_agree
     */
    omit?: policy_agreeOmit<ExtArgs> | null
    /**
     * Filter, which policy_agree to fetch.
     */
    where: policy_agreeWhereUniqueInput
  }

  /**
   * policy_agree findFirst
   */
  export type policy_agreeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_agree
     */
    select?: policy_agreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_agree
     */
    omit?: policy_agreeOmit<ExtArgs> | null
    /**
     * Filter, which policy_agree to fetch.
     */
    where?: policy_agreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of policy_agrees to fetch.
     */
    orderBy?: policy_agreeOrderByWithRelationInput | policy_agreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for policy_agrees.
     */
    cursor?: policy_agreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` policy_agrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` policy_agrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of policy_agrees.
     */
    distinct?: Policy_agreeScalarFieldEnum | Policy_agreeScalarFieldEnum[]
  }

  /**
   * policy_agree findFirstOrThrow
   */
  export type policy_agreeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_agree
     */
    select?: policy_agreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_agree
     */
    omit?: policy_agreeOmit<ExtArgs> | null
    /**
     * Filter, which policy_agree to fetch.
     */
    where?: policy_agreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of policy_agrees to fetch.
     */
    orderBy?: policy_agreeOrderByWithRelationInput | policy_agreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for policy_agrees.
     */
    cursor?: policy_agreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` policy_agrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` policy_agrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of policy_agrees.
     */
    distinct?: Policy_agreeScalarFieldEnum | Policy_agreeScalarFieldEnum[]
  }

  /**
   * policy_agree findMany
   */
  export type policy_agreeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_agree
     */
    select?: policy_agreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_agree
     */
    omit?: policy_agreeOmit<ExtArgs> | null
    /**
     * Filter, which policy_agrees to fetch.
     */
    where?: policy_agreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of policy_agrees to fetch.
     */
    orderBy?: policy_agreeOrderByWithRelationInput | policy_agreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing policy_agrees.
     */
    cursor?: policy_agreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` policy_agrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` policy_agrees.
     */
    skip?: number
    distinct?: Policy_agreeScalarFieldEnum | Policy_agreeScalarFieldEnum[]
  }

  /**
   * policy_agree create
   */
  export type policy_agreeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_agree
     */
    select?: policy_agreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_agree
     */
    omit?: policy_agreeOmit<ExtArgs> | null
    /**
     * The data needed to create a policy_agree.
     */
    data: XOR<policy_agreeCreateInput, policy_agreeUncheckedCreateInput>
  }

  /**
   * policy_agree createMany
   */
  export type policy_agreeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many policy_agrees.
     */
    data: policy_agreeCreateManyInput | policy_agreeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * policy_agree update
   */
  export type policy_agreeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_agree
     */
    select?: policy_agreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_agree
     */
    omit?: policy_agreeOmit<ExtArgs> | null
    /**
     * The data needed to update a policy_agree.
     */
    data: XOR<policy_agreeUpdateInput, policy_agreeUncheckedUpdateInput>
    /**
     * Choose, which policy_agree to update.
     */
    where: policy_agreeWhereUniqueInput
  }

  /**
   * policy_agree updateMany
   */
  export type policy_agreeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update policy_agrees.
     */
    data: XOR<policy_agreeUpdateManyMutationInput, policy_agreeUncheckedUpdateManyInput>
    /**
     * Filter which policy_agrees to update
     */
    where?: policy_agreeWhereInput
    /**
     * Limit how many policy_agrees to update.
     */
    limit?: number
  }

  /**
   * policy_agree upsert
   */
  export type policy_agreeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_agree
     */
    select?: policy_agreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_agree
     */
    omit?: policy_agreeOmit<ExtArgs> | null
    /**
     * The filter to search for the policy_agree to update in case it exists.
     */
    where: policy_agreeWhereUniqueInput
    /**
     * In case the policy_agree found by the `where` argument doesn't exist, create a new policy_agree with this data.
     */
    create: XOR<policy_agreeCreateInput, policy_agreeUncheckedCreateInput>
    /**
     * In case the policy_agree was found with the provided `where` argument, update it with this data.
     */
    update: XOR<policy_agreeUpdateInput, policy_agreeUncheckedUpdateInput>
  }

  /**
   * policy_agree delete
   */
  export type policy_agreeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_agree
     */
    select?: policy_agreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_agree
     */
    omit?: policy_agreeOmit<ExtArgs> | null
    /**
     * Filter which policy_agree to delete.
     */
    where: policy_agreeWhereUniqueInput
  }

  /**
   * policy_agree deleteMany
   */
  export type policy_agreeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which policy_agrees to delete
     */
    where?: policy_agreeWhereInput
    /**
     * Limit how many policy_agrees to delete.
     */
    limit?: number
  }

  /**
   * policy_agree without action
   */
  export type policy_agreeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_agree
     */
    select?: policy_agreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_agree
     */
    omit?: policy_agreeOmit<ExtArgs> | null
  }


  /**
   * Model policy_history
   */

  export type AggregatePolicy_history = {
    _count: Policy_historyCountAggregateOutputType | null
    _avg: Policy_historyAvgAggregateOutputType | null
    _sum: Policy_historySumAggregateOutputType | null
    _min: Policy_historyMinAggregateOutputType | null
    _max: Policy_historyMaxAggregateOutputType | null
  }

  export type Policy_historyAvgAggregateOutputType = {
    policy_history_id: number | null
  }

  export type Policy_historySumAggregateOutputType = {
    policy_history_id: bigint | null
  }

  export type Policy_historyMinAggregateOutputType = {
    policy_history_id: bigint | null
    policy_type: $Enums.policy_history_policy_type | null
    revision_date: Date | null
    pdf_file_path: string | null
    required: boolean | null
    is_latest_revision: boolean | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type Policy_historyMaxAggregateOutputType = {
    policy_history_id: bigint | null
    policy_type: $Enums.policy_history_policy_type | null
    revision_date: Date | null
    pdf_file_path: string | null
    required: boolean | null
    is_latest_revision: boolean | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type Policy_historyCountAggregateOutputType = {
    policy_history_id: number
    policy_type: number
    revision_date: number
    pdf_file_path: number
    required: number
    is_latest_revision: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type Policy_historyAvgAggregateInputType = {
    policy_history_id?: true
  }

  export type Policy_historySumAggregateInputType = {
    policy_history_id?: true
  }

  export type Policy_historyMinAggregateInputType = {
    policy_history_id?: true
    policy_type?: true
    revision_date?: true
    pdf_file_path?: true
    required?: true
    is_latest_revision?: true
    created_at?: true
    modified_at?: true
  }

  export type Policy_historyMaxAggregateInputType = {
    policy_history_id?: true
    policy_type?: true
    revision_date?: true
    pdf_file_path?: true
    required?: true
    is_latest_revision?: true
    created_at?: true
    modified_at?: true
  }

  export type Policy_historyCountAggregateInputType = {
    policy_history_id?: true
    policy_type?: true
    revision_date?: true
    pdf_file_path?: true
    required?: true
    is_latest_revision?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type Policy_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which policy_history to aggregate.
     */
    where?: policy_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of policy_histories to fetch.
     */
    orderBy?: policy_historyOrderByWithRelationInput | policy_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: policy_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` policy_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` policy_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned policy_histories
    **/
    _count?: true | Policy_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Policy_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Policy_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Policy_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Policy_historyMaxAggregateInputType
  }

  export type GetPolicy_historyAggregateType<T extends Policy_historyAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicy_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicy_history[P]>
      : GetScalarType<T[P], AggregatePolicy_history[P]>
  }




  export type policy_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: policy_historyWhereInput
    orderBy?: policy_historyOrderByWithAggregationInput | policy_historyOrderByWithAggregationInput[]
    by: Policy_historyScalarFieldEnum[] | Policy_historyScalarFieldEnum
    having?: policy_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Policy_historyCountAggregateInputType | true
    _avg?: Policy_historyAvgAggregateInputType
    _sum?: Policy_historySumAggregateInputType
    _min?: Policy_historyMinAggregateInputType
    _max?: Policy_historyMaxAggregateInputType
  }

  export type Policy_historyGroupByOutputType = {
    policy_history_id: bigint
    policy_type: $Enums.policy_history_policy_type
    revision_date: Date
    pdf_file_path: string
    required: boolean
    is_latest_revision: boolean
    created_at: Date
    modified_at: Date
    _count: Policy_historyCountAggregateOutputType | null
    _avg: Policy_historyAvgAggregateOutputType | null
    _sum: Policy_historySumAggregateOutputType | null
    _min: Policy_historyMinAggregateOutputType | null
    _max: Policy_historyMaxAggregateOutputType | null
  }

  type GetPolicy_historyGroupByPayload<T extends policy_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Policy_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Policy_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Policy_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Policy_historyGroupByOutputType[P]>
        }
      >
    >


  export type policy_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    policy_history_id?: boolean
    policy_type?: boolean
    revision_date?: boolean
    pdf_file_path?: boolean
    required?: boolean
    is_latest_revision?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["policy_history"]>



  export type policy_historySelectScalar = {
    policy_history_id?: boolean
    policy_type?: boolean
    revision_date?: boolean
    pdf_file_path?: boolean
    required?: boolean
    is_latest_revision?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type policy_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"policy_history_id" | "policy_type" | "revision_date" | "pdf_file_path" | "required" | "is_latest_revision" | "created_at" | "modified_at", ExtArgs["result"]["policy_history"]>

  export type $policy_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "policy_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      policy_history_id: bigint
      policy_type: $Enums.policy_history_policy_type
      revision_date: Date
      pdf_file_path: string
      required: boolean
      is_latest_revision: boolean
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["policy_history"]>
    composites: {}
  }

  type policy_historyGetPayload<S extends boolean | null | undefined | policy_historyDefaultArgs> = $Result.GetResult<Prisma.$policy_historyPayload, S>

  type policy_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<policy_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Policy_historyCountAggregateInputType | true
    }

  export interface policy_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['policy_history'], meta: { name: 'policy_history' } }
    /**
     * Find zero or one Policy_history that matches the filter.
     * @param {policy_historyFindUniqueArgs} args - Arguments to find a Policy_history
     * @example
     * // Get one Policy_history
     * const policy_history = await prisma.policy_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends policy_historyFindUniqueArgs>(args: SelectSubset<T, policy_historyFindUniqueArgs<ExtArgs>>): Prisma__policy_historyClient<$Result.GetResult<Prisma.$policy_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Policy_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {policy_historyFindUniqueOrThrowArgs} args - Arguments to find a Policy_history
     * @example
     * // Get one Policy_history
     * const policy_history = await prisma.policy_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends policy_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, policy_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__policy_historyClient<$Result.GetResult<Prisma.$policy_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Policy_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policy_historyFindFirstArgs} args - Arguments to find a Policy_history
     * @example
     * // Get one Policy_history
     * const policy_history = await prisma.policy_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends policy_historyFindFirstArgs>(args?: SelectSubset<T, policy_historyFindFirstArgs<ExtArgs>>): Prisma__policy_historyClient<$Result.GetResult<Prisma.$policy_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Policy_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policy_historyFindFirstOrThrowArgs} args - Arguments to find a Policy_history
     * @example
     * // Get one Policy_history
     * const policy_history = await prisma.policy_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends policy_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, policy_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__policy_historyClient<$Result.GetResult<Prisma.$policy_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Policy_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policy_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policy_histories
     * const policy_histories = await prisma.policy_history.findMany()
     * 
     * // Get first 10 Policy_histories
     * const policy_histories = await prisma.policy_history.findMany({ take: 10 })
     * 
     * // Only select the `policy_history_id`
     * const policy_historyWithPolicy_history_idOnly = await prisma.policy_history.findMany({ select: { policy_history_id: true } })
     * 
     */
    findMany<T extends policy_historyFindManyArgs>(args?: SelectSubset<T, policy_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$policy_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Policy_history.
     * @param {policy_historyCreateArgs} args - Arguments to create a Policy_history.
     * @example
     * // Create one Policy_history
     * const Policy_history = await prisma.policy_history.create({
     *   data: {
     *     // ... data to create a Policy_history
     *   }
     * })
     * 
     */
    create<T extends policy_historyCreateArgs>(args: SelectSubset<T, policy_historyCreateArgs<ExtArgs>>): Prisma__policy_historyClient<$Result.GetResult<Prisma.$policy_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Policy_histories.
     * @param {policy_historyCreateManyArgs} args - Arguments to create many Policy_histories.
     * @example
     * // Create many Policy_histories
     * const policy_history = await prisma.policy_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends policy_historyCreateManyArgs>(args?: SelectSubset<T, policy_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Policy_history.
     * @param {policy_historyDeleteArgs} args - Arguments to delete one Policy_history.
     * @example
     * // Delete one Policy_history
     * const Policy_history = await prisma.policy_history.delete({
     *   where: {
     *     // ... filter to delete one Policy_history
     *   }
     * })
     * 
     */
    delete<T extends policy_historyDeleteArgs>(args: SelectSubset<T, policy_historyDeleteArgs<ExtArgs>>): Prisma__policy_historyClient<$Result.GetResult<Prisma.$policy_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Policy_history.
     * @param {policy_historyUpdateArgs} args - Arguments to update one Policy_history.
     * @example
     * // Update one Policy_history
     * const policy_history = await prisma.policy_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends policy_historyUpdateArgs>(args: SelectSubset<T, policy_historyUpdateArgs<ExtArgs>>): Prisma__policy_historyClient<$Result.GetResult<Prisma.$policy_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Policy_histories.
     * @param {policy_historyDeleteManyArgs} args - Arguments to filter Policy_histories to delete.
     * @example
     * // Delete a few Policy_histories
     * const { count } = await prisma.policy_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends policy_historyDeleteManyArgs>(args?: SelectSubset<T, policy_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policy_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policy_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policy_histories
     * const policy_history = await prisma.policy_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends policy_historyUpdateManyArgs>(args: SelectSubset<T, policy_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Policy_history.
     * @param {policy_historyUpsertArgs} args - Arguments to update or create a Policy_history.
     * @example
     * // Update or create a Policy_history
     * const policy_history = await prisma.policy_history.upsert({
     *   create: {
     *     // ... data to create a Policy_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policy_history we want to update
     *   }
     * })
     */
    upsert<T extends policy_historyUpsertArgs>(args: SelectSubset<T, policy_historyUpsertArgs<ExtArgs>>): Prisma__policy_historyClient<$Result.GetResult<Prisma.$policy_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Policy_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policy_historyCountArgs} args - Arguments to filter Policy_histories to count.
     * @example
     * // Count the number of Policy_histories
     * const count = await prisma.policy_history.count({
     *   where: {
     *     // ... the filter for the Policy_histories we want to count
     *   }
     * })
    **/
    count<T extends policy_historyCountArgs>(
      args?: Subset<T, policy_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Policy_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policy_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Policy_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Policy_historyAggregateArgs>(args: Subset<T, Policy_historyAggregateArgs>): Prisma.PrismaPromise<GetPolicy_historyAggregateType<T>>

    /**
     * Group by Policy_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {policy_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends policy_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: policy_historyGroupByArgs['orderBy'] }
        : { orderBy?: policy_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, policy_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicy_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the policy_history model
   */
  readonly fields: policy_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for policy_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__policy_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the policy_history model
   */
  interface policy_historyFieldRefs {
    readonly policy_history_id: FieldRef<"policy_history", 'BigInt'>
    readonly policy_type: FieldRef<"policy_history", 'policy_history_policy_type'>
    readonly revision_date: FieldRef<"policy_history", 'DateTime'>
    readonly pdf_file_path: FieldRef<"policy_history", 'String'>
    readonly required: FieldRef<"policy_history", 'Boolean'>
    readonly is_latest_revision: FieldRef<"policy_history", 'Boolean'>
    readonly created_at: FieldRef<"policy_history", 'DateTime'>
    readonly modified_at: FieldRef<"policy_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * policy_history findUnique
   */
  export type policy_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_history
     */
    select?: policy_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_history
     */
    omit?: policy_historyOmit<ExtArgs> | null
    /**
     * Filter, which policy_history to fetch.
     */
    where: policy_historyWhereUniqueInput
  }

  /**
   * policy_history findUniqueOrThrow
   */
  export type policy_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_history
     */
    select?: policy_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_history
     */
    omit?: policy_historyOmit<ExtArgs> | null
    /**
     * Filter, which policy_history to fetch.
     */
    where: policy_historyWhereUniqueInput
  }

  /**
   * policy_history findFirst
   */
  export type policy_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_history
     */
    select?: policy_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_history
     */
    omit?: policy_historyOmit<ExtArgs> | null
    /**
     * Filter, which policy_history to fetch.
     */
    where?: policy_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of policy_histories to fetch.
     */
    orderBy?: policy_historyOrderByWithRelationInput | policy_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for policy_histories.
     */
    cursor?: policy_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` policy_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` policy_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of policy_histories.
     */
    distinct?: Policy_historyScalarFieldEnum | Policy_historyScalarFieldEnum[]
  }

  /**
   * policy_history findFirstOrThrow
   */
  export type policy_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_history
     */
    select?: policy_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_history
     */
    omit?: policy_historyOmit<ExtArgs> | null
    /**
     * Filter, which policy_history to fetch.
     */
    where?: policy_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of policy_histories to fetch.
     */
    orderBy?: policy_historyOrderByWithRelationInput | policy_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for policy_histories.
     */
    cursor?: policy_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` policy_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` policy_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of policy_histories.
     */
    distinct?: Policy_historyScalarFieldEnum | Policy_historyScalarFieldEnum[]
  }

  /**
   * policy_history findMany
   */
  export type policy_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_history
     */
    select?: policy_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_history
     */
    omit?: policy_historyOmit<ExtArgs> | null
    /**
     * Filter, which policy_histories to fetch.
     */
    where?: policy_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of policy_histories to fetch.
     */
    orderBy?: policy_historyOrderByWithRelationInput | policy_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing policy_histories.
     */
    cursor?: policy_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` policy_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` policy_histories.
     */
    skip?: number
    distinct?: Policy_historyScalarFieldEnum | Policy_historyScalarFieldEnum[]
  }

  /**
   * policy_history create
   */
  export type policy_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_history
     */
    select?: policy_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_history
     */
    omit?: policy_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a policy_history.
     */
    data: XOR<policy_historyCreateInput, policy_historyUncheckedCreateInput>
  }

  /**
   * policy_history createMany
   */
  export type policy_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many policy_histories.
     */
    data: policy_historyCreateManyInput | policy_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * policy_history update
   */
  export type policy_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_history
     */
    select?: policy_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_history
     */
    omit?: policy_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a policy_history.
     */
    data: XOR<policy_historyUpdateInput, policy_historyUncheckedUpdateInput>
    /**
     * Choose, which policy_history to update.
     */
    where: policy_historyWhereUniqueInput
  }

  /**
   * policy_history updateMany
   */
  export type policy_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update policy_histories.
     */
    data: XOR<policy_historyUpdateManyMutationInput, policy_historyUncheckedUpdateManyInput>
    /**
     * Filter which policy_histories to update
     */
    where?: policy_historyWhereInput
    /**
     * Limit how many policy_histories to update.
     */
    limit?: number
  }

  /**
   * policy_history upsert
   */
  export type policy_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_history
     */
    select?: policy_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_history
     */
    omit?: policy_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the policy_history to update in case it exists.
     */
    where: policy_historyWhereUniqueInput
    /**
     * In case the policy_history found by the `where` argument doesn't exist, create a new policy_history with this data.
     */
    create: XOR<policy_historyCreateInput, policy_historyUncheckedCreateInput>
    /**
     * In case the policy_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<policy_historyUpdateInput, policy_historyUncheckedUpdateInput>
  }

  /**
   * policy_history delete
   */
  export type policy_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_history
     */
    select?: policy_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_history
     */
    omit?: policy_historyOmit<ExtArgs> | null
    /**
     * Filter which policy_history to delete.
     */
    where: policy_historyWhereUniqueInput
  }

  /**
   * policy_history deleteMany
   */
  export type policy_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which policy_histories to delete
     */
    where?: policy_historyWhereInput
    /**
     * Limit how many policy_histories to delete.
     */
    limit?: number
  }

  /**
   * policy_history without action
   */
  export type policy_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the policy_history
     */
    select?: policy_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the policy_history
     */
    omit?: policy_historyOmit<ExtArgs> | null
  }


  /**
   * Model post_hashtag
   */

  export type AggregatePost_hashtag = {
    _count: Post_hashtagCountAggregateOutputType | null
    _avg: Post_hashtagAvgAggregateOutputType | null
    _sum: Post_hashtagSumAggregateOutputType | null
    _min: Post_hashtagMinAggregateOutputType | null
    _max: Post_hashtagMaxAggregateOutputType | null
  }

  export type Post_hashtagAvgAggregateOutputType = {
    post_hashtags_id: number | null
    post_id: number | null
    hashtag_id: number | null
  }

  export type Post_hashtagSumAggregateOutputType = {
    post_hashtags_id: bigint | null
    post_id: bigint | null
    hashtag_id: bigint | null
  }

  export type Post_hashtagMinAggregateOutputType = {
    post_hashtags_id: bigint | null
    post_id: bigint | null
    hashtag_id: bigint | null
    created_at: Date | null
    modified_at: Date | null
    deleted: boolean | null
    deleted_at: Date | null
  }

  export type Post_hashtagMaxAggregateOutputType = {
    post_hashtags_id: bigint | null
    post_id: bigint | null
    hashtag_id: bigint | null
    created_at: Date | null
    modified_at: Date | null
    deleted: boolean | null
    deleted_at: Date | null
  }

  export type Post_hashtagCountAggregateOutputType = {
    post_hashtags_id: number
    post_id: number
    hashtag_id: number
    created_at: number
    modified_at: number
    deleted: number
    deleted_at: number
    _all: number
  }


  export type Post_hashtagAvgAggregateInputType = {
    post_hashtags_id?: true
    post_id?: true
    hashtag_id?: true
  }

  export type Post_hashtagSumAggregateInputType = {
    post_hashtags_id?: true
    post_id?: true
    hashtag_id?: true
  }

  export type Post_hashtagMinAggregateInputType = {
    post_hashtags_id?: true
    post_id?: true
    hashtag_id?: true
    created_at?: true
    modified_at?: true
    deleted?: true
    deleted_at?: true
  }

  export type Post_hashtagMaxAggregateInputType = {
    post_hashtags_id?: true
    post_id?: true
    hashtag_id?: true
    created_at?: true
    modified_at?: true
    deleted?: true
    deleted_at?: true
  }

  export type Post_hashtagCountAggregateInputType = {
    post_hashtags_id?: true
    post_id?: true
    hashtag_id?: true
    created_at?: true
    modified_at?: true
    deleted?: true
    deleted_at?: true
    _all?: true
  }

  export type Post_hashtagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which post_hashtag to aggregate.
     */
    where?: post_hashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_hashtags to fetch.
     */
    orderBy?: post_hashtagOrderByWithRelationInput | post_hashtagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: post_hashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_hashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_hashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned post_hashtags
    **/
    _count?: true | Post_hashtagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Post_hashtagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Post_hashtagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Post_hashtagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Post_hashtagMaxAggregateInputType
  }

  export type GetPost_hashtagAggregateType<T extends Post_hashtagAggregateArgs> = {
        [P in keyof T & keyof AggregatePost_hashtag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost_hashtag[P]>
      : GetScalarType<T[P], AggregatePost_hashtag[P]>
  }




  export type post_hashtagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: post_hashtagWhereInput
    orderBy?: post_hashtagOrderByWithAggregationInput | post_hashtagOrderByWithAggregationInput[]
    by: Post_hashtagScalarFieldEnum[] | Post_hashtagScalarFieldEnum
    having?: post_hashtagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Post_hashtagCountAggregateInputType | true
    _avg?: Post_hashtagAvgAggregateInputType
    _sum?: Post_hashtagSumAggregateInputType
    _min?: Post_hashtagMinAggregateInputType
    _max?: Post_hashtagMaxAggregateInputType
  }

  export type Post_hashtagGroupByOutputType = {
    post_hashtags_id: bigint
    post_id: bigint
    hashtag_id: bigint
    created_at: Date
    modified_at: Date
    deleted: boolean
    deleted_at: Date | null
    _count: Post_hashtagCountAggregateOutputType | null
    _avg: Post_hashtagAvgAggregateOutputType | null
    _sum: Post_hashtagSumAggregateOutputType | null
    _min: Post_hashtagMinAggregateOutputType | null
    _max: Post_hashtagMaxAggregateOutputType | null
  }

  type GetPost_hashtagGroupByPayload<T extends post_hashtagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Post_hashtagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Post_hashtagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Post_hashtagGroupByOutputType[P]>
            : GetScalarType<T[P], Post_hashtagGroupByOutputType[P]>
        }
      >
    >


  export type post_hashtagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    post_hashtags_id?: boolean
    post_id?: boolean
    hashtag_id?: boolean
    created_at?: boolean
    modified_at?: boolean
    deleted?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["post_hashtag"]>



  export type post_hashtagSelectScalar = {
    post_hashtags_id?: boolean
    post_id?: boolean
    hashtag_id?: boolean
    created_at?: boolean
    modified_at?: boolean
    deleted?: boolean
    deleted_at?: boolean
  }

  export type post_hashtagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"post_hashtags_id" | "post_id" | "hashtag_id" | "created_at" | "modified_at" | "deleted" | "deleted_at", ExtArgs["result"]["post_hashtag"]>

  export type $post_hashtagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "post_hashtag"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      post_hashtags_id: bigint
      post_id: bigint
      hashtag_id: bigint
      created_at: Date
      modified_at: Date
      deleted: boolean
      deleted_at: Date | null
    }, ExtArgs["result"]["post_hashtag"]>
    composites: {}
  }

  type post_hashtagGetPayload<S extends boolean | null | undefined | post_hashtagDefaultArgs> = $Result.GetResult<Prisma.$post_hashtagPayload, S>

  type post_hashtagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<post_hashtagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Post_hashtagCountAggregateInputType | true
    }

  export interface post_hashtagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['post_hashtag'], meta: { name: 'post_hashtag' } }
    /**
     * Find zero or one Post_hashtag that matches the filter.
     * @param {post_hashtagFindUniqueArgs} args - Arguments to find a Post_hashtag
     * @example
     * // Get one Post_hashtag
     * const post_hashtag = await prisma.post_hashtag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends post_hashtagFindUniqueArgs>(args: SelectSubset<T, post_hashtagFindUniqueArgs<ExtArgs>>): Prisma__post_hashtagClient<$Result.GetResult<Prisma.$post_hashtagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post_hashtag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {post_hashtagFindUniqueOrThrowArgs} args - Arguments to find a Post_hashtag
     * @example
     * // Get one Post_hashtag
     * const post_hashtag = await prisma.post_hashtag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends post_hashtagFindUniqueOrThrowArgs>(args: SelectSubset<T, post_hashtagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__post_hashtagClient<$Result.GetResult<Prisma.$post_hashtagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post_hashtag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_hashtagFindFirstArgs} args - Arguments to find a Post_hashtag
     * @example
     * // Get one Post_hashtag
     * const post_hashtag = await prisma.post_hashtag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends post_hashtagFindFirstArgs>(args?: SelectSubset<T, post_hashtagFindFirstArgs<ExtArgs>>): Prisma__post_hashtagClient<$Result.GetResult<Prisma.$post_hashtagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post_hashtag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_hashtagFindFirstOrThrowArgs} args - Arguments to find a Post_hashtag
     * @example
     * // Get one Post_hashtag
     * const post_hashtag = await prisma.post_hashtag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends post_hashtagFindFirstOrThrowArgs>(args?: SelectSubset<T, post_hashtagFindFirstOrThrowArgs<ExtArgs>>): Prisma__post_hashtagClient<$Result.GetResult<Prisma.$post_hashtagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Post_hashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_hashtagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Post_hashtags
     * const post_hashtags = await prisma.post_hashtag.findMany()
     * 
     * // Get first 10 Post_hashtags
     * const post_hashtags = await prisma.post_hashtag.findMany({ take: 10 })
     * 
     * // Only select the `post_hashtags_id`
     * const post_hashtagWithPost_hashtags_idOnly = await prisma.post_hashtag.findMany({ select: { post_hashtags_id: true } })
     * 
     */
    findMany<T extends post_hashtagFindManyArgs>(args?: SelectSubset<T, post_hashtagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_hashtagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post_hashtag.
     * @param {post_hashtagCreateArgs} args - Arguments to create a Post_hashtag.
     * @example
     * // Create one Post_hashtag
     * const Post_hashtag = await prisma.post_hashtag.create({
     *   data: {
     *     // ... data to create a Post_hashtag
     *   }
     * })
     * 
     */
    create<T extends post_hashtagCreateArgs>(args: SelectSubset<T, post_hashtagCreateArgs<ExtArgs>>): Prisma__post_hashtagClient<$Result.GetResult<Prisma.$post_hashtagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Post_hashtags.
     * @param {post_hashtagCreateManyArgs} args - Arguments to create many Post_hashtags.
     * @example
     * // Create many Post_hashtags
     * const post_hashtag = await prisma.post_hashtag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends post_hashtagCreateManyArgs>(args?: SelectSubset<T, post_hashtagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post_hashtag.
     * @param {post_hashtagDeleteArgs} args - Arguments to delete one Post_hashtag.
     * @example
     * // Delete one Post_hashtag
     * const Post_hashtag = await prisma.post_hashtag.delete({
     *   where: {
     *     // ... filter to delete one Post_hashtag
     *   }
     * })
     * 
     */
    delete<T extends post_hashtagDeleteArgs>(args: SelectSubset<T, post_hashtagDeleteArgs<ExtArgs>>): Prisma__post_hashtagClient<$Result.GetResult<Prisma.$post_hashtagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post_hashtag.
     * @param {post_hashtagUpdateArgs} args - Arguments to update one Post_hashtag.
     * @example
     * // Update one Post_hashtag
     * const post_hashtag = await prisma.post_hashtag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends post_hashtagUpdateArgs>(args: SelectSubset<T, post_hashtagUpdateArgs<ExtArgs>>): Prisma__post_hashtagClient<$Result.GetResult<Prisma.$post_hashtagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Post_hashtags.
     * @param {post_hashtagDeleteManyArgs} args - Arguments to filter Post_hashtags to delete.
     * @example
     * // Delete a few Post_hashtags
     * const { count } = await prisma.post_hashtag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends post_hashtagDeleteManyArgs>(args?: SelectSubset<T, post_hashtagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Post_hashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_hashtagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Post_hashtags
     * const post_hashtag = await prisma.post_hashtag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends post_hashtagUpdateManyArgs>(args: SelectSubset<T, post_hashtagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post_hashtag.
     * @param {post_hashtagUpsertArgs} args - Arguments to update or create a Post_hashtag.
     * @example
     * // Update or create a Post_hashtag
     * const post_hashtag = await prisma.post_hashtag.upsert({
     *   create: {
     *     // ... data to create a Post_hashtag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post_hashtag we want to update
     *   }
     * })
     */
    upsert<T extends post_hashtagUpsertArgs>(args: SelectSubset<T, post_hashtagUpsertArgs<ExtArgs>>): Prisma__post_hashtagClient<$Result.GetResult<Prisma.$post_hashtagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Post_hashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_hashtagCountArgs} args - Arguments to filter Post_hashtags to count.
     * @example
     * // Count the number of Post_hashtags
     * const count = await prisma.post_hashtag.count({
     *   where: {
     *     // ... the filter for the Post_hashtags we want to count
     *   }
     * })
    **/
    count<T extends post_hashtagCountArgs>(
      args?: Subset<T, post_hashtagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Post_hashtagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post_hashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Post_hashtagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Post_hashtagAggregateArgs>(args: Subset<T, Post_hashtagAggregateArgs>): Prisma.PrismaPromise<GetPost_hashtagAggregateType<T>>

    /**
     * Group by Post_hashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_hashtagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends post_hashtagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: post_hashtagGroupByArgs['orderBy'] }
        : { orderBy?: post_hashtagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, post_hashtagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPost_hashtagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the post_hashtag model
   */
  readonly fields: post_hashtagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for post_hashtag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__post_hashtagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the post_hashtag model
   */
  interface post_hashtagFieldRefs {
    readonly post_hashtags_id: FieldRef<"post_hashtag", 'BigInt'>
    readonly post_id: FieldRef<"post_hashtag", 'BigInt'>
    readonly hashtag_id: FieldRef<"post_hashtag", 'BigInt'>
    readonly created_at: FieldRef<"post_hashtag", 'DateTime'>
    readonly modified_at: FieldRef<"post_hashtag", 'DateTime'>
    readonly deleted: FieldRef<"post_hashtag", 'Boolean'>
    readonly deleted_at: FieldRef<"post_hashtag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * post_hashtag findUnique
   */
  export type post_hashtagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_hashtag
     */
    select?: post_hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_hashtag
     */
    omit?: post_hashtagOmit<ExtArgs> | null
    /**
     * Filter, which post_hashtag to fetch.
     */
    where: post_hashtagWhereUniqueInput
  }

  /**
   * post_hashtag findUniqueOrThrow
   */
  export type post_hashtagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_hashtag
     */
    select?: post_hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_hashtag
     */
    omit?: post_hashtagOmit<ExtArgs> | null
    /**
     * Filter, which post_hashtag to fetch.
     */
    where: post_hashtagWhereUniqueInput
  }

  /**
   * post_hashtag findFirst
   */
  export type post_hashtagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_hashtag
     */
    select?: post_hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_hashtag
     */
    omit?: post_hashtagOmit<ExtArgs> | null
    /**
     * Filter, which post_hashtag to fetch.
     */
    where?: post_hashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_hashtags to fetch.
     */
    orderBy?: post_hashtagOrderByWithRelationInput | post_hashtagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for post_hashtags.
     */
    cursor?: post_hashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_hashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_hashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of post_hashtags.
     */
    distinct?: Post_hashtagScalarFieldEnum | Post_hashtagScalarFieldEnum[]
  }

  /**
   * post_hashtag findFirstOrThrow
   */
  export type post_hashtagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_hashtag
     */
    select?: post_hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_hashtag
     */
    omit?: post_hashtagOmit<ExtArgs> | null
    /**
     * Filter, which post_hashtag to fetch.
     */
    where?: post_hashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_hashtags to fetch.
     */
    orderBy?: post_hashtagOrderByWithRelationInput | post_hashtagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for post_hashtags.
     */
    cursor?: post_hashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_hashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_hashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of post_hashtags.
     */
    distinct?: Post_hashtagScalarFieldEnum | Post_hashtagScalarFieldEnum[]
  }

  /**
   * post_hashtag findMany
   */
  export type post_hashtagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_hashtag
     */
    select?: post_hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_hashtag
     */
    omit?: post_hashtagOmit<ExtArgs> | null
    /**
     * Filter, which post_hashtags to fetch.
     */
    where?: post_hashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_hashtags to fetch.
     */
    orderBy?: post_hashtagOrderByWithRelationInput | post_hashtagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing post_hashtags.
     */
    cursor?: post_hashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_hashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_hashtags.
     */
    skip?: number
    distinct?: Post_hashtagScalarFieldEnum | Post_hashtagScalarFieldEnum[]
  }

  /**
   * post_hashtag create
   */
  export type post_hashtagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_hashtag
     */
    select?: post_hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_hashtag
     */
    omit?: post_hashtagOmit<ExtArgs> | null
    /**
     * The data needed to create a post_hashtag.
     */
    data: XOR<post_hashtagCreateInput, post_hashtagUncheckedCreateInput>
  }

  /**
   * post_hashtag createMany
   */
  export type post_hashtagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many post_hashtags.
     */
    data: post_hashtagCreateManyInput | post_hashtagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * post_hashtag update
   */
  export type post_hashtagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_hashtag
     */
    select?: post_hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_hashtag
     */
    omit?: post_hashtagOmit<ExtArgs> | null
    /**
     * The data needed to update a post_hashtag.
     */
    data: XOR<post_hashtagUpdateInput, post_hashtagUncheckedUpdateInput>
    /**
     * Choose, which post_hashtag to update.
     */
    where: post_hashtagWhereUniqueInput
  }

  /**
   * post_hashtag updateMany
   */
  export type post_hashtagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update post_hashtags.
     */
    data: XOR<post_hashtagUpdateManyMutationInput, post_hashtagUncheckedUpdateManyInput>
    /**
     * Filter which post_hashtags to update
     */
    where?: post_hashtagWhereInput
    /**
     * Limit how many post_hashtags to update.
     */
    limit?: number
  }

  /**
   * post_hashtag upsert
   */
  export type post_hashtagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_hashtag
     */
    select?: post_hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_hashtag
     */
    omit?: post_hashtagOmit<ExtArgs> | null
    /**
     * The filter to search for the post_hashtag to update in case it exists.
     */
    where: post_hashtagWhereUniqueInput
    /**
     * In case the post_hashtag found by the `where` argument doesn't exist, create a new post_hashtag with this data.
     */
    create: XOR<post_hashtagCreateInput, post_hashtagUncheckedCreateInput>
    /**
     * In case the post_hashtag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<post_hashtagUpdateInput, post_hashtagUncheckedUpdateInput>
  }

  /**
   * post_hashtag delete
   */
  export type post_hashtagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_hashtag
     */
    select?: post_hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_hashtag
     */
    omit?: post_hashtagOmit<ExtArgs> | null
    /**
     * Filter which post_hashtag to delete.
     */
    where: post_hashtagWhereUniqueInput
  }

  /**
   * post_hashtag deleteMany
   */
  export type post_hashtagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which post_hashtags to delete
     */
    where?: post_hashtagWhereInput
    /**
     * Limit how many post_hashtags to delete.
     */
    limit?: number
  }

  /**
   * post_hashtag without action
   */
  export type post_hashtagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_hashtag
     */
    select?: post_hashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_hashtag
     */
    omit?: post_hashtagOmit<ExtArgs> | null
  }


  /**
   * Model recommended_feed
   */

  export type AggregateRecommended_feed = {
    _count: Recommended_feedCountAggregateOutputType | null
    _avg: Recommended_feedAvgAggregateOutputType | null
    _sum: Recommended_feedSumAggregateOutputType | null
    _min: Recommended_feedMinAggregateOutputType | null
    _max: Recommended_feedMaxAggregateOutputType | null
  }

  export type Recommended_feedAvgAggregateOutputType = {
    recommended_feed_id: number | null
    hobby_post_id: number | null
    created_by: number | null
    modified_by: number | null
  }

  export type Recommended_feedSumAggregateOutputType = {
    recommended_feed_id: bigint | null
    hobby_post_id: bigint | null
    created_by: bigint | null
    modified_by: bigint | null
  }

  export type Recommended_feedMinAggregateOutputType = {
    recommended_feed_id: bigint | null
    hobby_post_id: bigint | null
    recommended_type: $Enums.recommended_feed_recommended_type | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
  }

  export type Recommended_feedMaxAggregateOutputType = {
    recommended_feed_id: bigint | null
    hobby_post_id: bigint | null
    recommended_type: $Enums.recommended_feed_recommended_type | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
  }

  export type Recommended_feedCountAggregateOutputType = {
    recommended_feed_id: number
    hobby_post_id: number
    recommended_type: number
    created_at: number
    created_by: number
    modified_at: number
    modified_by: number
    deleted: number
    _all: number
  }


  export type Recommended_feedAvgAggregateInputType = {
    recommended_feed_id?: true
    hobby_post_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Recommended_feedSumAggregateInputType = {
    recommended_feed_id?: true
    hobby_post_id?: true
    created_by?: true
    modified_by?: true
  }

  export type Recommended_feedMinAggregateInputType = {
    recommended_feed_id?: true
    hobby_post_id?: true
    recommended_type?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
  }

  export type Recommended_feedMaxAggregateInputType = {
    recommended_feed_id?: true
    hobby_post_id?: true
    recommended_type?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
  }

  export type Recommended_feedCountAggregateInputType = {
    recommended_feed_id?: true
    hobby_post_id?: true
    recommended_type?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
    _all?: true
  }

  export type Recommended_feedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recommended_feed to aggregate.
     */
    where?: recommended_feedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recommended_feeds to fetch.
     */
    orderBy?: recommended_feedOrderByWithRelationInput | recommended_feedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recommended_feedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recommended_feeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recommended_feeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recommended_feeds
    **/
    _count?: true | Recommended_feedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Recommended_feedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Recommended_feedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Recommended_feedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Recommended_feedMaxAggregateInputType
  }

  export type GetRecommended_feedAggregateType<T extends Recommended_feedAggregateArgs> = {
        [P in keyof T & keyof AggregateRecommended_feed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecommended_feed[P]>
      : GetScalarType<T[P], AggregateRecommended_feed[P]>
  }




  export type recommended_feedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recommended_feedWhereInput
    orderBy?: recommended_feedOrderByWithAggregationInput | recommended_feedOrderByWithAggregationInput[]
    by: Recommended_feedScalarFieldEnum[] | Recommended_feedScalarFieldEnum
    having?: recommended_feedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Recommended_feedCountAggregateInputType | true
    _avg?: Recommended_feedAvgAggregateInputType
    _sum?: Recommended_feedSumAggregateInputType
    _min?: Recommended_feedMinAggregateInputType
    _max?: Recommended_feedMaxAggregateInputType
  }

  export type Recommended_feedGroupByOutputType = {
    recommended_feed_id: bigint
    hobby_post_id: bigint
    recommended_type: $Enums.recommended_feed_recommended_type | null
    created_at: Date
    created_by: bigint
    modified_at: Date
    modified_by: bigint
    deleted: boolean
    _count: Recommended_feedCountAggregateOutputType | null
    _avg: Recommended_feedAvgAggregateOutputType | null
    _sum: Recommended_feedSumAggregateOutputType | null
    _min: Recommended_feedMinAggregateOutputType | null
    _max: Recommended_feedMaxAggregateOutputType | null
  }

  type GetRecommended_feedGroupByPayload<T extends recommended_feedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Recommended_feedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Recommended_feedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Recommended_feedGroupByOutputType[P]>
            : GetScalarType<T[P], Recommended_feedGroupByOutputType[P]>
        }
      >
    >


  export type recommended_feedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recommended_feed_id?: boolean
    hobby_post_id?: boolean
    recommended_type?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["recommended_feed"]>



  export type recommended_feedSelectScalar = {
    recommended_feed_id?: boolean
    hobby_post_id?: boolean
    recommended_type?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
  }

  export type recommended_feedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"recommended_feed_id" | "hobby_post_id" | "recommended_type" | "created_at" | "created_by" | "modified_at" | "modified_by" | "deleted", ExtArgs["result"]["recommended_feed"]>

  export type $recommended_feedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "recommended_feed"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      recommended_feed_id: bigint
      hobby_post_id: bigint
      recommended_type: $Enums.recommended_feed_recommended_type | null
      created_at: Date
      created_by: bigint
      modified_at: Date
      modified_by: bigint
      deleted: boolean
    }, ExtArgs["result"]["recommended_feed"]>
    composites: {}
  }

  type recommended_feedGetPayload<S extends boolean | null | undefined | recommended_feedDefaultArgs> = $Result.GetResult<Prisma.$recommended_feedPayload, S>

  type recommended_feedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<recommended_feedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Recommended_feedCountAggregateInputType | true
    }

  export interface recommended_feedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['recommended_feed'], meta: { name: 'recommended_feed' } }
    /**
     * Find zero or one Recommended_feed that matches the filter.
     * @param {recommended_feedFindUniqueArgs} args - Arguments to find a Recommended_feed
     * @example
     * // Get one Recommended_feed
     * const recommended_feed = await prisma.recommended_feed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends recommended_feedFindUniqueArgs>(args: SelectSubset<T, recommended_feedFindUniqueArgs<ExtArgs>>): Prisma__recommended_feedClient<$Result.GetResult<Prisma.$recommended_feedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Recommended_feed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {recommended_feedFindUniqueOrThrowArgs} args - Arguments to find a Recommended_feed
     * @example
     * // Get one Recommended_feed
     * const recommended_feed = await prisma.recommended_feed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends recommended_feedFindUniqueOrThrowArgs>(args: SelectSubset<T, recommended_feedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__recommended_feedClient<$Result.GetResult<Prisma.$recommended_feedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recommended_feed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommended_feedFindFirstArgs} args - Arguments to find a Recommended_feed
     * @example
     * // Get one Recommended_feed
     * const recommended_feed = await prisma.recommended_feed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends recommended_feedFindFirstArgs>(args?: SelectSubset<T, recommended_feedFindFirstArgs<ExtArgs>>): Prisma__recommended_feedClient<$Result.GetResult<Prisma.$recommended_feedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recommended_feed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommended_feedFindFirstOrThrowArgs} args - Arguments to find a Recommended_feed
     * @example
     * // Get one Recommended_feed
     * const recommended_feed = await prisma.recommended_feed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends recommended_feedFindFirstOrThrowArgs>(args?: SelectSubset<T, recommended_feedFindFirstOrThrowArgs<ExtArgs>>): Prisma__recommended_feedClient<$Result.GetResult<Prisma.$recommended_feedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recommended_feeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommended_feedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recommended_feeds
     * const recommended_feeds = await prisma.recommended_feed.findMany()
     * 
     * // Get first 10 Recommended_feeds
     * const recommended_feeds = await prisma.recommended_feed.findMany({ take: 10 })
     * 
     * // Only select the `recommended_feed_id`
     * const recommended_feedWithRecommended_feed_idOnly = await prisma.recommended_feed.findMany({ select: { recommended_feed_id: true } })
     * 
     */
    findMany<T extends recommended_feedFindManyArgs>(args?: SelectSubset<T, recommended_feedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recommended_feedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Recommended_feed.
     * @param {recommended_feedCreateArgs} args - Arguments to create a Recommended_feed.
     * @example
     * // Create one Recommended_feed
     * const Recommended_feed = await prisma.recommended_feed.create({
     *   data: {
     *     // ... data to create a Recommended_feed
     *   }
     * })
     * 
     */
    create<T extends recommended_feedCreateArgs>(args: SelectSubset<T, recommended_feedCreateArgs<ExtArgs>>): Prisma__recommended_feedClient<$Result.GetResult<Prisma.$recommended_feedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recommended_feeds.
     * @param {recommended_feedCreateManyArgs} args - Arguments to create many Recommended_feeds.
     * @example
     * // Create many Recommended_feeds
     * const recommended_feed = await prisma.recommended_feed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends recommended_feedCreateManyArgs>(args?: SelectSubset<T, recommended_feedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Recommended_feed.
     * @param {recommended_feedDeleteArgs} args - Arguments to delete one Recommended_feed.
     * @example
     * // Delete one Recommended_feed
     * const Recommended_feed = await prisma.recommended_feed.delete({
     *   where: {
     *     // ... filter to delete one Recommended_feed
     *   }
     * })
     * 
     */
    delete<T extends recommended_feedDeleteArgs>(args: SelectSubset<T, recommended_feedDeleteArgs<ExtArgs>>): Prisma__recommended_feedClient<$Result.GetResult<Prisma.$recommended_feedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Recommended_feed.
     * @param {recommended_feedUpdateArgs} args - Arguments to update one Recommended_feed.
     * @example
     * // Update one Recommended_feed
     * const recommended_feed = await prisma.recommended_feed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends recommended_feedUpdateArgs>(args: SelectSubset<T, recommended_feedUpdateArgs<ExtArgs>>): Prisma__recommended_feedClient<$Result.GetResult<Prisma.$recommended_feedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recommended_feeds.
     * @param {recommended_feedDeleteManyArgs} args - Arguments to filter Recommended_feeds to delete.
     * @example
     * // Delete a few Recommended_feeds
     * const { count } = await prisma.recommended_feed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends recommended_feedDeleteManyArgs>(args?: SelectSubset<T, recommended_feedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recommended_feeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommended_feedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recommended_feeds
     * const recommended_feed = await prisma.recommended_feed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends recommended_feedUpdateManyArgs>(args: SelectSubset<T, recommended_feedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recommended_feed.
     * @param {recommended_feedUpsertArgs} args - Arguments to update or create a Recommended_feed.
     * @example
     * // Update or create a Recommended_feed
     * const recommended_feed = await prisma.recommended_feed.upsert({
     *   create: {
     *     // ... data to create a Recommended_feed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recommended_feed we want to update
     *   }
     * })
     */
    upsert<T extends recommended_feedUpsertArgs>(args: SelectSubset<T, recommended_feedUpsertArgs<ExtArgs>>): Prisma__recommended_feedClient<$Result.GetResult<Prisma.$recommended_feedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recommended_feeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommended_feedCountArgs} args - Arguments to filter Recommended_feeds to count.
     * @example
     * // Count the number of Recommended_feeds
     * const count = await prisma.recommended_feed.count({
     *   where: {
     *     // ... the filter for the Recommended_feeds we want to count
     *   }
     * })
    **/
    count<T extends recommended_feedCountArgs>(
      args?: Subset<T, recommended_feedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Recommended_feedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recommended_feed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Recommended_feedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Recommended_feedAggregateArgs>(args: Subset<T, Recommended_feedAggregateArgs>): Prisma.PrismaPromise<GetRecommended_feedAggregateType<T>>

    /**
     * Group by Recommended_feed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommended_feedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recommended_feedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recommended_feedGroupByArgs['orderBy'] }
        : { orderBy?: recommended_feedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recommended_feedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecommended_feedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the recommended_feed model
   */
  readonly fields: recommended_feedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for recommended_feed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recommended_feedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the recommended_feed model
   */
  interface recommended_feedFieldRefs {
    readonly recommended_feed_id: FieldRef<"recommended_feed", 'BigInt'>
    readonly hobby_post_id: FieldRef<"recommended_feed", 'BigInt'>
    readonly recommended_type: FieldRef<"recommended_feed", 'recommended_feed_recommended_type'>
    readonly created_at: FieldRef<"recommended_feed", 'DateTime'>
    readonly created_by: FieldRef<"recommended_feed", 'BigInt'>
    readonly modified_at: FieldRef<"recommended_feed", 'DateTime'>
    readonly modified_by: FieldRef<"recommended_feed", 'BigInt'>
    readonly deleted: FieldRef<"recommended_feed", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * recommended_feed findUnique
   */
  export type recommended_feedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommended_feed
     */
    select?: recommended_feedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recommended_feed
     */
    omit?: recommended_feedOmit<ExtArgs> | null
    /**
     * Filter, which recommended_feed to fetch.
     */
    where: recommended_feedWhereUniqueInput
  }

  /**
   * recommended_feed findUniqueOrThrow
   */
  export type recommended_feedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommended_feed
     */
    select?: recommended_feedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recommended_feed
     */
    omit?: recommended_feedOmit<ExtArgs> | null
    /**
     * Filter, which recommended_feed to fetch.
     */
    where: recommended_feedWhereUniqueInput
  }

  /**
   * recommended_feed findFirst
   */
  export type recommended_feedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommended_feed
     */
    select?: recommended_feedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recommended_feed
     */
    omit?: recommended_feedOmit<ExtArgs> | null
    /**
     * Filter, which recommended_feed to fetch.
     */
    where?: recommended_feedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recommended_feeds to fetch.
     */
    orderBy?: recommended_feedOrderByWithRelationInput | recommended_feedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recommended_feeds.
     */
    cursor?: recommended_feedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recommended_feeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recommended_feeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recommended_feeds.
     */
    distinct?: Recommended_feedScalarFieldEnum | Recommended_feedScalarFieldEnum[]
  }

  /**
   * recommended_feed findFirstOrThrow
   */
  export type recommended_feedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommended_feed
     */
    select?: recommended_feedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recommended_feed
     */
    omit?: recommended_feedOmit<ExtArgs> | null
    /**
     * Filter, which recommended_feed to fetch.
     */
    where?: recommended_feedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recommended_feeds to fetch.
     */
    orderBy?: recommended_feedOrderByWithRelationInput | recommended_feedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recommended_feeds.
     */
    cursor?: recommended_feedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recommended_feeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recommended_feeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recommended_feeds.
     */
    distinct?: Recommended_feedScalarFieldEnum | Recommended_feedScalarFieldEnum[]
  }

  /**
   * recommended_feed findMany
   */
  export type recommended_feedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommended_feed
     */
    select?: recommended_feedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recommended_feed
     */
    omit?: recommended_feedOmit<ExtArgs> | null
    /**
     * Filter, which recommended_feeds to fetch.
     */
    where?: recommended_feedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recommended_feeds to fetch.
     */
    orderBy?: recommended_feedOrderByWithRelationInput | recommended_feedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recommended_feeds.
     */
    cursor?: recommended_feedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recommended_feeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recommended_feeds.
     */
    skip?: number
    distinct?: Recommended_feedScalarFieldEnum | Recommended_feedScalarFieldEnum[]
  }

  /**
   * recommended_feed create
   */
  export type recommended_feedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommended_feed
     */
    select?: recommended_feedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recommended_feed
     */
    omit?: recommended_feedOmit<ExtArgs> | null
    /**
     * The data needed to create a recommended_feed.
     */
    data: XOR<recommended_feedCreateInput, recommended_feedUncheckedCreateInput>
  }

  /**
   * recommended_feed createMany
   */
  export type recommended_feedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many recommended_feeds.
     */
    data: recommended_feedCreateManyInput | recommended_feedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * recommended_feed update
   */
  export type recommended_feedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommended_feed
     */
    select?: recommended_feedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recommended_feed
     */
    omit?: recommended_feedOmit<ExtArgs> | null
    /**
     * The data needed to update a recommended_feed.
     */
    data: XOR<recommended_feedUpdateInput, recommended_feedUncheckedUpdateInput>
    /**
     * Choose, which recommended_feed to update.
     */
    where: recommended_feedWhereUniqueInput
  }

  /**
   * recommended_feed updateMany
   */
  export type recommended_feedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update recommended_feeds.
     */
    data: XOR<recommended_feedUpdateManyMutationInput, recommended_feedUncheckedUpdateManyInput>
    /**
     * Filter which recommended_feeds to update
     */
    where?: recommended_feedWhereInput
    /**
     * Limit how many recommended_feeds to update.
     */
    limit?: number
  }

  /**
   * recommended_feed upsert
   */
  export type recommended_feedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommended_feed
     */
    select?: recommended_feedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recommended_feed
     */
    omit?: recommended_feedOmit<ExtArgs> | null
    /**
     * The filter to search for the recommended_feed to update in case it exists.
     */
    where: recommended_feedWhereUniqueInput
    /**
     * In case the recommended_feed found by the `where` argument doesn't exist, create a new recommended_feed with this data.
     */
    create: XOR<recommended_feedCreateInput, recommended_feedUncheckedCreateInput>
    /**
     * In case the recommended_feed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recommended_feedUpdateInput, recommended_feedUncheckedUpdateInput>
  }

  /**
   * recommended_feed delete
   */
  export type recommended_feedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommended_feed
     */
    select?: recommended_feedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recommended_feed
     */
    omit?: recommended_feedOmit<ExtArgs> | null
    /**
     * Filter which recommended_feed to delete.
     */
    where: recommended_feedWhereUniqueInput
  }

  /**
   * recommended_feed deleteMany
   */
  export type recommended_feedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recommended_feeds to delete
     */
    where?: recommended_feedWhereInput
    /**
     * Limit how many recommended_feeds to delete.
     */
    limit?: number
  }

  /**
   * recommended_feed without action
   */
  export type recommended_feedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommended_feed
     */
    select?: recommended_feedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recommended_feed
     */
    omit?: recommended_feedOmit<ExtArgs> | null
  }


  /**
   * Model report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    report_id: number | null
    user_id: number | null
    hobby_post_id: number | null
    comment_id: number | null
    sub_comment_id: number | null
    created_by: number | null
    modified_by: number | null
  }

  export type ReportSumAggregateOutputType = {
    report_id: bigint | null
    user_id: bigint | null
    hobby_post_id: bigint | null
    comment_id: bigint | null
    sub_comment_id: bigint | null
    created_by: bigint | null
    modified_by: bigint | null
  }

  export type ReportMinAggregateOutputType = {
    report_id: bigint | null
    user_id: bigint | null
    hobby_post_id: bigint | null
    comment_id: bigint | null
    sub_comment_id: bigint | null
    report_content: string | null
    report_status: $Enums.report_report_status | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
  }

  export type ReportMaxAggregateOutputType = {
    report_id: bigint | null
    user_id: bigint | null
    hobby_post_id: bigint | null
    comment_id: bigint | null
    sub_comment_id: bigint | null
    report_content: string | null
    report_status: $Enums.report_report_status | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
  }

  export type ReportCountAggregateOutputType = {
    report_id: number
    user_id: number
    hobby_post_id: number
    comment_id: number
    sub_comment_id: number
    report_content: number
    report_status: number
    created_at: number
    created_by: number
    modified_at: number
    modified_by: number
    deleted: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    report_id?: true
    user_id?: true
    hobby_post_id?: true
    comment_id?: true
    sub_comment_id?: true
    created_by?: true
    modified_by?: true
  }

  export type ReportSumAggregateInputType = {
    report_id?: true
    user_id?: true
    hobby_post_id?: true
    comment_id?: true
    sub_comment_id?: true
    created_by?: true
    modified_by?: true
  }

  export type ReportMinAggregateInputType = {
    report_id?: true
    user_id?: true
    hobby_post_id?: true
    comment_id?: true
    sub_comment_id?: true
    report_content?: true
    report_status?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
  }

  export type ReportMaxAggregateInputType = {
    report_id?: true
    user_id?: true
    hobby_post_id?: true
    comment_id?: true
    sub_comment_id?: true
    report_content?: true
    report_status?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
  }

  export type ReportCountAggregateInputType = {
    report_id?: true
    user_id?: true
    hobby_post_id?: true
    comment_id?: true
    sub_comment_id?: true
    report_content?: true
    report_status?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which report to aggregate.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportOrderByWithRelationInput | reportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type reportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportWhereInput
    orderBy?: reportOrderByWithAggregationInput | reportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: reportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    report_id: bigint
    user_id: bigint
    hobby_post_id: bigint | null
    comment_id: bigint | null
    sub_comment_id: bigint | null
    report_content: string
    report_status: $Enums.report_report_status
    created_at: Date
    created_by: bigint
    modified_at: Date
    modified_by: bigint
    deleted: boolean
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends reportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type reportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    report_id?: boolean
    user_id?: boolean
    hobby_post_id?: boolean
    comment_id?: boolean
    sub_comment_id?: boolean
    report_content?: boolean
    report_status?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["report"]>



  export type reportSelectScalar = {
    report_id?: boolean
    user_id?: boolean
    hobby_post_id?: boolean
    comment_id?: boolean
    sub_comment_id?: boolean
    report_content?: boolean
    report_status?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
  }

  export type reportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"report_id" | "user_id" | "hobby_post_id" | "comment_id" | "sub_comment_id" | "report_content" | "report_status" | "created_at" | "created_by" | "modified_at" | "modified_by" | "deleted", ExtArgs["result"]["report"]>

  export type $reportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "report"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      report_id: bigint
      user_id: bigint
      hobby_post_id: bigint | null
      comment_id: bigint | null
      sub_comment_id: bigint | null
      report_content: string
      report_status: $Enums.report_report_status
      created_at: Date
      created_by: bigint
      modified_at: Date
      modified_by: bigint
      deleted: boolean
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type reportGetPayload<S extends boolean | null | undefined | reportDefaultArgs> = $Result.GetResult<Prisma.$reportPayload, S>

  type reportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface reportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['report'], meta: { name: 'report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {reportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reportFindUniqueArgs>(args: SelectSubset<T, reportFindUniqueArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reportFindUniqueOrThrowArgs>(args: SelectSubset<T, reportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reportFindFirstArgs>(args?: SelectSubset<T, reportFindFirstArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reportFindFirstOrThrowArgs>(args?: SelectSubset<T, reportFindFirstOrThrowArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `report_id`
     * const reportWithReport_idOnly = await prisma.report.findMany({ select: { report_id: true } })
     * 
     */
    findMany<T extends reportFindManyArgs>(args?: SelectSubset<T, reportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {reportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends reportCreateArgs>(args: SelectSubset<T, reportCreateArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {reportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reportCreateManyArgs>(args?: SelectSubset<T, reportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {reportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends reportDeleteArgs>(args: SelectSubset<T, reportDeleteArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {reportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reportUpdateArgs>(args: SelectSubset<T, reportUpdateArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {reportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reportDeleteManyArgs>(args?: SelectSubset<T, reportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reportUpdateManyArgs>(args: SelectSubset<T, reportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {reportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends reportUpsertArgs>(args: SelectSubset<T, reportUpsertArgs<ExtArgs>>): Prisma__reportClient<$Result.GetResult<Prisma.$reportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends reportCountArgs>(
      args?: Subset<T, reportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reportGroupByArgs['orderBy'] }
        : { orderBy?: reportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the report model
   */
  readonly fields: reportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the report model
   */
  interface reportFieldRefs {
    readonly report_id: FieldRef<"report", 'BigInt'>
    readonly user_id: FieldRef<"report", 'BigInt'>
    readonly hobby_post_id: FieldRef<"report", 'BigInt'>
    readonly comment_id: FieldRef<"report", 'BigInt'>
    readonly sub_comment_id: FieldRef<"report", 'BigInt'>
    readonly report_content: FieldRef<"report", 'String'>
    readonly report_status: FieldRef<"report", 'report_report_status'>
    readonly created_at: FieldRef<"report", 'DateTime'>
    readonly created_by: FieldRef<"report", 'BigInt'>
    readonly modified_at: FieldRef<"report", 'DateTime'>
    readonly modified_by: FieldRef<"report", 'BigInt'>
    readonly deleted: FieldRef<"report", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * report findUnique
   */
  export type reportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Filter, which report to fetch.
     */
    where: reportWhereUniqueInput
  }

  /**
   * report findUniqueOrThrow
   */
  export type reportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Filter, which report to fetch.
     */
    where: reportWhereUniqueInput
  }

  /**
   * report findFirst
   */
  export type reportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Filter, which report to fetch.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportOrderByWithRelationInput | reportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * report findFirstOrThrow
   */
  export type reportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Filter, which report to fetch.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportOrderByWithRelationInput | reportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * report findMany
   */
  export type reportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportOrderByWithRelationInput | reportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reports.
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * report create
   */
  export type reportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * The data needed to create a report.
     */
    data: XOR<reportCreateInput, reportUncheckedCreateInput>
  }

  /**
   * report createMany
   */
  export type reportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reports.
     */
    data: reportCreateManyInput | reportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * report update
   */
  export type reportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * The data needed to update a report.
     */
    data: XOR<reportUpdateInput, reportUncheckedUpdateInput>
    /**
     * Choose, which report to update.
     */
    where: reportWhereUniqueInput
  }

  /**
   * report updateMany
   */
  export type reportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reports.
     */
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyInput>
    /**
     * Filter which reports to update
     */
    where?: reportWhereInput
    /**
     * Limit how many reports to update.
     */
    limit?: number
  }

  /**
   * report upsert
   */
  export type reportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * The filter to search for the report to update in case it exists.
     */
    where: reportWhereUniqueInput
    /**
     * In case the report found by the `where` argument doesn't exist, create a new report with this data.
     */
    create: XOR<reportCreateInput, reportUncheckedCreateInput>
    /**
     * In case the report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reportUpdateInput, reportUncheckedUpdateInput>
  }

  /**
   * report delete
   */
  export type reportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
    /**
     * Filter which report to delete.
     */
    where: reportWhereUniqueInput
  }

  /**
   * report deleteMany
   */
  export type reportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reports to delete
     */
    where?: reportWhereInput
    /**
     * Limit how many reports to delete.
     */
    limit?: number
  }

  /**
   * report without action
   */
  export type reportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report
     */
    omit?: reportOmit<ExtArgs> | null
  }


  /**
   * Model setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingAvgAggregateOutputType = {
    setting_id: number | null
    user_id: number | null
    created_by: number | null
    modified_by: number | null
  }

  export type SettingSumAggregateOutputType = {
    setting_id: bigint | null
    user_id: bigint | null
    created_by: bigint | null
    modified_by: bigint | null
  }

  export type SettingMinAggregateOutputType = {
    setting_id: bigint | null
    user_id: bigint | null
    notification: boolean | null
    marketing: boolean | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
  }

  export type SettingMaxAggregateOutputType = {
    setting_id: bigint | null
    user_id: bigint | null
    notification: boolean | null
    marketing: boolean | null
    created_at: Date | null
    created_by: bigint | null
    modified_at: Date | null
    modified_by: bigint | null
    deleted: boolean | null
  }

  export type SettingCountAggregateOutputType = {
    setting_id: number
    user_id: number
    notification: number
    marketing: number
    created_at: number
    created_by: number
    modified_at: number
    modified_by: number
    deleted: number
    _all: number
  }


  export type SettingAvgAggregateInputType = {
    setting_id?: true
    user_id?: true
    created_by?: true
    modified_by?: true
  }

  export type SettingSumAggregateInputType = {
    setting_id?: true
    user_id?: true
    created_by?: true
    modified_by?: true
  }

  export type SettingMinAggregateInputType = {
    setting_id?: true
    user_id?: true
    notification?: true
    marketing?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
  }

  export type SettingMaxAggregateInputType = {
    setting_id?: true
    user_id?: true
    notification?: true
    marketing?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
  }

  export type SettingCountAggregateInputType = {
    setting_id?: true
    user_id?: true
    notification?: true
    marketing?: true
    created_at?: true
    created_by?: true
    modified_at?: true
    modified_by?: true
    deleted?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which setting to aggregate.
     */
    where?: settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingOrderByWithRelationInput | settingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type settingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settingWhereInput
    orderBy?: settingOrderByWithAggregationInput | settingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: settingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _avg?: SettingAvgAggregateInputType
    _sum?: SettingSumAggregateInputType
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    setting_id: bigint
    user_id: bigint
    notification: boolean
    marketing: boolean
    created_at: Date
    created_by: bigint
    modified_at: Date
    modified_by: bigint
    deleted: boolean
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends settingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type settingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    setting_id?: boolean
    user_id?: boolean
    notification?: boolean
    marketing?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["setting"]>



  export type settingSelectScalar = {
    setting_id?: boolean
    user_id?: boolean
    notification?: boolean
    marketing?: boolean
    created_at?: boolean
    created_by?: boolean
    modified_at?: boolean
    modified_by?: boolean
    deleted?: boolean
  }

  export type settingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"setting_id" | "user_id" | "notification" | "marketing" | "created_at" | "created_by" | "modified_at" | "modified_by" | "deleted", ExtArgs["result"]["setting"]>

  export type $settingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      setting_id: bigint
      user_id: bigint
      notification: boolean
      marketing: boolean
      created_at: Date
      created_by: bigint
      modified_at: Date
      modified_by: bigint
      deleted: boolean
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type settingGetPayload<S extends boolean | null | undefined | settingDefaultArgs> = $Result.GetResult<Prisma.$settingPayload, S>

  type settingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<settingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface settingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['setting'], meta: { name: 'setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {settingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends settingFindUniqueArgs>(args: SelectSubset<T, settingFindUniqueArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {settingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends settingFindUniqueOrThrowArgs>(args: SelectSubset<T, settingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends settingFindFirstArgs>(args?: SelectSubset<T, settingFindFirstArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends settingFindFirstOrThrowArgs>(args?: SelectSubset<T, settingFindFirstOrThrowArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `setting_id`
     * const settingWithSetting_idOnly = await prisma.setting.findMany({ select: { setting_id: true } })
     * 
     */
    findMany<T extends settingFindManyArgs>(args?: SelectSubset<T, settingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {settingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends settingCreateArgs>(args: SelectSubset<T, settingCreateArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {settingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends settingCreateManyArgs>(args?: SelectSubset<T, settingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Setting.
     * @param {settingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends settingDeleteArgs>(args: SelectSubset<T, settingDeleteArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {settingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends settingUpdateArgs>(args: SelectSubset<T, settingUpdateArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {settingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends settingDeleteManyArgs>(args?: SelectSubset<T, settingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends settingUpdateManyArgs>(args: SelectSubset<T, settingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {settingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends settingUpsertArgs>(args: SelectSubset<T, settingUpsertArgs<ExtArgs>>): Prisma__settingClient<$Result.GetResult<Prisma.$settingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends settingCountArgs>(
      args?: Subset<T, settingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends settingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settingGroupByArgs['orderBy'] }
        : { orderBy?: settingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, settingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the setting model
   */
  readonly fields: settingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__settingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the setting model
   */
  interface settingFieldRefs {
    readonly setting_id: FieldRef<"setting", 'BigInt'>
    readonly user_id: FieldRef<"setting", 'BigInt'>
    readonly notification: FieldRef<"setting", 'Boolean'>
    readonly marketing: FieldRef<"setting", 'Boolean'>
    readonly created_at: FieldRef<"setting", 'DateTime'>
    readonly created_by: FieldRef<"setting", 'BigInt'>
    readonly modified_at: FieldRef<"setting", 'DateTime'>
    readonly modified_by: FieldRef<"setting", 'BigInt'>
    readonly deleted: FieldRef<"setting", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * setting findUnique
   */
  export type settingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * Filter, which setting to fetch.
     */
    where: settingWhereUniqueInput
  }

  /**
   * setting findUniqueOrThrow
   */
  export type settingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * Filter, which setting to fetch.
     */
    where: settingWhereUniqueInput
  }

  /**
   * setting findFirst
   */
  export type settingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * Filter, which setting to fetch.
     */
    where?: settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingOrderByWithRelationInput | settingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * setting findFirstOrThrow
   */
  export type settingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * Filter, which setting to fetch.
     */
    where?: settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingOrderByWithRelationInput | settingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * setting findMany
   */
  export type settingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingOrderByWithRelationInput | settingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settings.
     */
    cursor?: settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * setting create
   */
  export type settingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * The data needed to create a setting.
     */
    data: XOR<settingCreateInput, settingUncheckedCreateInput>
  }

  /**
   * setting createMany
   */
  export type settingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settings.
     */
    data: settingCreateManyInput | settingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * setting update
   */
  export type settingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * The data needed to update a setting.
     */
    data: XOR<settingUpdateInput, settingUncheckedUpdateInput>
    /**
     * Choose, which setting to update.
     */
    where: settingWhereUniqueInput
  }

  /**
   * setting updateMany
   */
  export type settingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settings.
     */
    data: XOR<settingUpdateManyMutationInput, settingUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingWhereInput
    /**
     * Limit how many settings to update.
     */
    limit?: number
  }

  /**
   * setting upsert
   */
  export type settingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * The filter to search for the setting to update in case it exists.
     */
    where: settingWhereUniqueInput
    /**
     * In case the setting found by the `where` argument doesn't exist, create a new setting with this data.
     */
    create: XOR<settingCreateInput, settingUncheckedCreateInput>
    /**
     * In case the setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settingUpdateInput, settingUncheckedUpdateInput>
  }

  /**
   * setting delete
   */
  export type settingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
    /**
     * Filter which setting to delete.
     */
    where: settingWhereUniqueInput
  }

  /**
   * setting deleteMany
   */
  export type settingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to delete
     */
    where?: settingWhereInput
    /**
     * Limit how many settings to delete.
     */
    limit?: number
  }

  /**
   * setting without action
   */
  export type settingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the setting
     */
    select?: settingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the setting
     */
    omit?: settingOmit<ExtArgs> | null
  }


  /**
   * Model today_hobby
   */

  export type AggregateToday_hobby = {
    _count: Today_hobbyCountAggregateOutputType | null
    _avg: Today_hobbyAvgAggregateOutputType | null
    _sum: Today_hobbySumAggregateOutputType | null
    _min: Today_hobbyMinAggregateOutputType | null
    _max: Today_hobbyMaxAggregateOutputType | null
  }

  export type Today_hobbyAvgAggregateOutputType = {
    today_hobby_id: number | null
    hobby_category_id: number | null
    today_theme_code: number | null
  }

  export type Today_hobbySumAggregateOutputType = {
    today_hobby_id: bigint | null
    hobby_category_id: bigint | null
    today_theme_code: bigint | null
  }

  export type Today_hobbyMinAggregateOutputType = {
    today_hobby_id: bigint | null
    hobby_category_id: bigint | null
    today_theme_code: bigint | null
    today_theme_name: string | null
    today_hobby_details_name: string | null
    today_hobby_details_description: string | null
    today_hobby_details_attributes: string | null
    today_hobby_thumbnail: string | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type Today_hobbyMaxAggregateOutputType = {
    today_hobby_id: bigint | null
    hobby_category_id: bigint | null
    today_theme_code: bigint | null
    today_theme_name: string | null
    today_hobby_details_name: string | null
    today_hobby_details_description: string | null
    today_hobby_details_attributes: string | null
    today_hobby_thumbnail: string | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type Today_hobbyCountAggregateOutputType = {
    today_hobby_id: number
    hobby_category_id: number
    today_theme_code: number
    today_theme_name: number
    today_hobby_details_name: number
    today_hobby_details_description: number
    today_hobby_details_attributes: number
    today_hobby_thumbnail: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type Today_hobbyAvgAggregateInputType = {
    today_hobby_id?: true
    hobby_category_id?: true
    today_theme_code?: true
  }

  export type Today_hobbySumAggregateInputType = {
    today_hobby_id?: true
    hobby_category_id?: true
    today_theme_code?: true
  }

  export type Today_hobbyMinAggregateInputType = {
    today_hobby_id?: true
    hobby_category_id?: true
    today_theme_code?: true
    today_theme_name?: true
    today_hobby_details_name?: true
    today_hobby_details_description?: true
    today_hobby_details_attributes?: true
    today_hobby_thumbnail?: true
    created_at?: true
    modified_at?: true
  }

  export type Today_hobbyMaxAggregateInputType = {
    today_hobby_id?: true
    hobby_category_id?: true
    today_theme_code?: true
    today_theme_name?: true
    today_hobby_details_name?: true
    today_hobby_details_description?: true
    today_hobby_details_attributes?: true
    today_hobby_thumbnail?: true
    created_at?: true
    modified_at?: true
  }

  export type Today_hobbyCountAggregateInputType = {
    today_hobby_id?: true
    hobby_category_id?: true
    today_theme_code?: true
    today_theme_name?: true
    today_hobby_details_name?: true
    today_hobby_details_description?: true
    today_hobby_details_attributes?: true
    today_hobby_thumbnail?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type Today_hobbyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which today_hobby to aggregate.
     */
    where?: today_hobbyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of today_hobbies to fetch.
     */
    orderBy?: today_hobbyOrderByWithRelationInput | today_hobbyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: today_hobbyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` today_hobbies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` today_hobbies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned today_hobbies
    **/
    _count?: true | Today_hobbyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Today_hobbyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Today_hobbySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Today_hobbyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Today_hobbyMaxAggregateInputType
  }

  export type GetToday_hobbyAggregateType<T extends Today_hobbyAggregateArgs> = {
        [P in keyof T & keyof AggregateToday_hobby]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToday_hobby[P]>
      : GetScalarType<T[P], AggregateToday_hobby[P]>
  }




  export type today_hobbyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: today_hobbyWhereInput
    orderBy?: today_hobbyOrderByWithAggregationInput | today_hobbyOrderByWithAggregationInput[]
    by: Today_hobbyScalarFieldEnum[] | Today_hobbyScalarFieldEnum
    having?: today_hobbyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Today_hobbyCountAggregateInputType | true
    _avg?: Today_hobbyAvgAggregateInputType
    _sum?: Today_hobbySumAggregateInputType
    _min?: Today_hobbyMinAggregateInputType
    _max?: Today_hobbyMaxAggregateInputType
  }

  export type Today_hobbyGroupByOutputType = {
    today_hobby_id: bigint
    hobby_category_id: bigint | null
    today_theme_code: bigint | null
    today_theme_name: string
    today_hobby_details_name: string
    today_hobby_details_description: string
    today_hobby_details_attributes: string
    today_hobby_thumbnail: string
    created_at: Date
    modified_at: Date
    _count: Today_hobbyCountAggregateOutputType | null
    _avg: Today_hobbyAvgAggregateOutputType | null
    _sum: Today_hobbySumAggregateOutputType | null
    _min: Today_hobbyMinAggregateOutputType | null
    _max: Today_hobbyMaxAggregateOutputType | null
  }

  type GetToday_hobbyGroupByPayload<T extends today_hobbyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Today_hobbyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Today_hobbyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Today_hobbyGroupByOutputType[P]>
            : GetScalarType<T[P], Today_hobbyGroupByOutputType[P]>
        }
      >
    >


  export type today_hobbySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    today_hobby_id?: boolean
    hobby_category_id?: boolean
    today_theme_code?: boolean
    today_theme_name?: boolean
    today_hobby_details_name?: boolean
    today_hobby_details_description?: boolean
    today_hobby_details_attributes?: boolean
    today_hobby_thumbnail?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["today_hobby"]>



  export type today_hobbySelectScalar = {
    today_hobby_id?: boolean
    hobby_category_id?: boolean
    today_theme_code?: boolean
    today_theme_name?: boolean
    today_hobby_details_name?: boolean
    today_hobby_details_description?: boolean
    today_hobby_details_attributes?: boolean
    today_hobby_thumbnail?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type today_hobbyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"today_hobby_id" | "hobby_category_id" | "today_theme_code" | "today_theme_name" | "today_hobby_details_name" | "today_hobby_details_description" | "today_hobby_details_attributes" | "today_hobby_thumbnail" | "created_at" | "modified_at", ExtArgs["result"]["today_hobby"]>

  export type $today_hobbyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "today_hobby"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      today_hobby_id: bigint
      hobby_category_id: bigint | null
      today_theme_code: bigint | null
      today_theme_name: string
      today_hobby_details_name: string
      today_hobby_details_description: string
      today_hobby_details_attributes: string
      today_hobby_thumbnail: string
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["today_hobby"]>
    composites: {}
  }

  type today_hobbyGetPayload<S extends boolean | null | undefined | today_hobbyDefaultArgs> = $Result.GetResult<Prisma.$today_hobbyPayload, S>

  type today_hobbyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<today_hobbyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Today_hobbyCountAggregateInputType | true
    }

  export interface today_hobbyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['today_hobby'], meta: { name: 'today_hobby' } }
    /**
     * Find zero or one Today_hobby that matches the filter.
     * @param {today_hobbyFindUniqueArgs} args - Arguments to find a Today_hobby
     * @example
     * // Get one Today_hobby
     * const today_hobby = await prisma.today_hobby.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends today_hobbyFindUniqueArgs>(args: SelectSubset<T, today_hobbyFindUniqueArgs<ExtArgs>>): Prisma__today_hobbyClient<$Result.GetResult<Prisma.$today_hobbyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Today_hobby that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {today_hobbyFindUniqueOrThrowArgs} args - Arguments to find a Today_hobby
     * @example
     * // Get one Today_hobby
     * const today_hobby = await prisma.today_hobby.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends today_hobbyFindUniqueOrThrowArgs>(args: SelectSubset<T, today_hobbyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__today_hobbyClient<$Result.GetResult<Prisma.$today_hobbyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Today_hobby that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {today_hobbyFindFirstArgs} args - Arguments to find a Today_hobby
     * @example
     * // Get one Today_hobby
     * const today_hobby = await prisma.today_hobby.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends today_hobbyFindFirstArgs>(args?: SelectSubset<T, today_hobbyFindFirstArgs<ExtArgs>>): Prisma__today_hobbyClient<$Result.GetResult<Prisma.$today_hobbyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Today_hobby that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {today_hobbyFindFirstOrThrowArgs} args - Arguments to find a Today_hobby
     * @example
     * // Get one Today_hobby
     * const today_hobby = await prisma.today_hobby.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends today_hobbyFindFirstOrThrowArgs>(args?: SelectSubset<T, today_hobbyFindFirstOrThrowArgs<ExtArgs>>): Prisma__today_hobbyClient<$Result.GetResult<Prisma.$today_hobbyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Today_hobbies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {today_hobbyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Today_hobbies
     * const today_hobbies = await prisma.today_hobby.findMany()
     * 
     * // Get first 10 Today_hobbies
     * const today_hobbies = await prisma.today_hobby.findMany({ take: 10 })
     * 
     * // Only select the `today_hobby_id`
     * const today_hobbyWithToday_hobby_idOnly = await prisma.today_hobby.findMany({ select: { today_hobby_id: true } })
     * 
     */
    findMany<T extends today_hobbyFindManyArgs>(args?: SelectSubset<T, today_hobbyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$today_hobbyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Today_hobby.
     * @param {today_hobbyCreateArgs} args - Arguments to create a Today_hobby.
     * @example
     * // Create one Today_hobby
     * const Today_hobby = await prisma.today_hobby.create({
     *   data: {
     *     // ... data to create a Today_hobby
     *   }
     * })
     * 
     */
    create<T extends today_hobbyCreateArgs>(args: SelectSubset<T, today_hobbyCreateArgs<ExtArgs>>): Prisma__today_hobbyClient<$Result.GetResult<Prisma.$today_hobbyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Today_hobbies.
     * @param {today_hobbyCreateManyArgs} args - Arguments to create many Today_hobbies.
     * @example
     * // Create many Today_hobbies
     * const today_hobby = await prisma.today_hobby.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends today_hobbyCreateManyArgs>(args?: SelectSubset<T, today_hobbyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Today_hobby.
     * @param {today_hobbyDeleteArgs} args - Arguments to delete one Today_hobby.
     * @example
     * // Delete one Today_hobby
     * const Today_hobby = await prisma.today_hobby.delete({
     *   where: {
     *     // ... filter to delete one Today_hobby
     *   }
     * })
     * 
     */
    delete<T extends today_hobbyDeleteArgs>(args: SelectSubset<T, today_hobbyDeleteArgs<ExtArgs>>): Prisma__today_hobbyClient<$Result.GetResult<Prisma.$today_hobbyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Today_hobby.
     * @param {today_hobbyUpdateArgs} args - Arguments to update one Today_hobby.
     * @example
     * // Update one Today_hobby
     * const today_hobby = await prisma.today_hobby.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends today_hobbyUpdateArgs>(args: SelectSubset<T, today_hobbyUpdateArgs<ExtArgs>>): Prisma__today_hobbyClient<$Result.GetResult<Prisma.$today_hobbyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Today_hobbies.
     * @param {today_hobbyDeleteManyArgs} args - Arguments to filter Today_hobbies to delete.
     * @example
     * // Delete a few Today_hobbies
     * const { count } = await prisma.today_hobby.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends today_hobbyDeleteManyArgs>(args?: SelectSubset<T, today_hobbyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Today_hobbies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {today_hobbyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Today_hobbies
     * const today_hobby = await prisma.today_hobby.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends today_hobbyUpdateManyArgs>(args: SelectSubset<T, today_hobbyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Today_hobby.
     * @param {today_hobbyUpsertArgs} args - Arguments to update or create a Today_hobby.
     * @example
     * // Update or create a Today_hobby
     * const today_hobby = await prisma.today_hobby.upsert({
     *   create: {
     *     // ... data to create a Today_hobby
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Today_hobby we want to update
     *   }
     * })
     */
    upsert<T extends today_hobbyUpsertArgs>(args: SelectSubset<T, today_hobbyUpsertArgs<ExtArgs>>): Prisma__today_hobbyClient<$Result.GetResult<Prisma.$today_hobbyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Today_hobbies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {today_hobbyCountArgs} args - Arguments to filter Today_hobbies to count.
     * @example
     * // Count the number of Today_hobbies
     * const count = await prisma.today_hobby.count({
     *   where: {
     *     // ... the filter for the Today_hobbies we want to count
     *   }
     * })
    **/
    count<T extends today_hobbyCountArgs>(
      args?: Subset<T, today_hobbyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Today_hobbyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Today_hobby.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Today_hobbyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Today_hobbyAggregateArgs>(args: Subset<T, Today_hobbyAggregateArgs>): Prisma.PrismaPromise<GetToday_hobbyAggregateType<T>>

    /**
     * Group by Today_hobby.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {today_hobbyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends today_hobbyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: today_hobbyGroupByArgs['orderBy'] }
        : { orderBy?: today_hobbyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, today_hobbyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToday_hobbyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the today_hobby model
   */
  readonly fields: today_hobbyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for today_hobby.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__today_hobbyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the today_hobby model
   */
  interface today_hobbyFieldRefs {
    readonly today_hobby_id: FieldRef<"today_hobby", 'BigInt'>
    readonly hobby_category_id: FieldRef<"today_hobby", 'BigInt'>
    readonly today_theme_code: FieldRef<"today_hobby", 'BigInt'>
    readonly today_theme_name: FieldRef<"today_hobby", 'String'>
    readonly today_hobby_details_name: FieldRef<"today_hobby", 'String'>
    readonly today_hobby_details_description: FieldRef<"today_hobby", 'String'>
    readonly today_hobby_details_attributes: FieldRef<"today_hobby", 'String'>
    readonly today_hobby_thumbnail: FieldRef<"today_hobby", 'String'>
    readonly created_at: FieldRef<"today_hobby", 'DateTime'>
    readonly modified_at: FieldRef<"today_hobby", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * today_hobby findUnique
   */
  export type today_hobbyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the today_hobby
     */
    select?: today_hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the today_hobby
     */
    omit?: today_hobbyOmit<ExtArgs> | null
    /**
     * Filter, which today_hobby to fetch.
     */
    where: today_hobbyWhereUniqueInput
  }

  /**
   * today_hobby findUniqueOrThrow
   */
  export type today_hobbyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the today_hobby
     */
    select?: today_hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the today_hobby
     */
    omit?: today_hobbyOmit<ExtArgs> | null
    /**
     * Filter, which today_hobby to fetch.
     */
    where: today_hobbyWhereUniqueInput
  }

  /**
   * today_hobby findFirst
   */
  export type today_hobbyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the today_hobby
     */
    select?: today_hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the today_hobby
     */
    omit?: today_hobbyOmit<ExtArgs> | null
    /**
     * Filter, which today_hobby to fetch.
     */
    where?: today_hobbyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of today_hobbies to fetch.
     */
    orderBy?: today_hobbyOrderByWithRelationInput | today_hobbyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for today_hobbies.
     */
    cursor?: today_hobbyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` today_hobbies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` today_hobbies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of today_hobbies.
     */
    distinct?: Today_hobbyScalarFieldEnum | Today_hobbyScalarFieldEnum[]
  }

  /**
   * today_hobby findFirstOrThrow
   */
  export type today_hobbyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the today_hobby
     */
    select?: today_hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the today_hobby
     */
    omit?: today_hobbyOmit<ExtArgs> | null
    /**
     * Filter, which today_hobby to fetch.
     */
    where?: today_hobbyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of today_hobbies to fetch.
     */
    orderBy?: today_hobbyOrderByWithRelationInput | today_hobbyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for today_hobbies.
     */
    cursor?: today_hobbyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` today_hobbies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` today_hobbies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of today_hobbies.
     */
    distinct?: Today_hobbyScalarFieldEnum | Today_hobbyScalarFieldEnum[]
  }

  /**
   * today_hobby findMany
   */
  export type today_hobbyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the today_hobby
     */
    select?: today_hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the today_hobby
     */
    omit?: today_hobbyOmit<ExtArgs> | null
    /**
     * Filter, which today_hobbies to fetch.
     */
    where?: today_hobbyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of today_hobbies to fetch.
     */
    orderBy?: today_hobbyOrderByWithRelationInput | today_hobbyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing today_hobbies.
     */
    cursor?: today_hobbyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` today_hobbies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` today_hobbies.
     */
    skip?: number
    distinct?: Today_hobbyScalarFieldEnum | Today_hobbyScalarFieldEnum[]
  }

  /**
   * today_hobby create
   */
  export type today_hobbyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the today_hobby
     */
    select?: today_hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the today_hobby
     */
    omit?: today_hobbyOmit<ExtArgs> | null
    /**
     * The data needed to create a today_hobby.
     */
    data: XOR<today_hobbyCreateInput, today_hobbyUncheckedCreateInput>
  }

  /**
   * today_hobby createMany
   */
  export type today_hobbyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many today_hobbies.
     */
    data: today_hobbyCreateManyInput | today_hobbyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * today_hobby update
   */
  export type today_hobbyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the today_hobby
     */
    select?: today_hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the today_hobby
     */
    omit?: today_hobbyOmit<ExtArgs> | null
    /**
     * The data needed to update a today_hobby.
     */
    data: XOR<today_hobbyUpdateInput, today_hobbyUncheckedUpdateInput>
    /**
     * Choose, which today_hobby to update.
     */
    where: today_hobbyWhereUniqueInput
  }

  /**
   * today_hobby updateMany
   */
  export type today_hobbyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update today_hobbies.
     */
    data: XOR<today_hobbyUpdateManyMutationInput, today_hobbyUncheckedUpdateManyInput>
    /**
     * Filter which today_hobbies to update
     */
    where?: today_hobbyWhereInput
    /**
     * Limit how many today_hobbies to update.
     */
    limit?: number
  }

  /**
   * today_hobby upsert
   */
  export type today_hobbyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the today_hobby
     */
    select?: today_hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the today_hobby
     */
    omit?: today_hobbyOmit<ExtArgs> | null
    /**
     * The filter to search for the today_hobby to update in case it exists.
     */
    where: today_hobbyWhereUniqueInput
    /**
     * In case the today_hobby found by the `where` argument doesn't exist, create a new today_hobby with this data.
     */
    create: XOR<today_hobbyCreateInput, today_hobbyUncheckedCreateInput>
    /**
     * In case the today_hobby was found with the provided `where` argument, update it with this data.
     */
    update: XOR<today_hobbyUpdateInput, today_hobbyUncheckedUpdateInput>
  }

  /**
   * today_hobby delete
   */
  export type today_hobbyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the today_hobby
     */
    select?: today_hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the today_hobby
     */
    omit?: today_hobbyOmit<ExtArgs> | null
    /**
     * Filter which today_hobby to delete.
     */
    where: today_hobbyWhereUniqueInput
  }

  /**
   * today_hobby deleteMany
   */
  export type today_hobbyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which today_hobbies to delete
     */
    where?: today_hobbyWhereInput
    /**
     * Limit how many today_hobbies to delete.
     */
    limit?: number
  }

  /**
   * today_hobby without action
   */
  export type today_hobbyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the today_hobby
     */
    select?: today_hobbySelect<ExtArgs> | null
    /**
     * Omit specific fields from the today_hobby
     */
    omit?: today_hobbyOmit<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    user_id: number | null
  }

  export type UserSumAggregateOutputType = {
    user_id: bigint | null
  }

  export type UserMinAggregateOutputType = {
    user_id: bigint | null
    user_email: string | null
    user_profile: string | null
    user_password: string | null
    user_type: $Enums.user_user_type | null
    user_nickname: string | null
    provider_type: $Enums.user_provider_type | null
    provider_key: string | null
    created_at: Date | null
    modified_at: Date | null
    user_last_login_date: Date | null
    deleted: boolean | null
    dormancy: boolean | null
    refresh_token: string | null
    profile_description: string | null
  }

  export type UserMaxAggregateOutputType = {
    user_id: bigint | null
    user_email: string | null
    user_profile: string | null
    user_password: string | null
    user_type: $Enums.user_user_type | null
    user_nickname: string | null
    provider_type: $Enums.user_provider_type | null
    provider_key: string | null
    created_at: Date | null
    modified_at: Date | null
    user_last_login_date: Date | null
    deleted: boolean | null
    dormancy: boolean | null
    refresh_token: string | null
    profile_description: string | null
  }

  export type UserCountAggregateOutputType = {
    user_id: number
    user_email: number
    user_profile: number
    user_password: number
    user_type: number
    user_nickname: number
    provider_type: number
    provider_key: number
    created_at: number
    modified_at: number
    user_last_login_date: number
    deleted: number
    dormancy: number
    refresh_token: number
    profile_description: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    user_id?: true
  }

  export type UserSumAggregateInputType = {
    user_id?: true
  }

  export type UserMinAggregateInputType = {
    user_id?: true
    user_email?: true
    user_profile?: true
    user_password?: true
    user_type?: true
    user_nickname?: true
    provider_type?: true
    provider_key?: true
    created_at?: true
    modified_at?: true
    user_last_login_date?: true
    deleted?: true
    dormancy?: true
    refresh_token?: true
    profile_description?: true
  }

  export type UserMaxAggregateInputType = {
    user_id?: true
    user_email?: true
    user_profile?: true
    user_password?: true
    user_type?: true
    user_nickname?: true
    provider_type?: true
    provider_key?: true
    created_at?: true
    modified_at?: true
    user_last_login_date?: true
    deleted?: true
    dormancy?: true
    refresh_token?: true
    profile_description?: true
  }

  export type UserCountAggregateInputType = {
    user_id?: true
    user_email?: true
    user_profile?: true
    user_password?: true
    user_type?: true
    user_nickname?: true
    provider_type?: true
    provider_key?: true
    created_at?: true
    modified_at?: true
    user_last_login_date?: true
    deleted?: true
    dormancy?: true
    refresh_token?: true
    profile_description?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    user_id: bigint
    user_email: string | null
    user_profile: string | null
    user_password: string | null
    user_type: $Enums.user_user_type
    user_nickname: string | null
    provider_type: $Enums.user_provider_type
    provider_key: string | null
    created_at: Date
    modified_at: Date
    user_last_login_date: Date
    deleted: boolean
    dormancy: boolean
    refresh_token: string | null
    profile_description: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    user_email?: boolean
    user_profile?: boolean
    user_password?: boolean
    user_type?: boolean
    user_nickname?: boolean
    provider_type?: boolean
    provider_key?: boolean
    created_at?: boolean
    modified_at?: boolean
    user_last_login_date?: boolean
    deleted?: boolean
    dormancy?: boolean
    refresh_token?: boolean
    profile_description?: boolean
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    user_id?: boolean
    user_email?: boolean
    user_profile?: boolean
    user_password?: boolean
    user_type?: boolean
    user_nickname?: boolean
    provider_type?: boolean
    provider_key?: boolean
    created_at?: boolean
    modified_at?: boolean
    user_last_login_date?: boolean
    deleted?: boolean
    dormancy?: boolean
    refresh_token?: boolean
    profile_description?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "user_email" | "user_profile" | "user_password" | "user_type" | "user_nickname" | "provider_type" | "provider_key" | "created_at" | "modified_at" | "user_last_login_date" | "deleted" | "dormancy" | "refresh_token" | "profile_description", ExtArgs["result"]["user"]>

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      user_email: string | null
      user_profile: string | null
      user_password: string | null
      user_type: $Enums.user_user_type
      user_nickname: string | null
      provider_type: $Enums.user_provider_type
      provider_key: string | null
      created_at: Date
      modified_at: Date
      user_last_login_date: Date
      deleted: boolean
      dormancy: boolean
      refresh_token: string | null
      profile_description: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userWithUser_idOnly = await prisma.user.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly user_id: FieldRef<"user", 'BigInt'>
    readonly user_email: FieldRef<"user", 'String'>
    readonly user_profile: FieldRef<"user", 'String'>
    readonly user_password: FieldRef<"user", 'String'>
    readonly user_type: FieldRef<"user", 'user_user_type'>
    readonly user_nickname: FieldRef<"user", 'String'>
    readonly provider_type: FieldRef<"user", 'user_provider_type'>
    readonly provider_key: FieldRef<"user", 'String'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly modified_at: FieldRef<"user", 'DateTime'>
    readonly user_last_login_date: FieldRef<"user", 'DateTime'>
    readonly deleted: FieldRef<"user", 'Boolean'>
    readonly dormancy: FieldRef<"user", 'Boolean'>
    readonly refresh_token: FieldRef<"user", 'String'>
    readonly profile_description: FieldRef<"user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
  }


  /**
   * Model user_metrics
   */

  export type AggregateUser_metrics = {
    _count: User_metricsCountAggregateOutputType | null
    _avg: User_metricsAvgAggregateOutputType | null
    _sum: User_metricsSumAggregateOutputType | null
    _min: User_metricsMinAggregateOutputType | null
    _max: User_metricsMaxAggregateOutputType | null
  }

  export type User_metricsAvgAggregateOutputType = {
    id: number | null
    new_users: number | null
    total_users: number | null
  }

  export type User_metricsSumAggregateOutputType = {
    id: bigint | null
    new_users: bigint | null
    total_users: bigint | null
  }

  export type User_metricsMinAggregateOutputType = {
    id: bigint | null
    new_users: bigint | null
    total_users: bigint | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type User_metricsMaxAggregateOutputType = {
    id: bigint | null
    new_users: bigint | null
    total_users: bigint | null
    created_at: Date | null
    modified_at: Date | null
  }

  export type User_metricsCountAggregateOutputType = {
    id: number
    new_users: number
    total_users: number
    created_at: number
    modified_at: number
    _all: number
  }


  export type User_metricsAvgAggregateInputType = {
    id?: true
    new_users?: true
    total_users?: true
  }

  export type User_metricsSumAggregateInputType = {
    id?: true
    new_users?: true
    total_users?: true
  }

  export type User_metricsMinAggregateInputType = {
    id?: true
    new_users?: true
    total_users?: true
    created_at?: true
    modified_at?: true
  }

  export type User_metricsMaxAggregateInputType = {
    id?: true
    new_users?: true
    total_users?: true
    created_at?: true
    modified_at?: true
  }

  export type User_metricsCountAggregateInputType = {
    id?: true
    new_users?: true
    total_users?: true
    created_at?: true
    modified_at?: true
    _all?: true
  }

  export type User_metricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_metrics to aggregate.
     */
    where?: user_metricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_metrics to fetch.
     */
    orderBy?: user_metricsOrderByWithRelationInput | user_metricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_metricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_metrics
    **/
    _count?: true | User_metricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_metricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_metricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_metricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_metricsMaxAggregateInputType
  }

  export type GetUser_metricsAggregateType<T extends User_metricsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_metrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_metrics[P]>
      : GetScalarType<T[P], AggregateUser_metrics[P]>
  }




  export type user_metricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_metricsWhereInput
    orderBy?: user_metricsOrderByWithAggregationInput | user_metricsOrderByWithAggregationInput[]
    by: User_metricsScalarFieldEnum[] | User_metricsScalarFieldEnum
    having?: user_metricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_metricsCountAggregateInputType | true
    _avg?: User_metricsAvgAggregateInputType
    _sum?: User_metricsSumAggregateInputType
    _min?: User_metricsMinAggregateInputType
    _max?: User_metricsMaxAggregateInputType
  }

  export type User_metricsGroupByOutputType = {
    id: bigint
    new_users: bigint
    total_users: bigint
    created_at: Date
    modified_at: Date
    _count: User_metricsCountAggregateOutputType | null
    _avg: User_metricsAvgAggregateOutputType | null
    _sum: User_metricsSumAggregateOutputType | null
    _min: User_metricsMinAggregateOutputType | null
    _max: User_metricsMaxAggregateOutputType | null
  }

  type GetUser_metricsGroupByPayload<T extends user_metricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_metricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_metricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_metricsGroupByOutputType[P]>
            : GetScalarType<T[P], User_metricsGroupByOutputType[P]>
        }
      >
    >


  export type user_metricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    new_users?: boolean
    total_users?: boolean
    created_at?: boolean
    modified_at?: boolean
  }, ExtArgs["result"]["user_metrics"]>



  export type user_metricsSelectScalar = {
    id?: boolean
    new_users?: boolean
    total_users?: boolean
    created_at?: boolean
    modified_at?: boolean
  }

  export type user_metricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "new_users" | "total_users" | "created_at" | "modified_at", ExtArgs["result"]["user_metrics"]>

  export type $user_metricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_metrics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      new_users: bigint
      total_users: bigint
      created_at: Date
      modified_at: Date
    }, ExtArgs["result"]["user_metrics"]>
    composites: {}
  }

  type user_metricsGetPayload<S extends boolean | null | undefined | user_metricsDefaultArgs> = $Result.GetResult<Prisma.$user_metricsPayload, S>

  type user_metricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_metricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_metricsCountAggregateInputType | true
    }

  export interface user_metricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_metrics'], meta: { name: 'user_metrics' } }
    /**
     * Find zero or one User_metrics that matches the filter.
     * @param {user_metricsFindUniqueArgs} args - Arguments to find a User_metrics
     * @example
     * // Get one User_metrics
     * const user_metrics = await prisma.user_metrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_metricsFindUniqueArgs>(args: SelectSubset<T, user_metricsFindUniqueArgs<ExtArgs>>): Prisma__user_metricsClient<$Result.GetResult<Prisma.$user_metricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_metrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_metricsFindUniqueOrThrowArgs} args - Arguments to find a User_metrics
     * @example
     * // Get one User_metrics
     * const user_metrics = await prisma.user_metrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_metricsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_metricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_metricsClient<$Result.GetResult<Prisma.$user_metricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_metrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_metricsFindFirstArgs} args - Arguments to find a User_metrics
     * @example
     * // Get one User_metrics
     * const user_metrics = await prisma.user_metrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_metricsFindFirstArgs>(args?: SelectSubset<T, user_metricsFindFirstArgs<ExtArgs>>): Prisma__user_metricsClient<$Result.GetResult<Prisma.$user_metricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_metrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_metricsFindFirstOrThrowArgs} args - Arguments to find a User_metrics
     * @example
     * // Get one User_metrics
     * const user_metrics = await prisma.user_metrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_metricsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_metricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_metricsClient<$Result.GetResult<Prisma.$user_metricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_metrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_metricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_metrics
     * const user_metrics = await prisma.user_metrics.findMany()
     * 
     * // Get first 10 User_metrics
     * const user_metrics = await prisma.user_metrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_metricsWithIdOnly = await prisma.user_metrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_metricsFindManyArgs>(args?: SelectSubset<T, user_metricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_metricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_metrics.
     * @param {user_metricsCreateArgs} args - Arguments to create a User_metrics.
     * @example
     * // Create one User_metrics
     * const User_metrics = await prisma.user_metrics.create({
     *   data: {
     *     // ... data to create a User_metrics
     *   }
     * })
     * 
     */
    create<T extends user_metricsCreateArgs>(args: SelectSubset<T, user_metricsCreateArgs<ExtArgs>>): Prisma__user_metricsClient<$Result.GetResult<Prisma.$user_metricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_metrics.
     * @param {user_metricsCreateManyArgs} args - Arguments to create many User_metrics.
     * @example
     * // Create many User_metrics
     * const user_metrics = await prisma.user_metrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_metricsCreateManyArgs>(args?: SelectSubset<T, user_metricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_metrics.
     * @param {user_metricsDeleteArgs} args - Arguments to delete one User_metrics.
     * @example
     * // Delete one User_metrics
     * const User_metrics = await prisma.user_metrics.delete({
     *   where: {
     *     // ... filter to delete one User_metrics
     *   }
     * })
     * 
     */
    delete<T extends user_metricsDeleteArgs>(args: SelectSubset<T, user_metricsDeleteArgs<ExtArgs>>): Prisma__user_metricsClient<$Result.GetResult<Prisma.$user_metricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_metrics.
     * @param {user_metricsUpdateArgs} args - Arguments to update one User_metrics.
     * @example
     * // Update one User_metrics
     * const user_metrics = await prisma.user_metrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_metricsUpdateArgs>(args: SelectSubset<T, user_metricsUpdateArgs<ExtArgs>>): Prisma__user_metricsClient<$Result.GetResult<Prisma.$user_metricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_metrics.
     * @param {user_metricsDeleteManyArgs} args - Arguments to filter User_metrics to delete.
     * @example
     * // Delete a few User_metrics
     * const { count } = await prisma.user_metrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_metricsDeleteManyArgs>(args?: SelectSubset<T, user_metricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_metricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_metrics
     * const user_metrics = await prisma.user_metrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_metricsUpdateManyArgs>(args: SelectSubset<T, user_metricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_metrics.
     * @param {user_metricsUpsertArgs} args - Arguments to update or create a User_metrics.
     * @example
     * // Update or create a User_metrics
     * const user_metrics = await prisma.user_metrics.upsert({
     *   create: {
     *     // ... data to create a User_metrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_metrics we want to update
     *   }
     * })
     */
    upsert<T extends user_metricsUpsertArgs>(args: SelectSubset<T, user_metricsUpsertArgs<ExtArgs>>): Prisma__user_metricsClient<$Result.GetResult<Prisma.$user_metricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_metricsCountArgs} args - Arguments to filter User_metrics to count.
     * @example
     * // Count the number of User_metrics
     * const count = await prisma.user_metrics.count({
     *   where: {
     *     // ... the filter for the User_metrics we want to count
     *   }
     * })
    **/
    count<T extends user_metricsCountArgs>(
      args?: Subset<T, user_metricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_metricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_metricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_metricsAggregateArgs>(args: Subset<T, User_metricsAggregateArgs>): Prisma.PrismaPromise<GetUser_metricsAggregateType<T>>

    /**
     * Group by User_metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_metricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_metricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_metricsGroupByArgs['orderBy'] }
        : { orderBy?: user_metricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_metricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_metricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_metrics model
   */
  readonly fields: user_metricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_metrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_metricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_metrics model
   */
  interface user_metricsFieldRefs {
    readonly id: FieldRef<"user_metrics", 'BigInt'>
    readonly new_users: FieldRef<"user_metrics", 'BigInt'>
    readonly total_users: FieldRef<"user_metrics", 'BigInt'>
    readonly created_at: FieldRef<"user_metrics", 'DateTime'>
    readonly modified_at: FieldRef<"user_metrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_metrics findUnique
   */
  export type user_metricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_metrics
     */
    select?: user_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_metrics
     */
    omit?: user_metricsOmit<ExtArgs> | null
    /**
     * Filter, which user_metrics to fetch.
     */
    where: user_metricsWhereUniqueInput
  }

  /**
   * user_metrics findUniqueOrThrow
   */
  export type user_metricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_metrics
     */
    select?: user_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_metrics
     */
    omit?: user_metricsOmit<ExtArgs> | null
    /**
     * Filter, which user_metrics to fetch.
     */
    where: user_metricsWhereUniqueInput
  }

  /**
   * user_metrics findFirst
   */
  export type user_metricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_metrics
     */
    select?: user_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_metrics
     */
    omit?: user_metricsOmit<ExtArgs> | null
    /**
     * Filter, which user_metrics to fetch.
     */
    where?: user_metricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_metrics to fetch.
     */
    orderBy?: user_metricsOrderByWithRelationInput | user_metricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_metrics.
     */
    cursor?: user_metricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_metrics.
     */
    distinct?: User_metricsScalarFieldEnum | User_metricsScalarFieldEnum[]
  }

  /**
   * user_metrics findFirstOrThrow
   */
  export type user_metricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_metrics
     */
    select?: user_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_metrics
     */
    omit?: user_metricsOmit<ExtArgs> | null
    /**
     * Filter, which user_metrics to fetch.
     */
    where?: user_metricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_metrics to fetch.
     */
    orderBy?: user_metricsOrderByWithRelationInput | user_metricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_metrics.
     */
    cursor?: user_metricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_metrics.
     */
    distinct?: User_metricsScalarFieldEnum | User_metricsScalarFieldEnum[]
  }

  /**
   * user_metrics findMany
   */
  export type user_metricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_metrics
     */
    select?: user_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_metrics
     */
    omit?: user_metricsOmit<ExtArgs> | null
    /**
     * Filter, which user_metrics to fetch.
     */
    where?: user_metricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_metrics to fetch.
     */
    orderBy?: user_metricsOrderByWithRelationInput | user_metricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_metrics.
     */
    cursor?: user_metricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_metrics.
     */
    skip?: number
    distinct?: User_metricsScalarFieldEnum | User_metricsScalarFieldEnum[]
  }

  /**
   * user_metrics create
   */
  export type user_metricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_metrics
     */
    select?: user_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_metrics
     */
    omit?: user_metricsOmit<ExtArgs> | null
    /**
     * The data needed to create a user_metrics.
     */
    data: XOR<user_metricsCreateInput, user_metricsUncheckedCreateInput>
  }

  /**
   * user_metrics createMany
   */
  export type user_metricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_metrics.
     */
    data: user_metricsCreateManyInput | user_metricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_metrics update
   */
  export type user_metricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_metrics
     */
    select?: user_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_metrics
     */
    omit?: user_metricsOmit<ExtArgs> | null
    /**
     * The data needed to update a user_metrics.
     */
    data: XOR<user_metricsUpdateInput, user_metricsUncheckedUpdateInput>
    /**
     * Choose, which user_metrics to update.
     */
    where: user_metricsWhereUniqueInput
  }

  /**
   * user_metrics updateMany
   */
  export type user_metricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_metrics.
     */
    data: XOR<user_metricsUpdateManyMutationInput, user_metricsUncheckedUpdateManyInput>
    /**
     * Filter which user_metrics to update
     */
    where?: user_metricsWhereInput
    /**
     * Limit how many user_metrics to update.
     */
    limit?: number
  }

  /**
   * user_metrics upsert
   */
  export type user_metricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_metrics
     */
    select?: user_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_metrics
     */
    omit?: user_metricsOmit<ExtArgs> | null
    /**
     * The filter to search for the user_metrics to update in case it exists.
     */
    where: user_metricsWhereUniqueInput
    /**
     * In case the user_metrics found by the `where` argument doesn't exist, create a new user_metrics with this data.
     */
    create: XOR<user_metricsCreateInput, user_metricsUncheckedCreateInput>
    /**
     * In case the user_metrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_metricsUpdateInput, user_metricsUncheckedUpdateInput>
  }

  /**
   * user_metrics delete
   */
  export type user_metricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_metrics
     */
    select?: user_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_metrics
     */
    omit?: user_metricsOmit<ExtArgs> | null
    /**
     * Filter which user_metrics to delete.
     */
    where: user_metricsWhereUniqueInput
  }

  /**
   * user_metrics deleteMany
   */
  export type user_metricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_metrics to delete
     */
    where?: user_metricsWhereInput
    /**
     * Limit how many user_metrics to delete.
     */
    limit?: number
  }

  /**
   * user_metrics without action
   */
  export type user_metricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_metrics
     */
    select?: user_metricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_metrics
     */
    omit?: user_metricsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const QRTZ_BLOB_TRIGGERSScalarFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    TRIGGER_NAME: 'TRIGGER_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP',
    BLOB_DATA: 'BLOB_DATA'
  };

  export type QRTZ_BLOB_TRIGGERSScalarFieldEnum = (typeof QRTZ_BLOB_TRIGGERSScalarFieldEnum)[keyof typeof QRTZ_BLOB_TRIGGERSScalarFieldEnum]


  export const QRTZ_CALENDARSScalarFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    CALENDAR_NAME: 'CALENDAR_NAME',
    CALENDAR: 'CALENDAR'
  };

  export type QRTZ_CALENDARSScalarFieldEnum = (typeof QRTZ_CALENDARSScalarFieldEnum)[keyof typeof QRTZ_CALENDARSScalarFieldEnum]


  export const QRTZ_CRON_TRIGGERSScalarFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    TRIGGER_NAME: 'TRIGGER_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP',
    CRON_EXPRESSION: 'CRON_EXPRESSION',
    TIME_ZONE_ID: 'TIME_ZONE_ID'
  };

  export type QRTZ_CRON_TRIGGERSScalarFieldEnum = (typeof QRTZ_CRON_TRIGGERSScalarFieldEnum)[keyof typeof QRTZ_CRON_TRIGGERSScalarFieldEnum]


  export const QRTZ_FIRED_TRIGGERSScalarFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    ENTRY_ID: 'ENTRY_ID',
    TRIGGER_NAME: 'TRIGGER_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP',
    INSTANCE_NAME: 'INSTANCE_NAME',
    FIRED_TIME: 'FIRED_TIME',
    SCHED_TIME: 'SCHED_TIME',
    PRIORITY: 'PRIORITY',
    STATE: 'STATE',
    JOB_NAME: 'JOB_NAME',
    JOB_GROUP: 'JOB_GROUP',
    IS_NONCONCURRENT: 'IS_NONCONCURRENT',
    REQUESTS_RECOVERY: 'REQUESTS_RECOVERY'
  };

  export type QRTZ_FIRED_TRIGGERSScalarFieldEnum = (typeof QRTZ_FIRED_TRIGGERSScalarFieldEnum)[keyof typeof QRTZ_FIRED_TRIGGERSScalarFieldEnum]


  export const QRTZ_JOB_DETAILSScalarFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    JOB_NAME: 'JOB_NAME',
    JOB_GROUP: 'JOB_GROUP',
    DESCRIPTION: 'DESCRIPTION',
    JOB_CLASS_NAME: 'JOB_CLASS_NAME',
    IS_DURABLE: 'IS_DURABLE',
    IS_NONCONCURRENT: 'IS_NONCONCURRENT',
    IS_UPDATE_DATA: 'IS_UPDATE_DATA',
    REQUESTS_RECOVERY: 'REQUESTS_RECOVERY',
    JOB_DATA: 'JOB_DATA'
  };

  export type QRTZ_JOB_DETAILSScalarFieldEnum = (typeof QRTZ_JOB_DETAILSScalarFieldEnum)[keyof typeof QRTZ_JOB_DETAILSScalarFieldEnum]


  export const QRTZ_LOCKSScalarFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    LOCK_NAME: 'LOCK_NAME'
  };

  export type QRTZ_LOCKSScalarFieldEnum = (typeof QRTZ_LOCKSScalarFieldEnum)[keyof typeof QRTZ_LOCKSScalarFieldEnum]


  export const QRTZ_PAUSED_TRIGGER_GRPSScalarFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP'
  };

  export type QRTZ_PAUSED_TRIGGER_GRPSScalarFieldEnum = (typeof QRTZ_PAUSED_TRIGGER_GRPSScalarFieldEnum)[keyof typeof QRTZ_PAUSED_TRIGGER_GRPSScalarFieldEnum]


  export const QRTZ_SCHEDULER_STATEScalarFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    INSTANCE_NAME: 'INSTANCE_NAME',
    LAST_CHECKIN_TIME: 'LAST_CHECKIN_TIME',
    CHECKIN_INTERVAL: 'CHECKIN_INTERVAL'
  };

  export type QRTZ_SCHEDULER_STATEScalarFieldEnum = (typeof QRTZ_SCHEDULER_STATEScalarFieldEnum)[keyof typeof QRTZ_SCHEDULER_STATEScalarFieldEnum]


  export const QRTZ_SIMPLE_TRIGGERSScalarFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    TRIGGER_NAME: 'TRIGGER_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP',
    REPEAT_COUNT: 'REPEAT_COUNT',
    REPEAT_INTERVAL: 'REPEAT_INTERVAL',
    TIMES_TRIGGERED: 'TIMES_TRIGGERED'
  };

  export type QRTZ_SIMPLE_TRIGGERSScalarFieldEnum = (typeof QRTZ_SIMPLE_TRIGGERSScalarFieldEnum)[keyof typeof QRTZ_SIMPLE_TRIGGERSScalarFieldEnum]


  export const QRTZ_SIMPROP_TRIGGERSScalarFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    TRIGGER_NAME: 'TRIGGER_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP',
    STR_PROP_1: 'STR_PROP_1',
    STR_PROP_2: 'STR_PROP_2',
    STR_PROP_3: 'STR_PROP_3',
    INT_PROP_1: 'INT_PROP_1',
    INT_PROP_2: 'INT_PROP_2',
    LONG_PROP_1: 'LONG_PROP_1',
    LONG_PROP_2: 'LONG_PROP_2',
    DEC_PROP_1: 'DEC_PROP_1',
    DEC_PROP_2: 'DEC_PROP_2',
    BOOL_PROP_1: 'BOOL_PROP_1',
    BOOL_PROP_2: 'BOOL_PROP_2'
  };

  export type QRTZ_SIMPROP_TRIGGERSScalarFieldEnum = (typeof QRTZ_SIMPROP_TRIGGERSScalarFieldEnum)[keyof typeof QRTZ_SIMPROP_TRIGGERSScalarFieldEnum]


  export const QRTZ_TRIGGERSScalarFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    TRIGGER_NAME: 'TRIGGER_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP',
    JOB_NAME: 'JOB_NAME',
    JOB_GROUP: 'JOB_GROUP',
    DESCRIPTION: 'DESCRIPTION',
    NEXT_FIRE_TIME: 'NEXT_FIRE_TIME',
    PREV_FIRE_TIME: 'PREV_FIRE_TIME',
    PRIORITY: 'PRIORITY',
    TRIGGER_STATE: 'TRIGGER_STATE',
    TRIGGER_TYPE: 'TRIGGER_TYPE',
    START_TIME: 'START_TIME',
    END_TIME: 'END_TIME',
    CALENDAR_NAME: 'CALENDAR_NAME',
    MISFIRE_INSTR: 'MISFIRE_INSTR',
    JOB_DATA: 'JOB_DATA'
  };

  export type QRTZ_TRIGGERSScalarFieldEnum = (typeof QRTZ_TRIGGERSScalarFieldEnum)[keyof typeof QRTZ_TRIGGERSScalarFieldEnum]


  export const BagScalarFieldEnum: {
    bag_id: 'bag_id'
  };

  export type BagScalarFieldEnum = (typeof BagScalarFieldEnum)[keyof typeof BagScalarFieldEnum]


  export const Ban_wordScalarFieldEnum: {
    id: 'id',
    word: 'word',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type Ban_wordScalarFieldEnum = (typeof Ban_wordScalarFieldEnum)[keyof typeof Ban_wordScalarFieldEnum]


  export const Flyway_schema_historyScalarFieldEnum: {
    installed_rank: 'installed_rank',
    version: 'version',
    description: 'description',
    type: 'type',
    script: 'script',
    checksum: 'checksum',
    installed_by: 'installed_by',
    installed_on: 'installed_on',
    execution_time: 'execution_time',
    success: 'success'
  };

  export type Flyway_schema_historyScalarFieldEnum = (typeof Flyway_schema_historyScalarFieldEnum)[keyof typeof Flyway_schema_historyScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    follow_id: 'follow_id',
    user_id: 'user_id',
    target_user_id: 'target_user_id',
    created_at: 'created_at',
    modified_at: 'modified_at',
    deleted: 'deleted'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const HashtagScalarFieldEnum: {
    hashtag_id: 'hashtag_id',
    hashtag: 'hashtag',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type HashtagScalarFieldEnum = (typeof HashtagScalarFieldEnum)[keyof typeof HashtagScalarFieldEnum]


  export const HobbyScalarFieldEnum: {
    hobby_id: 'hobby_id',
    user_id: 'user_id',
    hobby_category_id: 'hobby_category_id',
    hobby_name: 'hobby_name',
    hobby_group_id: 'hobby_group_id',
    created_at: 'created_at',
    created_by: 'created_by',
    modified_at: 'modified_at',
    modified_by: 'modified_by',
    deleted: 'deleted'
  };

  export type HobbyScalarFieldEnum = (typeof HobbyScalarFieldEnum)[keyof typeof HobbyScalarFieldEnum]


  export const Hobby_categoryScalarFieldEnum: {
    hobby_category_id: 'hobby_category_id',
    hobby_category_name: 'hobby_category_name',
    hobby_category_thumbnail: 'hobby_category_thumbnail',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type Hobby_categoryScalarFieldEnum = (typeof Hobby_categoryScalarFieldEnum)[keyof typeof Hobby_categoryScalarFieldEnum]


  export const Hobby_commentScalarFieldEnum: {
    comment_id: 'comment_id',
    post_id: 'post_id',
    comment: 'comment',
    created_at: 'created_at',
    created_by: 'created_by',
    modified_at: 'modified_at',
    modified_by: 'modified_by',
    deleted: 'deleted',
    deleted_at: 'deleted_at'
  };

  export type Hobby_commentScalarFieldEnum = (typeof Hobby_commentScalarFieldEnum)[keyof typeof Hobby_commentScalarFieldEnum]


  export const Hobby_groupScalarFieldEnum: {
    hobby_group_id: 'hobby_group_id',
    user_id: 'user_id',
    hobby_group_title: 'hobby_group_title',
    deleted: 'deleted',
    created_at: 'created_at',
    created_by: 'created_by',
    modified_at: 'modified_at',
    modified_by: 'modified_by',
    deleted_at: 'deleted_at'
  };

  export type Hobby_groupScalarFieldEnum = (typeof Hobby_groupScalarFieldEnum)[keyof typeof Hobby_groupScalarFieldEnum]


  export const Hobby_likeScalarFieldEnum: {
    hobby_like_id: 'hobby_like_id',
    user_id: 'user_id',
    hobby_post_id: 'hobby_post_id',
    created_at: 'created_at',
    created_by: 'created_by',
    modified_at: 'modified_at',
    modified_by: 'modified_by',
    deleted: 'deleted'
  };

  export type Hobby_likeScalarFieldEnum = (typeof Hobby_likeScalarFieldEnum)[keyof typeof Hobby_likeScalarFieldEnum]


  export const Hobby_photoScalarFieldEnum: {
    hobby_photo_id: 'hobby_photo_id',
    hobby_post_id: 'hobby_post_id',
    hobby_photo_path: 'hobby_photo_path',
    deleted: 'deleted',
    created_at: 'created_at',
    created_by: 'created_by',
    modified_at: 'modified_at',
    modified_by: 'modified_by'
  };

  export type Hobby_photoScalarFieldEnum = (typeof Hobby_photoScalarFieldEnum)[keyof typeof Hobby_photoScalarFieldEnum]


  export const Hobby_postScalarFieldEnum: {
    hobby_post_id: 'hobby_post_id',
    user_id: 'user_id',
    hobby_id: 'hobby_id',
    hobby_post_content: 'hobby_post_content',
    hobby_post_thumbnail: 'hobby_post_thumbnail',
    deleted: 'deleted',
    created_at: 'created_at',
    created_by: 'created_by',
    modified_at: 'modified_at',
    modified_by: 'modified_by',
    deleted_at: 'deleted_at'
  };

  export type Hobby_postScalarFieldEnum = (typeof Hobby_postScalarFieldEnum)[keyof typeof Hobby_postScalarFieldEnum]


  export const Hobby_sub_commentScalarFieldEnum: {
    sub_comment_id: 'sub_comment_id',
    comment_id: 'comment_id',
    post_id: 'post_id',
    sub_comment: 'sub_comment',
    created_at: 'created_at',
    created_by: 'created_by',
    modified_at: 'modified_at',
    modified_by: 'modified_by',
    deleted: 'deleted',
    deleted_at: 'deleted_at'
  };

  export type Hobby_sub_commentScalarFieldEnum = (typeof Hobby_sub_commentScalarFieldEnum)[keyof typeof Hobby_sub_commentScalarFieldEnum]


  export const Hobby_top_tenScalarFieldEnum: {
    hobby_top_ten_id: 'hobby_top_ten_id',
    hobby_post_id: 'hobby_post_id',
    view_count: 'view_count',
    category: 'category',
    created_at: 'created_at'
  };

  export type Hobby_top_tenScalarFieldEnum = (typeof Hobby_top_tenScalarFieldEnum)[keyof typeof Hobby_top_tenScalarFieldEnum]


  export const Hobby_view_historyScalarFieldEnum: {
    hobby_view_history_id: 'hobby_view_history_id',
    hobby_post_id: 'hobby_post_id',
    user_id: 'user_id',
    category: 'category',
    created_at: 'created_at',
    modified_at: 'modified_at',
    created_by: 'created_by',
    modified_by: 'modified_by',
    deleted: 'deleted'
  };

  export type Hobby_view_historyScalarFieldEnum = (typeof Hobby_view_historyScalarFieldEnum)[keyof typeof Hobby_view_historyScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    item_id: 'item_id',
    item_name: 'item_name',
    bag_id: 'bag_id'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    studentId: 'studentId',
    studentName: 'studentName',
    studentEmail: 'studentEmail'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const Policy_agreeScalarFieldEnum: {
    policy_agree_id: 'policy_agree_id',
    policy_type: 'policy_type',
    policy_history_id: 'policy_history_id',
    user_id: 'user_id',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type Policy_agreeScalarFieldEnum = (typeof Policy_agreeScalarFieldEnum)[keyof typeof Policy_agreeScalarFieldEnum]


  export const Policy_historyScalarFieldEnum: {
    policy_history_id: 'policy_history_id',
    policy_type: 'policy_type',
    revision_date: 'revision_date',
    pdf_file_path: 'pdf_file_path',
    required: 'required',
    is_latest_revision: 'is_latest_revision',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type Policy_historyScalarFieldEnum = (typeof Policy_historyScalarFieldEnum)[keyof typeof Policy_historyScalarFieldEnum]


  export const Post_hashtagScalarFieldEnum: {
    post_hashtags_id: 'post_hashtags_id',
    post_id: 'post_id',
    hashtag_id: 'hashtag_id',
    created_at: 'created_at',
    modified_at: 'modified_at',
    deleted: 'deleted',
    deleted_at: 'deleted_at'
  };

  export type Post_hashtagScalarFieldEnum = (typeof Post_hashtagScalarFieldEnum)[keyof typeof Post_hashtagScalarFieldEnum]


  export const Recommended_feedScalarFieldEnum: {
    recommended_feed_id: 'recommended_feed_id',
    hobby_post_id: 'hobby_post_id',
    recommended_type: 'recommended_type',
    created_at: 'created_at',
    created_by: 'created_by',
    modified_at: 'modified_at',
    modified_by: 'modified_by',
    deleted: 'deleted'
  };

  export type Recommended_feedScalarFieldEnum = (typeof Recommended_feedScalarFieldEnum)[keyof typeof Recommended_feedScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    report_id: 'report_id',
    user_id: 'user_id',
    hobby_post_id: 'hobby_post_id',
    comment_id: 'comment_id',
    sub_comment_id: 'sub_comment_id',
    report_content: 'report_content',
    report_status: 'report_status',
    created_at: 'created_at',
    created_by: 'created_by',
    modified_at: 'modified_at',
    modified_by: 'modified_by',
    deleted: 'deleted'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    setting_id: 'setting_id',
    user_id: 'user_id',
    notification: 'notification',
    marketing: 'marketing',
    created_at: 'created_at',
    created_by: 'created_by',
    modified_at: 'modified_at',
    modified_by: 'modified_by',
    deleted: 'deleted'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const Today_hobbyScalarFieldEnum: {
    today_hobby_id: 'today_hobby_id',
    hobby_category_id: 'hobby_category_id',
    today_theme_code: 'today_theme_code',
    today_theme_name: 'today_theme_name',
    today_hobby_details_name: 'today_hobby_details_name',
    today_hobby_details_description: 'today_hobby_details_description',
    today_hobby_details_attributes: 'today_hobby_details_attributes',
    today_hobby_thumbnail: 'today_hobby_thumbnail',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type Today_hobbyScalarFieldEnum = (typeof Today_hobbyScalarFieldEnum)[keyof typeof Today_hobbyScalarFieldEnum]


  export const UserScalarFieldEnum: {
    user_id: 'user_id',
    user_email: 'user_email',
    user_profile: 'user_profile',
    user_password: 'user_password',
    user_type: 'user_type',
    user_nickname: 'user_nickname',
    provider_type: 'provider_type',
    provider_key: 'provider_key',
    created_at: 'created_at',
    modified_at: 'modified_at',
    user_last_login_date: 'user_last_login_date',
    deleted: 'deleted',
    dormancy: 'dormancy',
    refresh_token: 'refresh_token',
    profile_description: 'profile_description'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const User_metricsScalarFieldEnum: {
    id: 'id',
    new_users: 'new_users',
    total_users: 'total_users',
    created_at: 'created_at',
    modified_at: 'modified_at'
  };

  export type User_metricsScalarFieldEnum = (typeof User_metricsScalarFieldEnum)[keyof typeof User_metricsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const QRTZ_BLOB_TRIGGERSOrderByRelevanceFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    TRIGGER_NAME: 'TRIGGER_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP'
  };

  export type QRTZ_BLOB_TRIGGERSOrderByRelevanceFieldEnum = (typeof QRTZ_BLOB_TRIGGERSOrderByRelevanceFieldEnum)[keyof typeof QRTZ_BLOB_TRIGGERSOrderByRelevanceFieldEnum]


  export const QRTZ_CALENDARSOrderByRelevanceFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    CALENDAR_NAME: 'CALENDAR_NAME'
  };

  export type QRTZ_CALENDARSOrderByRelevanceFieldEnum = (typeof QRTZ_CALENDARSOrderByRelevanceFieldEnum)[keyof typeof QRTZ_CALENDARSOrderByRelevanceFieldEnum]


  export const QRTZ_CRON_TRIGGERSOrderByRelevanceFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    TRIGGER_NAME: 'TRIGGER_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP',
    CRON_EXPRESSION: 'CRON_EXPRESSION',
    TIME_ZONE_ID: 'TIME_ZONE_ID'
  };

  export type QRTZ_CRON_TRIGGERSOrderByRelevanceFieldEnum = (typeof QRTZ_CRON_TRIGGERSOrderByRelevanceFieldEnum)[keyof typeof QRTZ_CRON_TRIGGERSOrderByRelevanceFieldEnum]


  export const QRTZ_FIRED_TRIGGERSOrderByRelevanceFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    ENTRY_ID: 'ENTRY_ID',
    TRIGGER_NAME: 'TRIGGER_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP',
    INSTANCE_NAME: 'INSTANCE_NAME',
    STATE: 'STATE',
    JOB_NAME: 'JOB_NAME',
    JOB_GROUP: 'JOB_GROUP',
    IS_NONCONCURRENT: 'IS_NONCONCURRENT',
    REQUESTS_RECOVERY: 'REQUESTS_RECOVERY'
  };

  export type QRTZ_FIRED_TRIGGERSOrderByRelevanceFieldEnum = (typeof QRTZ_FIRED_TRIGGERSOrderByRelevanceFieldEnum)[keyof typeof QRTZ_FIRED_TRIGGERSOrderByRelevanceFieldEnum]


  export const QRTZ_JOB_DETAILSOrderByRelevanceFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    JOB_NAME: 'JOB_NAME',
    JOB_GROUP: 'JOB_GROUP',
    DESCRIPTION: 'DESCRIPTION',
    JOB_CLASS_NAME: 'JOB_CLASS_NAME',
    IS_DURABLE: 'IS_DURABLE',
    IS_NONCONCURRENT: 'IS_NONCONCURRENT',
    IS_UPDATE_DATA: 'IS_UPDATE_DATA',
    REQUESTS_RECOVERY: 'REQUESTS_RECOVERY'
  };

  export type QRTZ_JOB_DETAILSOrderByRelevanceFieldEnum = (typeof QRTZ_JOB_DETAILSOrderByRelevanceFieldEnum)[keyof typeof QRTZ_JOB_DETAILSOrderByRelevanceFieldEnum]


  export const QRTZ_LOCKSOrderByRelevanceFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    LOCK_NAME: 'LOCK_NAME'
  };

  export type QRTZ_LOCKSOrderByRelevanceFieldEnum = (typeof QRTZ_LOCKSOrderByRelevanceFieldEnum)[keyof typeof QRTZ_LOCKSOrderByRelevanceFieldEnum]


  export const QRTZ_PAUSED_TRIGGER_GRPSOrderByRelevanceFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP'
  };

  export type QRTZ_PAUSED_TRIGGER_GRPSOrderByRelevanceFieldEnum = (typeof QRTZ_PAUSED_TRIGGER_GRPSOrderByRelevanceFieldEnum)[keyof typeof QRTZ_PAUSED_TRIGGER_GRPSOrderByRelevanceFieldEnum]


  export const QRTZ_SCHEDULER_STATEOrderByRelevanceFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    INSTANCE_NAME: 'INSTANCE_NAME'
  };

  export type QRTZ_SCHEDULER_STATEOrderByRelevanceFieldEnum = (typeof QRTZ_SCHEDULER_STATEOrderByRelevanceFieldEnum)[keyof typeof QRTZ_SCHEDULER_STATEOrderByRelevanceFieldEnum]


  export const QRTZ_SIMPLE_TRIGGERSOrderByRelevanceFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    TRIGGER_NAME: 'TRIGGER_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP'
  };

  export type QRTZ_SIMPLE_TRIGGERSOrderByRelevanceFieldEnum = (typeof QRTZ_SIMPLE_TRIGGERSOrderByRelevanceFieldEnum)[keyof typeof QRTZ_SIMPLE_TRIGGERSOrderByRelevanceFieldEnum]


  export const QRTZ_SIMPROP_TRIGGERSOrderByRelevanceFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    TRIGGER_NAME: 'TRIGGER_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP',
    STR_PROP_1: 'STR_PROP_1',
    STR_PROP_2: 'STR_PROP_2',
    STR_PROP_3: 'STR_PROP_3',
    BOOL_PROP_1: 'BOOL_PROP_1',
    BOOL_PROP_2: 'BOOL_PROP_2'
  };

  export type QRTZ_SIMPROP_TRIGGERSOrderByRelevanceFieldEnum = (typeof QRTZ_SIMPROP_TRIGGERSOrderByRelevanceFieldEnum)[keyof typeof QRTZ_SIMPROP_TRIGGERSOrderByRelevanceFieldEnum]


  export const QRTZ_TRIGGERSOrderByRelevanceFieldEnum: {
    SCHED_NAME: 'SCHED_NAME',
    TRIGGER_NAME: 'TRIGGER_NAME',
    TRIGGER_GROUP: 'TRIGGER_GROUP',
    JOB_NAME: 'JOB_NAME',
    JOB_GROUP: 'JOB_GROUP',
    DESCRIPTION: 'DESCRIPTION',
    TRIGGER_STATE: 'TRIGGER_STATE',
    TRIGGER_TYPE: 'TRIGGER_TYPE',
    CALENDAR_NAME: 'CALENDAR_NAME'
  };

  export type QRTZ_TRIGGERSOrderByRelevanceFieldEnum = (typeof QRTZ_TRIGGERSOrderByRelevanceFieldEnum)[keyof typeof QRTZ_TRIGGERSOrderByRelevanceFieldEnum]


  export const ban_wordOrderByRelevanceFieldEnum: {
    word: 'word'
  };

  export type ban_wordOrderByRelevanceFieldEnum = (typeof ban_wordOrderByRelevanceFieldEnum)[keyof typeof ban_wordOrderByRelevanceFieldEnum]


  export const flyway_schema_historyOrderByRelevanceFieldEnum: {
    version: 'version',
    description: 'description',
    type: 'type',
    script: 'script',
    installed_by: 'installed_by'
  };

  export type flyway_schema_historyOrderByRelevanceFieldEnum = (typeof flyway_schema_historyOrderByRelevanceFieldEnum)[keyof typeof flyway_schema_historyOrderByRelevanceFieldEnum]


  export const hashtagOrderByRelevanceFieldEnum: {
    hashtag: 'hashtag'
  };

  export type hashtagOrderByRelevanceFieldEnum = (typeof hashtagOrderByRelevanceFieldEnum)[keyof typeof hashtagOrderByRelevanceFieldEnum]


  export const hobbyOrderByRelevanceFieldEnum: {
    hobby_name: 'hobby_name'
  };

  export type hobbyOrderByRelevanceFieldEnum = (typeof hobbyOrderByRelevanceFieldEnum)[keyof typeof hobbyOrderByRelevanceFieldEnum]


  export const hobby_categoryOrderByRelevanceFieldEnum: {
    hobby_category_thumbnail: 'hobby_category_thumbnail'
  };

  export type hobby_categoryOrderByRelevanceFieldEnum = (typeof hobby_categoryOrderByRelevanceFieldEnum)[keyof typeof hobby_categoryOrderByRelevanceFieldEnum]


  export const hobby_commentOrderByRelevanceFieldEnum: {
    comment: 'comment'
  };

  export type hobby_commentOrderByRelevanceFieldEnum = (typeof hobby_commentOrderByRelevanceFieldEnum)[keyof typeof hobby_commentOrderByRelevanceFieldEnum]


  export const hobby_groupOrderByRelevanceFieldEnum: {
    hobby_group_title: 'hobby_group_title'
  };

  export type hobby_groupOrderByRelevanceFieldEnum = (typeof hobby_groupOrderByRelevanceFieldEnum)[keyof typeof hobby_groupOrderByRelevanceFieldEnum]


  export const hobby_photoOrderByRelevanceFieldEnum: {
    hobby_photo_path: 'hobby_photo_path'
  };

  export type hobby_photoOrderByRelevanceFieldEnum = (typeof hobby_photoOrderByRelevanceFieldEnum)[keyof typeof hobby_photoOrderByRelevanceFieldEnum]


  export const hobby_postOrderByRelevanceFieldEnum: {
    hobby_post_content: 'hobby_post_content',
    hobby_post_thumbnail: 'hobby_post_thumbnail'
  };

  export type hobby_postOrderByRelevanceFieldEnum = (typeof hobby_postOrderByRelevanceFieldEnum)[keyof typeof hobby_postOrderByRelevanceFieldEnum]


  export const hobby_sub_commentOrderByRelevanceFieldEnum: {
    sub_comment: 'sub_comment'
  };

  export type hobby_sub_commentOrderByRelevanceFieldEnum = (typeof hobby_sub_commentOrderByRelevanceFieldEnum)[keyof typeof hobby_sub_commentOrderByRelevanceFieldEnum]


  export const itemOrderByRelevanceFieldEnum: {
    item_name: 'item_name'
  };

  export type itemOrderByRelevanceFieldEnum = (typeof itemOrderByRelevanceFieldEnum)[keyof typeof itemOrderByRelevanceFieldEnum]


  export const memberOrderByRelevanceFieldEnum: {
    studentName: 'studentName',
    studentEmail: 'studentEmail'
  };

  export type memberOrderByRelevanceFieldEnum = (typeof memberOrderByRelevanceFieldEnum)[keyof typeof memberOrderByRelevanceFieldEnum]


  export const policy_historyOrderByRelevanceFieldEnum: {
    pdf_file_path: 'pdf_file_path'
  };

  export type policy_historyOrderByRelevanceFieldEnum = (typeof policy_historyOrderByRelevanceFieldEnum)[keyof typeof policy_historyOrderByRelevanceFieldEnum]


  export const reportOrderByRelevanceFieldEnum: {
    report_content: 'report_content'
  };

  export type reportOrderByRelevanceFieldEnum = (typeof reportOrderByRelevanceFieldEnum)[keyof typeof reportOrderByRelevanceFieldEnum]


  export const today_hobbyOrderByRelevanceFieldEnum: {
    today_theme_name: 'today_theme_name',
    today_hobby_details_name: 'today_hobby_details_name',
    today_hobby_details_description: 'today_hobby_details_description',
    today_hobby_details_attributes: 'today_hobby_details_attributes',
    today_hobby_thumbnail: 'today_hobby_thumbnail'
  };

  export type today_hobbyOrderByRelevanceFieldEnum = (typeof today_hobbyOrderByRelevanceFieldEnum)[keyof typeof today_hobbyOrderByRelevanceFieldEnum]


  export const userOrderByRelevanceFieldEnum: {
    user_email: 'user_email',
    user_profile: 'user_profile',
    user_password: 'user_password',
    user_nickname: 'user_nickname',
    provider_key: 'provider_key',
    refresh_token: 'refresh_token',
    profile_description: 'profile_description'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'hobby_category_hobby_category_name'
   */
  export type Enumhobby_category_hobby_category_nameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'hobby_category_hobby_category_name'>
    


  /**
   * Reference to a field of type 'hobby_top_ten_category'
   */
  export type Enumhobby_top_ten_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'hobby_top_ten_category'>
    


  /**
   * Reference to a field of type 'hobby_view_history_category'
   */
  export type Enumhobby_view_history_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'hobby_view_history_category'>
    


  /**
   * Reference to a field of type 'policy_agree_policy_type'
   */
  export type Enumpolicy_agree_policy_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'policy_agree_policy_type'>
    


  /**
   * Reference to a field of type 'policy_history_policy_type'
   */
  export type Enumpolicy_history_policy_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'policy_history_policy_type'>
    


  /**
   * Reference to a field of type 'recommended_feed_recommended_type'
   */
  export type Enumrecommended_feed_recommended_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'recommended_feed_recommended_type'>
    


  /**
   * Reference to a field of type 'report_report_status'
   */
  export type Enumreport_report_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'report_report_status'>
    


  /**
   * Reference to a field of type 'user_user_type'
   */
  export type Enumuser_user_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_user_type'>
    


  /**
   * Reference to a field of type 'user_provider_type'
   */
  export type Enumuser_provider_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_provider_type'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type QRTZ_BLOB_TRIGGERSWhereInput = {
    AND?: QRTZ_BLOB_TRIGGERSWhereInput | QRTZ_BLOB_TRIGGERSWhereInput[]
    OR?: QRTZ_BLOB_TRIGGERSWhereInput[]
    NOT?: QRTZ_BLOB_TRIGGERSWhereInput | QRTZ_BLOB_TRIGGERSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_BLOB_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_BLOB_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_BLOB_TRIGGERS"> | string
    BLOB_DATA?: BytesNullableFilter<"QRTZ_BLOB_TRIGGERS"> | Uint8Array | null
    QRTZ_TRIGGERS?: XOR<QRTZ_TRIGGERSScalarRelationFilter, QRTZ_TRIGGERSWhereInput>
  }

  export type QRTZ_BLOB_TRIGGERSOrderByWithRelationInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    BLOB_DATA?: SortOrderInput | SortOrder
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSOrderByWithRelationInput
    _relevance?: QRTZ_BLOB_TRIGGERSOrderByRelevanceInput
  }

  export type QRTZ_BLOB_TRIGGERSWhereUniqueInput = Prisma.AtLeast<{
    SCHED_NAME_TRIGGER_NAME_TRIGGER_GROUP?: QRTZ_BLOB_TRIGGERSSCHED_NAMETRIGGER_NAMETRIGGER_GROUPCompoundUniqueInput
    AND?: QRTZ_BLOB_TRIGGERSWhereInput | QRTZ_BLOB_TRIGGERSWhereInput[]
    OR?: QRTZ_BLOB_TRIGGERSWhereInput[]
    NOT?: QRTZ_BLOB_TRIGGERSWhereInput | QRTZ_BLOB_TRIGGERSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_BLOB_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_BLOB_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_BLOB_TRIGGERS"> | string
    BLOB_DATA?: BytesNullableFilter<"QRTZ_BLOB_TRIGGERS"> | Uint8Array | null
    QRTZ_TRIGGERS?: XOR<QRTZ_TRIGGERSScalarRelationFilter, QRTZ_TRIGGERSWhereInput>
  }, "SCHED_NAME_TRIGGER_NAME_TRIGGER_GROUP">

  export type QRTZ_BLOB_TRIGGERSOrderByWithAggregationInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    BLOB_DATA?: SortOrderInput | SortOrder
    _count?: QRTZ_BLOB_TRIGGERSCountOrderByAggregateInput
    _max?: QRTZ_BLOB_TRIGGERSMaxOrderByAggregateInput
    _min?: QRTZ_BLOB_TRIGGERSMinOrderByAggregateInput
  }

  export type QRTZ_BLOB_TRIGGERSScalarWhereWithAggregatesInput = {
    AND?: QRTZ_BLOB_TRIGGERSScalarWhereWithAggregatesInput | QRTZ_BLOB_TRIGGERSScalarWhereWithAggregatesInput[]
    OR?: QRTZ_BLOB_TRIGGERSScalarWhereWithAggregatesInput[]
    NOT?: QRTZ_BLOB_TRIGGERSScalarWhereWithAggregatesInput | QRTZ_BLOB_TRIGGERSScalarWhereWithAggregatesInput[]
    SCHED_NAME?: StringWithAggregatesFilter<"QRTZ_BLOB_TRIGGERS"> | string
    TRIGGER_NAME?: StringWithAggregatesFilter<"QRTZ_BLOB_TRIGGERS"> | string
    TRIGGER_GROUP?: StringWithAggregatesFilter<"QRTZ_BLOB_TRIGGERS"> | string
    BLOB_DATA?: BytesNullableWithAggregatesFilter<"QRTZ_BLOB_TRIGGERS"> | Uint8Array | null
  }

  export type QRTZ_CALENDARSWhereInput = {
    AND?: QRTZ_CALENDARSWhereInput | QRTZ_CALENDARSWhereInput[]
    OR?: QRTZ_CALENDARSWhereInput[]
    NOT?: QRTZ_CALENDARSWhereInput | QRTZ_CALENDARSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_CALENDARS"> | string
    CALENDAR_NAME?: StringFilter<"QRTZ_CALENDARS"> | string
    CALENDAR?: BytesFilter<"QRTZ_CALENDARS"> | Uint8Array
  }

  export type QRTZ_CALENDARSOrderByWithRelationInput = {
    SCHED_NAME?: SortOrder
    CALENDAR_NAME?: SortOrder
    CALENDAR?: SortOrder
    _relevance?: QRTZ_CALENDARSOrderByRelevanceInput
  }

  export type QRTZ_CALENDARSWhereUniqueInput = Prisma.AtLeast<{
    SCHED_NAME_CALENDAR_NAME?: QRTZ_CALENDARSSCHED_NAMECALENDAR_NAMECompoundUniqueInput
    AND?: QRTZ_CALENDARSWhereInput | QRTZ_CALENDARSWhereInput[]
    OR?: QRTZ_CALENDARSWhereInput[]
    NOT?: QRTZ_CALENDARSWhereInput | QRTZ_CALENDARSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_CALENDARS"> | string
    CALENDAR_NAME?: StringFilter<"QRTZ_CALENDARS"> | string
    CALENDAR?: BytesFilter<"QRTZ_CALENDARS"> | Uint8Array
  }, "SCHED_NAME_CALENDAR_NAME">

  export type QRTZ_CALENDARSOrderByWithAggregationInput = {
    SCHED_NAME?: SortOrder
    CALENDAR_NAME?: SortOrder
    CALENDAR?: SortOrder
    _count?: QRTZ_CALENDARSCountOrderByAggregateInput
    _max?: QRTZ_CALENDARSMaxOrderByAggregateInput
    _min?: QRTZ_CALENDARSMinOrderByAggregateInput
  }

  export type QRTZ_CALENDARSScalarWhereWithAggregatesInput = {
    AND?: QRTZ_CALENDARSScalarWhereWithAggregatesInput | QRTZ_CALENDARSScalarWhereWithAggregatesInput[]
    OR?: QRTZ_CALENDARSScalarWhereWithAggregatesInput[]
    NOT?: QRTZ_CALENDARSScalarWhereWithAggregatesInput | QRTZ_CALENDARSScalarWhereWithAggregatesInput[]
    SCHED_NAME?: StringWithAggregatesFilter<"QRTZ_CALENDARS"> | string
    CALENDAR_NAME?: StringWithAggregatesFilter<"QRTZ_CALENDARS"> | string
    CALENDAR?: BytesWithAggregatesFilter<"QRTZ_CALENDARS"> | Uint8Array
  }

  export type QRTZ_CRON_TRIGGERSWhereInput = {
    AND?: QRTZ_CRON_TRIGGERSWhereInput | QRTZ_CRON_TRIGGERSWhereInput[]
    OR?: QRTZ_CRON_TRIGGERSWhereInput[]
    NOT?: QRTZ_CRON_TRIGGERSWhereInput | QRTZ_CRON_TRIGGERSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_CRON_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_CRON_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_CRON_TRIGGERS"> | string
    CRON_EXPRESSION?: StringFilter<"QRTZ_CRON_TRIGGERS"> | string
    TIME_ZONE_ID?: StringNullableFilter<"QRTZ_CRON_TRIGGERS"> | string | null
    QRTZ_TRIGGERS?: XOR<QRTZ_TRIGGERSScalarRelationFilter, QRTZ_TRIGGERSWhereInput>
  }

  export type QRTZ_CRON_TRIGGERSOrderByWithRelationInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    CRON_EXPRESSION?: SortOrder
    TIME_ZONE_ID?: SortOrderInput | SortOrder
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSOrderByWithRelationInput
    _relevance?: QRTZ_CRON_TRIGGERSOrderByRelevanceInput
  }

  export type QRTZ_CRON_TRIGGERSWhereUniqueInput = Prisma.AtLeast<{
    SCHED_NAME_TRIGGER_NAME_TRIGGER_GROUP?: QRTZ_CRON_TRIGGERSSCHED_NAMETRIGGER_NAMETRIGGER_GROUPCompoundUniqueInput
    AND?: QRTZ_CRON_TRIGGERSWhereInput | QRTZ_CRON_TRIGGERSWhereInput[]
    OR?: QRTZ_CRON_TRIGGERSWhereInput[]
    NOT?: QRTZ_CRON_TRIGGERSWhereInput | QRTZ_CRON_TRIGGERSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_CRON_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_CRON_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_CRON_TRIGGERS"> | string
    CRON_EXPRESSION?: StringFilter<"QRTZ_CRON_TRIGGERS"> | string
    TIME_ZONE_ID?: StringNullableFilter<"QRTZ_CRON_TRIGGERS"> | string | null
    QRTZ_TRIGGERS?: XOR<QRTZ_TRIGGERSScalarRelationFilter, QRTZ_TRIGGERSWhereInput>
  }, "SCHED_NAME_TRIGGER_NAME_TRIGGER_GROUP">

  export type QRTZ_CRON_TRIGGERSOrderByWithAggregationInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    CRON_EXPRESSION?: SortOrder
    TIME_ZONE_ID?: SortOrderInput | SortOrder
    _count?: QRTZ_CRON_TRIGGERSCountOrderByAggregateInput
    _max?: QRTZ_CRON_TRIGGERSMaxOrderByAggregateInput
    _min?: QRTZ_CRON_TRIGGERSMinOrderByAggregateInput
  }

  export type QRTZ_CRON_TRIGGERSScalarWhereWithAggregatesInput = {
    AND?: QRTZ_CRON_TRIGGERSScalarWhereWithAggregatesInput | QRTZ_CRON_TRIGGERSScalarWhereWithAggregatesInput[]
    OR?: QRTZ_CRON_TRIGGERSScalarWhereWithAggregatesInput[]
    NOT?: QRTZ_CRON_TRIGGERSScalarWhereWithAggregatesInput | QRTZ_CRON_TRIGGERSScalarWhereWithAggregatesInput[]
    SCHED_NAME?: StringWithAggregatesFilter<"QRTZ_CRON_TRIGGERS"> | string
    TRIGGER_NAME?: StringWithAggregatesFilter<"QRTZ_CRON_TRIGGERS"> | string
    TRIGGER_GROUP?: StringWithAggregatesFilter<"QRTZ_CRON_TRIGGERS"> | string
    CRON_EXPRESSION?: StringWithAggregatesFilter<"QRTZ_CRON_TRIGGERS"> | string
    TIME_ZONE_ID?: StringNullableWithAggregatesFilter<"QRTZ_CRON_TRIGGERS"> | string | null
  }

  export type QRTZ_FIRED_TRIGGERSWhereInput = {
    AND?: QRTZ_FIRED_TRIGGERSWhereInput | QRTZ_FIRED_TRIGGERSWhereInput[]
    OR?: QRTZ_FIRED_TRIGGERSWhereInput[]
    NOT?: QRTZ_FIRED_TRIGGERSWhereInput | QRTZ_FIRED_TRIGGERSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_FIRED_TRIGGERS"> | string
    ENTRY_ID?: StringFilter<"QRTZ_FIRED_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_FIRED_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_FIRED_TRIGGERS"> | string
    INSTANCE_NAME?: StringFilter<"QRTZ_FIRED_TRIGGERS"> | string
    FIRED_TIME?: BigIntFilter<"QRTZ_FIRED_TRIGGERS"> | bigint | number
    SCHED_TIME?: BigIntFilter<"QRTZ_FIRED_TRIGGERS"> | bigint | number
    PRIORITY?: IntFilter<"QRTZ_FIRED_TRIGGERS"> | number
    STATE?: StringFilter<"QRTZ_FIRED_TRIGGERS"> | string
    JOB_NAME?: StringNullableFilter<"QRTZ_FIRED_TRIGGERS"> | string | null
    JOB_GROUP?: StringNullableFilter<"QRTZ_FIRED_TRIGGERS"> | string | null
    IS_NONCONCURRENT?: StringNullableFilter<"QRTZ_FIRED_TRIGGERS"> | string | null
    REQUESTS_RECOVERY?: StringNullableFilter<"QRTZ_FIRED_TRIGGERS"> | string | null
  }

  export type QRTZ_FIRED_TRIGGERSOrderByWithRelationInput = {
    SCHED_NAME?: SortOrder
    ENTRY_ID?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    INSTANCE_NAME?: SortOrder
    FIRED_TIME?: SortOrder
    SCHED_TIME?: SortOrder
    PRIORITY?: SortOrder
    STATE?: SortOrder
    JOB_NAME?: SortOrderInput | SortOrder
    JOB_GROUP?: SortOrderInput | SortOrder
    IS_NONCONCURRENT?: SortOrderInput | SortOrder
    REQUESTS_RECOVERY?: SortOrderInput | SortOrder
    _relevance?: QRTZ_FIRED_TRIGGERSOrderByRelevanceInput
  }

  export type QRTZ_FIRED_TRIGGERSWhereUniqueInput = Prisma.AtLeast<{
    SCHED_NAME_ENTRY_ID?: QRTZ_FIRED_TRIGGERSSCHED_NAMEENTRY_IDCompoundUniqueInput
    AND?: QRTZ_FIRED_TRIGGERSWhereInput | QRTZ_FIRED_TRIGGERSWhereInput[]
    OR?: QRTZ_FIRED_TRIGGERSWhereInput[]
    NOT?: QRTZ_FIRED_TRIGGERSWhereInput | QRTZ_FIRED_TRIGGERSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_FIRED_TRIGGERS"> | string
    ENTRY_ID?: StringFilter<"QRTZ_FIRED_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_FIRED_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_FIRED_TRIGGERS"> | string
    INSTANCE_NAME?: StringFilter<"QRTZ_FIRED_TRIGGERS"> | string
    FIRED_TIME?: BigIntFilter<"QRTZ_FIRED_TRIGGERS"> | bigint | number
    SCHED_TIME?: BigIntFilter<"QRTZ_FIRED_TRIGGERS"> | bigint | number
    PRIORITY?: IntFilter<"QRTZ_FIRED_TRIGGERS"> | number
    STATE?: StringFilter<"QRTZ_FIRED_TRIGGERS"> | string
    JOB_NAME?: StringNullableFilter<"QRTZ_FIRED_TRIGGERS"> | string | null
    JOB_GROUP?: StringNullableFilter<"QRTZ_FIRED_TRIGGERS"> | string | null
    IS_NONCONCURRENT?: StringNullableFilter<"QRTZ_FIRED_TRIGGERS"> | string | null
    REQUESTS_RECOVERY?: StringNullableFilter<"QRTZ_FIRED_TRIGGERS"> | string | null
  }, "SCHED_NAME_ENTRY_ID">

  export type QRTZ_FIRED_TRIGGERSOrderByWithAggregationInput = {
    SCHED_NAME?: SortOrder
    ENTRY_ID?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    INSTANCE_NAME?: SortOrder
    FIRED_TIME?: SortOrder
    SCHED_TIME?: SortOrder
    PRIORITY?: SortOrder
    STATE?: SortOrder
    JOB_NAME?: SortOrderInput | SortOrder
    JOB_GROUP?: SortOrderInput | SortOrder
    IS_NONCONCURRENT?: SortOrderInput | SortOrder
    REQUESTS_RECOVERY?: SortOrderInput | SortOrder
    _count?: QRTZ_FIRED_TRIGGERSCountOrderByAggregateInput
    _avg?: QRTZ_FIRED_TRIGGERSAvgOrderByAggregateInput
    _max?: QRTZ_FIRED_TRIGGERSMaxOrderByAggregateInput
    _min?: QRTZ_FIRED_TRIGGERSMinOrderByAggregateInput
    _sum?: QRTZ_FIRED_TRIGGERSSumOrderByAggregateInput
  }

  export type QRTZ_FIRED_TRIGGERSScalarWhereWithAggregatesInput = {
    AND?: QRTZ_FIRED_TRIGGERSScalarWhereWithAggregatesInput | QRTZ_FIRED_TRIGGERSScalarWhereWithAggregatesInput[]
    OR?: QRTZ_FIRED_TRIGGERSScalarWhereWithAggregatesInput[]
    NOT?: QRTZ_FIRED_TRIGGERSScalarWhereWithAggregatesInput | QRTZ_FIRED_TRIGGERSScalarWhereWithAggregatesInput[]
    SCHED_NAME?: StringWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | string
    ENTRY_ID?: StringWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | string
    TRIGGER_NAME?: StringWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | string
    TRIGGER_GROUP?: StringWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | string
    INSTANCE_NAME?: StringWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | string
    FIRED_TIME?: BigIntWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | bigint | number
    SCHED_TIME?: BigIntWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | bigint | number
    PRIORITY?: IntWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | number
    STATE?: StringWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | string
    JOB_NAME?: StringNullableWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | string | null
    JOB_GROUP?: StringNullableWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | string | null
    IS_NONCONCURRENT?: StringNullableWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | string | null
    REQUESTS_RECOVERY?: StringNullableWithAggregatesFilter<"QRTZ_FIRED_TRIGGERS"> | string | null
  }

  export type QRTZ_JOB_DETAILSWhereInput = {
    AND?: QRTZ_JOB_DETAILSWhereInput | QRTZ_JOB_DETAILSWhereInput[]
    OR?: QRTZ_JOB_DETAILSWhereInput[]
    NOT?: QRTZ_JOB_DETAILSWhereInput | QRTZ_JOB_DETAILSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    JOB_NAME?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    JOB_GROUP?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    DESCRIPTION?: StringNullableFilter<"QRTZ_JOB_DETAILS"> | string | null
    JOB_CLASS_NAME?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    IS_DURABLE?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    IS_NONCONCURRENT?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    IS_UPDATE_DATA?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    REQUESTS_RECOVERY?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    JOB_DATA?: BytesNullableFilter<"QRTZ_JOB_DETAILS"> | Uint8Array | null
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSListRelationFilter
  }

  export type QRTZ_JOB_DETAILSOrderByWithRelationInput = {
    SCHED_NAME?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    DESCRIPTION?: SortOrderInput | SortOrder
    JOB_CLASS_NAME?: SortOrder
    IS_DURABLE?: SortOrder
    IS_NONCONCURRENT?: SortOrder
    IS_UPDATE_DATA?: SortOrder
    REQUESTS_RECOVERY?: SortOrder
    JOB_DATA?: SortOrderInput | SortOrder
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSOrderByRelationAggregateInput
    _relevance?: QRTZ_JOB_DETAILSOrderByRelevanceInput
  }

  export type QRTZ_JOB_DETAILSWhereUniqueInput = Prisma.AtLeast<{
    SCHED_NAME_JOB_NAME_JOB_GROUP?: QRTZ_JOB_DETAILSSCHED_NAMEJOB_NAMEJOB_GROUPCompoundUniqueInput
    AND?: QRTZ_JOB_DETAILSWhereInput | QRTZ_JOB_DETAILSWhereInput[]
    OR?: QRTZ_JOB_DETAILSWhereInput[]
    NOT?: QRTZ_JOB_DETAILSWhereInput | QRTZ_JOB_DETAILSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    JOB_NAME?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    JOB_GROUP?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    DESCRIPTION?: StringNullableFilter<"QRTZ_JOB_DETAILS"> | string | null
    JOB_CLASS_NAME?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    IS_DURABLE?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    IS_NONCONCURRENT?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    IS_UPDATE_DATA?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    REQUESTS_RECOVERY?: StringFilter<"QRTZ_JOB_DETAILS"> | string
    JOB_DATA?: BytesNullableFilter<"QRTZ_JOB_DETAILS"> | Uint8Array | null
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSListRelationFilter
  }, "SCHED_NAME_JOB_NAME_JOB_GROUP">

  export type QRTZ_JOB_DETAILSOrderByWithAggregationInput = {
    SCHED_NAME?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    DESCRIPTION?: SortOrderInput | SortOrder
    JOB_CLASS_NAME?: SortOrder
    IS_DURABLE?: SortOrder
    IS_NONCONCURRENT?: SortOrder
    IS_UPDATE_DATA?: SortOrder
    REQUESTS_RECOVERY?: SortOrder
    JOB_DATA?: SortOrderInput | SortOrder
    _count?: QRTZ_JOB_DETAILSCountOrderByAggregateInput
    _max?: QRTZ_JOB_DETAILSMaxOrderByAggregateInput
    _min?: QRTZ_JOB_DETAILSMinOrderByAggregateInput
  }

  export type QRTZ_JOB_DETAILSScalarWhereWithAggregatesInput = {
    AND?: QRTZ_JOB_DETAILSScalarWhereWithAggregatesInput | QRTZ_JOB_DETAILSScalarWhereWithAggregatesInput[]
    OR?: QRTZ_JOB_DETAILSScalarWhereWithAggregatesInput[]
    NOT?: QRTZ_JOB_DETAILSScalarWhereWithAggregatesInput | QRTZ_JOB_DETAILSScalarWhereWithAggregatesInput[]
    SCHED_NAME?: StringWithAggregatesFilter<"QRTZ_JOB_DETAILS"> | string
    JOB_NAME?: StringWithAggregatesFilter<"QRTZ_JOB_DETAILS"> | string
    JOB_GROUP?: StringWithAggregatesFilter<"QRTZ_JOB_DETAILS"> | string
    DESCRIPTION?: StringNullableWithAggregatesFilter<"QRTZ_JOB_DETAILS"> | string | null
    JOB_CLASS_NAME?: StringWithAggregatesFilter<"QRTZ_JOB_DETAILS"> | string
    IS_DURABLE?: StringWithAggregatesFilter<"QRTZ_JOB_DETAILS"> | string
    IS_NONCONCURRENT?: StringWithAggregatesFilter<"QRTZ_JOB_DETAILS"> | string
    IS_UPDATE_DATA?: StringWithAggregatesFilter<"QRTZ_JOB_DETAILS"> | string
    REQUESTS_RECOVERY?: StringWithAggregatesFilter<"QRTZ_JOB_DETAILS"> | string
    JOB_DATA?: BytesNullableWithAggregatesFilter<"QRTZ_JOB_DETAILS"> | Uint8Array | null
  }

  export type QRTZ_LOCKSWhereInput = {
    AND?: QRTZ_LOCKSWhereInput | QRTZ_LOCKSWhereInput[]
    OR?: QRTZ_LOCKSWhereInput[]
    NOT?: QRTZ_LOCKSWhereInput | QRTZ_LOCKSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_LOCKS"> | string
    LOCK_NAME?: StringFilter<"QRTZ_LOCKS"> | string
  }

  export type QRTZ_LOCKSOrderByWithRelationInput = {
    SCHED_NAME?: SortOrder
    LOCK_NAME?: SortOrder
    _relevance?: QRTZ_LOCKSOrderByRelevanceInput
  }

  export type QRTZ_LOCKSWhereUniqueInput = Prisma.AtLeast<{
    SCHED_NAME_LOCK_NAME?: QRTZ_LOCKSSCHED_NAMELOCK_NAMECompoundUniqueInput
    AND?: QRTZ_LOCKSWhereInput | QRTZ_LOCKSWhereInput[]
    OR?: QRTZ_LOCKSWhereInput[]
    NOT?: QRTZ_LOCKSWhereInput | QRTZ_LOCKSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_LOCKS"> | string
    LOCK_NAME?: StringFilter<"QRTZ_LOCKS"> | string
  }, "SCHED_NAME_LOCK_NAME">

  export type QRTZ_LOCKSOrderByWithAggregationInput = {
    SCHED_NAME?: SortOrder
    LOCK_NAME?: SortOrder
    _count?: QRTZ_LOCKSCountOrderByAggregateInput
    _max?: QRTZ_LOCKSMaxOrderByAggregateInput
    _min?: QRTZ_LOCKSMinOrderByAggregateInput
  }

  export type QRTZ_LOCKSScalarWhereWithAggregatesInput = {
    AND?: QRTZ_LOCKSScalarWhereWithAggregatesInput | QRTZ_LOCKSScalarWhereWithAggregatesInput[]
    OR?: QRTZ_LOCKSScalarWhereWithAggregatesInput[]
    NOT?: QRTZ_LOCKSScalarWhereWithAggregatesInput | QRTZ_LOCKSScalarWhereWithAggregatesInput[]
    SCHED_NAME?: StringWithAggregatesFilter<"QRTZ_LOCKS"> | string
    LOCK_NAME?: StringWithAggregatesFilter<"QRTZ_LOCKS"> | string
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSWhereInput = {
    AND?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput | QRTZ_PAUSED_TRIGGER_GRPSWhereInput[]
    OR?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput[]
    NOT?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput | QRTZ_PAUSED_TRIGGER_GRPSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_PAUSED_TRIGGER_GRPS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_PAUSED_TRIGGER_GRPS"> | string
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSOrderByWithRelationInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    _relevance?: QRTZ_PAUSED_TRIGGER_GRPSOrderByRelevanceInput
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSWhereUniqueInput = Prisma.AtLeast<{
    SCHED_NAME_TRIGGER_GROUP?: QRTZ_PAUSED_TRIGGER_GRPSSCHED_NAMETRIGGER_GROUPCompoundUniqueInput
    AND?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput | QRTZ_PAUSED_TRIGGER_GRPSWhereInput[]
    OR?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput[]
    NOT?: QRTZ_PAUSED_TRIGGER_GRPSWhereInput | QRTZ_PAUSED_TRIGGER_GRPSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_PAUSED_TRIGGER_GRPS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_PAUSED_TRIGGER_GRPS"> | string
  }, "SCHED_NAME_TRIGGER_GROUP">

  export type QRTZ_PAUSED_TRIGGER_GRPSOrderByWithAggregationInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    _count?: QRTZ_PAUSED_TRIGGER_GRPSCountOrderByAggregateInput
    _max?: QRTZ_PAUSED_TRIGGER_GRPSMaxOrderByAggregateInput
    _min?: QRTZ_PAUSED_TRIGGER_GRPSMinOrderByAggregateInput
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSScalarWhereWithAggregatesInput = {
    AND?: QRTZ_PAUSED_TRIGGER_GRPSScalarWhereWithAggregatesInput | QRTZ_PAUSED_TRIGGER_GRPSScalarWhereWithAggregatesInput[]
    OR?: QRTZ_PAUSED_TRIGGER_GRPSScalarWhereWithAggregatesInput[]
    NOT?: QRTZ_PAUSED_TRIGGER_GRPSScalarWhereWithAggregatesInput | QRTZ_PAUSED_TRIGGER_GRPSScalarWhereWithAggregatesInput[]
    SCHED_NAME?: StringWithAggregatesFilter<"QRTZ_PAUSED_TRIGGER_GRPS"> | string
    TRIGGER_GROUP?: StringWithAggregatesFilter<"QRTZ_PAUSED_TRIGGER_GRPS"> | string
  }

  export type QRTZ_SCHEDULER_STATEWhereInput = {
    AND?: QRTZ_SCHEDULER_STATEWhereInput | QRTZ_SCHEDULER_STATEWhereInput[]
    OR?: QRTZ_SCHEDULER_STATEWhereInput[]
    NOT?: QRTZ_SCHEDULER_STATEWhereInput | QRTZ_SCHEDULER_STATEWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_SCHEDULER_STATE"> | string
    INSTANCE_NAME?: StringFilter<"QRTZ_SCHEDULER_STATE"> | string
    LAST_CHECKIN_TIME?: BigIntFilter<"QRTZ_SCHEDULER_STATE"> | bigint | number
    CHECKIN_INTERVAL?: BigIntFilter<"QRTZ_SCHEDULER_STATE"> | bigint | number
  }

  export type QRTZ_SCHEDULER_STATEOrderByWithRelationInput = {
    SCHED_NAME?: SortOrder
    INSTANCE_NAME?: SortOrder
    LAST_CHECKIN_TIME?: SortOrder
    CHECKIN_INTERVAL?: SortOrder
    _relevance?: QRTZ_SCHEDULER_STATEOrderByRelevanceInput
  }

  export type QRTZ_SCHEDULER_STATEWhereUniqueInput = Prisma.AtLeast<{
    SCHED_NAME_INSTANCE_NAME?: QRTZ_SCHEDULER_STATESCHED_NAMEINSTANCE_NAMECompoundUniqueInput
    AND?: QRTZ_SCHEDULER_STATEWhereInput | QRTZ_SCHEDULER_STATEWhereInput[]
    OR?: QRTZ_SCHEDULER_STATEWhereInput[]
    NOT?: QRTZ_SCHEDULER_STATEWhereInput | QRTZ_SCHEDULER_STATEWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_SCHEDULER_STATE"> | string
    INSTANCE_NAME?: StringFilter<"QRTZ_SCHEDULER_STATE"> | string
    LAST_CHECKIN_TIME?: BigIntFilter<"QRTZ_SCHEDULER_STATE"> | bigint | number
    CHECKIN_INTERVAL?: BigIntFilter<"QRTZ_SCHEDULER_STATE"> | bigint | number
  }, "SCHED_NAME_INSTANCE_NAME">

  export type QRTZ_SCHEDULER_STATEOrderByWithAggregationInput = {
    SCHED_NAME?: SortOrder
    INSTANCE_NAME?: SortOrder
    LAST_CHECKIN_TIME?: SortOrder
    CHECKIN_INTERVAL?: SortOrder
    _count?: QRTZ_SCHEDULER_STATECountOrderByAggregateInput
    _avg?: QRTZ_SCHEDULER_STATEAvgOrderByAggregateInput
    _max?: QRTZ_SCHEDULER_STATEMaxOrderByAggregateInput
    _min?: QRTZ_SCHEDULER_STATEMinOrderByAggregateInput
    _sum?: QRTZ_SCHEDULER_STATESumOrderByAggregateInput
  }

  export type QRTZ_SCHEDULER_STATEScalarWhereWithAggregatesInput = {
    AND?: QRTZ_SCHEDULER_STATEScalarWhereWithAggregatesInput | QRTZ_SCHEDULER_STATEScalarWhereWithAggregatesInput[]
    OR?: QRTZ_SCHEDULER_STATEScalarWhereWithAggregatesInput[]
    NOT?: QRTZ_SCHEDULER_STATEScalarWhereWithAggregatesInput | QRTZ_SCHEDULER_STATEScalarWhereWithAggregatesInput[]
    SCHED_NAME?: StringWithAggregatesFilter<"QRTZ_SCHEDULER_STATE"> | string
    INSTANCE_NAME?: StringWithAggregatesFilter<"QRTZ_SCHEDULER_STATE"> | string
    LAST_CHECKIN_TIME?: BigIntWithAggregatesFilter<"QRTZ_SCHEDULER_STATE"> | bigint | number
    CHECKIN_INTERVAL?: BigIntWithAggregatesFilter<"QRTZ_SCHEDULER_STATE"> | bigint | number
  }

  export type QRTZ_SIMPLE_TRIGGERSWhereInput = {
    AND?: QRTZ_SIMPLE_TRIGGERSWhereInput | QRTZ_SIMPLE_TRIGGERSWhereInput[]
    OR?: QRTZ_SIMPLE_TRIGGERSWhereInput[]
    NOT?: QRTZ_SIMPLE_TRIGGERSWhereInput | QRTZ_SIMPLE_TRIGGERSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_SIMPLE_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_SIMPLE_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_SIMPLE_TRIGGERS"> | string
    REPEAT_COUNT?: BigIntFilter<"QRTZ_SIMPLE_TRIGGERS"> | bigint | number
    REPEAT_INTERVAL?: BigIntFilter<"QRTZ_SIMPLE_TRIGGERS"> | bigint | number
    TIMES_TRIGGERED?: BigIntFilter<"QRTZ_SIMPLE_TRIGGERS"> | bigint | number
    QRTZ_TRIGGERS?: XOR<QRTZ_TRIGGERSScalarRelationFilter, QRTZ_TRIGGERSWhereInput>
  }

  export type QRTZ_SIMPLE_TRIGGERSOrderByWithRelationInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    REPEAT_COUNT?: SortOrder
    REPEAT_INTERVAL?: SortOrder
    TIMES_TRIGGERED?: SortOrder
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSOrderByWithRelationInput
    _relevance?: QRTZ_SIMPLE_TRIGGERSOrderByRelevanceInput
  }

  export type QRTZ_SIMPLE_TRIGGERSWhereUniqueInput = Prisma.AtLeast<{
    SCHED_NAME_TRIGGER_NAME_TRIGGER_GROUP?: QRTZ_SIMPLE_TRIGGERSSCHED_NAMETRIGGER_NAMETRIGGER_GROUPCompoundUniqueInput
    AND?: QRTZ_SIMPLE_TRIGGERSWhereInput | QRTZ_SIMPLE_TRIGGERSWhereInput[]
    OR?: QRTZ_SIMPLE_TRIGGERSWhereInput[]
    NOT?: QRTZ_SIMPLE_TRIGGERSWhereInput | QRTZ_SIMPLE_TRIGGERSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_SIMPLE_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_SIMPLE_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_SIMPLE_TRIGGERS"> | string
    REPEAT_COUNT?: BigIntFilter<"QRTZ_SIMPLE_TRIGGERS"> | bigint | number
    REPEAT_INTERVAL?: BigIntFilter<"QRTZ_SIMPLE_TRIGGERS"> | bigint | number
    TIMES_TRIGGERED?: BigIntFilter<"QRTZ_SIMPLE_TRIGGERS"> | bigint | number
    QRTZ_TRIGGERS?: XOR<QRTZ_TRIGGERSScalarRelationFilter, QRTZ_TRIGGERSWhereInput>
  }, "SCHED_NAME_TRIGGER_NAME_TRIGGER_GROUP">

  export type QRTZ_SIMPLE_TRIGGERSOrderByWithAggregationInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    REPEAT_COUNT?: SortOrder
    REPEAT_INTERVAL?: SortOrder
    TIMES_TRIGGERED?: SortOrder
    _count?: QRTZ_SIMPLE_TRIGGERSCountOrderByAggregateInput
    _avg?: QRTZ_SIMPLE_TRIGGERSAvgOrderByAggregateInput
    _max?: QRTZ_SIMPLE_TRIGGERSMaxOrderByAggregateInput
    _min?: QRTZ_SIMPLE_TRIGGERSMinOrderByAggregateInput
    _sum?: QRTZ_SIMPLE_TRIGGERSSumOrderByAggregateInput
  }

  export type QRTZ_SIMPLE_TRIGGERSScalarWhereWithAggregatesInput = {
    AND?: QRTZ_SIMPLE_TRIGGERSScalarWhereWithAggregatesInput | QRTZ_SIMPLE_TRIGGERSScalarWhereWithAggregatesInput[]
    OR?: QRTZ_SIMPLE_TRIGGERSScalarWhereWithAggregatesInput[]
    NOT?: QRTZ_SIMPLE_TRIGGERSScalarWhereWithAggregatesInput | QRTZ_SIMPLE_TRIGGERSScalarWhereWithAggregatesInput[]
    SCHED_NAME?: StringWithAggregatesFilter<"QRTZ_SIMPLE_TRIGGERS"> | string
    TRIGGER_NAME?: StringWithAggregatesFilter<"QRTZ_SIMPLE_TRIGGERS"> | string
    TRIGGER_GROUP?: StringWithAggregatesFilter<"QRTZ_SIMPLE_TRIGGERS"> | string
    REPEAT_COUNT?: BigIntWithAggregatesFilter<"QRTZ_SIMPLE_TRIGGERS"> | bigint | number
    REPEAT_INTERVAL?: BigIntWithAggregatesFilter<"QRTZ_SIMPLE_TRIGGERS"> | bigint | number
    TIMES_TRIGGERED?: BigIntWithAggregatesFilter<"QRTZ_SIMPLE_TRIGGERS"> | bigint | number
  }

  export type QRTZ_SIMPROP_TRIGGERSWhereInput = {
    AND?: QRTZ_SIMPROP_TRIGGERSWhereInput | QRTZ_SIMPROP_TRIGGERSWhereInput[]
    OR?: QRTZ_SIMPROP_TRIGGERSWhereInput[]
    NOT?: QRTZ_SIMPROP_TRIGGERSWhereInput | QRTZ_SIMPROP_TRIGGERSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_SIMPROP_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_SIMPROP_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_SIMPROP_TRIGGERS"> | string
    STR_PROP_1?: StringNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    STR_PROP_2?: StringNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    STR_PROP_3?: StringNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    INT_PROP_1?: IntNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | number | null
    INT_PROP_2?: IntNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | number | null
    LONG_PROP_1?: BigIntNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | bigint | number | null
    LONG_PROP_2?: BigIntNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | bigint | number | null
    DEC_PROP_1?: DecimalNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: DecimalNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: StringNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    BOOL_PROP_2?: StringNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    QRTZ_TRIGGERS?: XOR<QRTZ_TRIGGERSScalarRelationFilter, QRTZ_TRIGGERSWhereInput>
  }

  export type QRTZ_SIMPROP_TRIGGERSOrderByWithRelationInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    STR_PROP_1?: SortOrderInput | SortOrder
    STR_PROP_2?: SortOrderInput | SortOrder
    STR_PROP_3?: SortOrderInput | SortOrder
    INT_PROP_1?: SortOrderInput | SortOrder
    INT_PROP_2?: SortOrderInput | SortOrder
    LONG_PROP_1?: SortOrderInput | SortOrder
    LONG_PROP_2?: SortOrderInput | SortOrder
    DEC_PROP_1?: SortOrderInput | SortOrder
    DEC_PROP_2?: SortOrderInput | SortOrder
    BOOL_PROP_1?: SortOrderInput | SortOrder
    BOOL_PROP_2?: SortOrderInput | SortOrder
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSOrderByWithRelationInput
    _relevance?: QRTZ_SIMPROP_TRIGGERSOrderByRelevanceInput
  }

  export type QRTZ_SIMPROP_TRIGGERSWhereUniqueInput = Prisma.AtLeast<{
    SCHED_NAME_TRIGGER_NAME_TRIGGER_GROUP?: QRTZ_SIMPROP_TRIGGERSSCHED_NAMETRIGGER_NAMETRIGGER_GROUPCompoundUniqueInput
    AND?: QRTZ_SIMPROP_TRIGGERSWhereInput | QRTZ_SIMPROP_TRIGGERSWhereInput[]
    OR?: QRTZ_SIMPROP_TRIGGERSWhereInput[]
    NOT?: QRTZ_SIMPROP_TRIGGERSWhereInput | QRTZ_SIMPROP_TRIGGERSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_SIMPROP_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_SIMPROP_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_SIMPROP_TRIGGERS"> | string
    STR_PROP_1?: StringNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    STR_PROP_2?: StringNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    STR_PROP_3?: StringNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    INT_PROP_1?: IntNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | number | null
    INT_PROP_2?: IntNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | number | null
    LONG_PROP_1?: BigIntNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | bigint | number | null
    LONG_PROP_2?: BigIntNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | bigint | number | null
    DEC_PROP_1?: DecimalNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: DecimalNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: StringNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    BOOL_PROP_2?: StringNullableFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    QRTZ_TRIGGERS?: XOR<QRTZ_TRIGGERSScalarRelationFilter, QRTZ_TRIGGERSWhereInput>
  }, "SCHED_NAME_TRIGGER_NAME_TRIGGER_GROUP">

  export type QRTZ_SIMPROP_TRIGGERSOrderByWithAggregationInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    STR_PROP_1?: SortOrderInput | SortOrder
    STR_PROP_2?: SortOrderInput | SortOrder
    STR_PROP_3?: SortOrderInput | SortOrder
    INT_PROP_1?: SortOrderInput | SortOrder
    INT_PROP_2?: SortOrderInput | SortOrder
    LONG_PROP_1?: SortOrderInput | SortOrder
    LONG_PROP_2?: SortOrderInput | SortOrder
    DEC_PROP_1?: SortOrderInput | SortOrder
    DEC_PROP_2?: SortOrderInput | SortOrder
    BOOL_PROP_1?: SortOrderInput | SortOrder
    BOOL_PROP_2?: SortOrderInput | SortOrder
    _count?: QRTZ_SIMPROP_TRIGGERSCountOrderByAggregateInput
    _avg?: QRTZ_SIMPROP_TRIGGERSAvgOrderByAggregateInput
    _max?: QRTZ_SIMPROP_TRIGGERSMaxOrderByAggregateInput
    _min?: QRTZ_SIMPROP_TRIGGERSMinOrderByAggregateInput
    _sum?: QRTZ_SIMPROP_TRIGGERSSumOrderByAggregateInput
  }

  export type QRTZ_SIMPROP_TRIGGERSScalarWhereWithAggregatesInput = {
    AND?: QRTZ_SIMPROP_TRIGGERSScalarWhereWithAggregatesInput | QRTZ_SIMPROP_TRIGGERSScalarWhereWithAggregatesInput[]
    OR?: QRTZ_SIMPROP_TRIGGERSScalarWhereWithAggregatesInput[]
    NOT?: QRTZ_SIMPROP_TRIGGERSScalarWhereWithAggregatesInput | QRTZ_SIMPROP_TRIGGERSScalarWhereWithAggregatesInput[]
    SCHED_NAME?: StringWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | string
    TRIGGER_NAME?: StringWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | string
    TRIGGER_GROUP?: StringWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | string
    STR_PROP_1?: StringNullableWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    STR_PROP_2?: StringNullableWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    STR_PROP_3?: StringNullableWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    INT_PROP_1?: IntNullableWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | number | null
    INT_PROP_2?: IntNullableWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | number | null
    LONG_PROP_1?: BigIntNullableWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | bigint | number | null
    LONG_PROP_2?: BigIntNullableWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | bigint | number | null
    DEC_PROP_1?: DecimalNullableWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: DecimalNullableWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: StringNullableWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
    BOOL_PROP_2?: StringNullableWithAggregatesFilter<"QRTZ_SIMPROP_TRIGGERS"> | string | null
  }

  export type QRTZ_TRIGGERSWhereInput = {
    AND?: QRTZ_TRIGGERSWhereInput | QRTZ_TRIGGERSWhereInput[]
    OR?: QRTZ_TRIGGERSWhereInput[]
    NOT?: QRTZ_TRIGGERSWhereInput | QRTZ_TRIGGERSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_TRIGGERS"> | string
    JOB_NAME?: StringFilter<"QRTZ_TRIGGERS"> | string
    JOB_GROUP?: StringFilter<"QRTZ_TRIGGERS"> | string
    DESCRIPTION?: StringNullableFilter<"QRTZ_TRIGGERS"> | string | null
    NEXT_FIRE_TIME?: BigIntNullableFilter<"QRTZ_TRIGGERS"> | bigint | number | null
    PREV_FIRE_TIME?: BigIntNullableFilter<"QRTZ_TRIGGERS"> | bigint | number | null
    PRIORITY?: IntNullableFilter<"QRTZ_TRIGGERS"> | number | null
    TRIGGER_STATE?: StringFilter<"QRTZ_TRIGGERS"> | string
    TRIGGER_TYPE?: StringFilter<"QRTZ_TRIGGERS"> | string
    START_TIME?: BigIntFilter<"QRTZ_TRIGGERS"> | bigint | number
    END_TIME?: BigIntNullableFilter<"QRTZ_TRIGGERS"> | bigint | number | null
    CALENDAR_NAME?: StringNullableFilter<"QRTZ_TRIGGERS"> | string | null
    MISFIRE_INSTR?: IntNullableFilter<"QRTZ_TRIGGERS"> | number | null
    JOB_DATA?: BytesNullableFilter<"QRTZ_TRIGGERS"> | Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: XOR<QRTZ_BLOB_TRIGGERSNullableScalarRelationFilter, QRTZ_BLOB_TRIGGERSWhereInput> | null
    QRTZ_CRON_TRIGGERS?: XOR<QRTZ_CRON_TRIGGERSNullableScalarRelationFilter, QRTZ_CRON_TRIGGERSWhereInput> | null
    QRTZ_SIMPLE_TRIGGERS?: XOR<QRTZ_SIMPLE_TRIGGERSNullableScalarRelationFilter, QRTZ_SIMPLE_TRIGGERSWhereInput> | null
    QRTZ_SIMPROP_TRIGGERS?: XOR<QRTZ_SIMPROP_TRIGGERSNullableScalarRelationFilter, QRTZ_SIMPROP_TRIGGERSWhereInput> | null
    QRTZ_JOB_DETAILS?: XOR<QRTZ_JOB_DETAILSScalarRelationFilter, QRTZ_JOB_DETAILSWhereInput>
  }

  export type QRTZ_TRIGGERSOrderByWithRelationInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    DESCRIPTION?: SortOrderInput | SortOrder
    NEXT_FIRE_TIME?: SortOrderInput | SortOrder
    PREV_FIRE_TIME?: SortOrderInput | SortOrder
    PRIORITY?: SortOrderInput | SortOrder
    TRIGGER_STATE?: SortOrder
    TRIGGER_TYPE?: SortOrder
    START_TIME?: SortOrder
    END_TIME?: SortOrderInput | SortOrder
    CALENDAR_NAME?: SortOrderInput | SortOrder
    MISFIRE_INSTR?: SortOrderInput | SortOrder
    JOB_DATA?: SortOrderInput | SortOrder
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSOrderByWithRelationInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSOrderByWithRelationInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSOrderByWithRelationInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSOrderByWithRelationInput
    QRTZ_JOB_DETAILS?: QRTZ_JOB_DETAILSOrderByWithRelationInput
    _relevance?: QRTZ_TRIGGERSOrderByRelevanceInput
  }

  export type QRTZ_TRIGGERSWhereUniqueInput = Prisma.AtLeast<{
    SCHED_NAME_TRIGGER_NAME_TRIGGER_GROUP?: QRTZ_TRIGGERSSCHED_NAMETRIGGER_NAMETRIGGER_GROUPCompoundUniqueInput
    AND?: QRTZ_TRIGGERSWhereInput | QRTZ_TRIGGERSWhereInput[]
    OR?: QRTZ_TRIGGERSWhereInput[]
    NOT?: QRTZ_TRIGGERSWhereInput | QRTZ_TRIGGERSWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_TRIGGERS"> | string
    JOB_NAME?: StringFilter<"QRTZ_TRIGGERS"> | string
    JOB_GROUP?: StringFilter<"QRTZ_TRIGGERS"> | string
    DESCRIPTION?: StringNullableFilter<"QRTZ_TRIGGERS"> | string | null
    NEXT_FIRE_TIME?: BigIntNullableFilter<"QRTZ_TRIGGERS"> | bigint | number | null
    PREV_FIRE_TIME?: BigIntNullableFilter<"QRTZ_TRIGGERS"> | bigint | number | null
    PRIORITY?: IntNullableFilter<"QRTZ_TRIGGERS"> | number | null
    TRIGGER_STATE?: StringFilter<"QRTZ_TRIGGERS"> | string
    TRIGGER_TYPE?: StringFilter<"QRTZ_TRIGGERS"> | string
    START_TIME?: BigIntFilter<"QRTZ_TRIGGERS"> | bigint | number
    END_TIME?: BigIntNullableFilter<"QRTZ_TRIGGERS"> | bigint | number | null
    CALENDAR_NAME?: StringNullableFilter<"QRTZ_TRIGGERS"> | string | null
    MISFIRE_INSTR?: IntNullableFilter<"QRTZ_TRIGGERS"> | number | null
    JOB_DATA?: BytesNullableFilter<"QRTZ_TRIGGERS"> | Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: XOR<QRTZ_BLOB_TRIGGERSNullableScalarRelationFilter, QRTZ_BLOB_TRIGGERSWhereInput> | null
    QRTZ_CRON_TRIGGERS?: XOR<QRTZ_CRON_TRIGGERSNullableScalarRelationFilter, QRTZ_CRON_TRIGGERSWhereInput> | null
    QRTZ_SIMPLE_TRIGGERS?: XOR<QRTZ_SIMPLE_TRIGGERSNullableScalarRelationFilter, QRTZ_SIMPLE_TRIGGERSWhereInput> | null
    QRTZ_SIMPROP_TRIGGERS?: XOR<QRTZ_SIMPROP_TRIGGERSNullableScalarRelationFilter, QRTZ_SIMPROP_TRIGGERSWhereInput> | null
    QRTZ_JOB_DETAILS?: XOR<QRTZ_JOB_DETAILSScalarRelationFilter, QRTZ_JOB_DETAILSWhereInput>
  }, "SCHED_NAME_TRIGGER_NAME_TRIGGER_GROUP">

  export type QRTZ_TRIGGERSOrderByWithAggregationInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    DESCRIPTION?: SortOrderInput | SortOrder
    NEXT_FIRE_TIME?: SortOrderInput | SortOrder
    PREV_FIRE_TIME?: SortOrderInput | SortOrder
    PRIORITY?: SortOrderInput | SortOrder
    TRIGGER_STATE?: SortOrder
    TRIGGER_TYPE?: SortOrder
    START_TIME?: SortOrder
    END_TIME?: SortOrderInput | SortOrder
    CALENDAR_NAME?: SortOrderInput | SortOrder
    MISFIRE_INSTR?: SortOrderInput | SortOrder
    JOB_DATA?: SortOrderInput | SortOrder
    _count?: QRTZ_TRIGGERSCountOrderByAggregateInput
    _avg?: QRTZ_TRIGGERSAvgOrderByAggregateInput
    _max?: QRTZ_TRIGGERSMaxOrderByAggregateInput
    _min?: QRTZ_TRIGGERSMinOrderByAggregateInput
    _sum?: QRTZ_TRIGGERSSumOrderByAggregateInput
  }

  export type QRTZ_TRIGGERSScalarWhereWithAggregatesInput = {
    AND?: QRTZ_TRIGGERSScalarWhereWithAggregatesInput | QRTZ_TRIGGERSScalarWhereWithAggregatesInput[]
    OR?: QRTZ_TRIGGERSScalarWhereWithAggregatesInput[]
    NOT?: QRTZ_TRIGGERSScalarWhereWithAggregatesInput | QRTZ_TRIGGERSScalarWhereWithAggregatesInput[]
    SCHED_NAME?: StringWithAggregatesFilter<"QRTZ_TRIGGERS"> | string
    TRIGGER_NAME?: StringWithAggregatesFilter<"QRTZ_TRIGGERS"> | string
    TRIGGER_GROUP?: StringWithAggregatesFilter<"QRTZ_TRIGGERS"> | string
    JOB_NAME?: StringWithAggregatesFilter<"QRTZ_TRIGGERS"> | string
    JOB_GROUP?: StringWithAggregatesFilter<"QRTZ_TRIGGERS"> | string
    DESCRIPTION?: StringNullableWithAggregatesFilter<"QRTZ_TRIGGERS"> | string | null
    NEXT_FIRE_TIME?: BigIntNullableWithAggregatesFilter<"QRTZ_TRIGGERS"> | bigint | number | null
    PREV_FIRE_TIME?: BigIntNullableWithAggregatesFilter<"QRTZ_TRIGGERS"> | bigint | number | null
    PRIORITY?: IntNullableWithAggregatesFilter<"QRTZ_TRIGGERS"> | number | null
    TRIGGER_STATE?: StringWithAggregatesFilter<"QRTZ_TRIGGERS"> | string
    TRIGGER_TYPE?: StringWithAggregatesFilter<"QRTZ_TRIGGERS"> | string
    START_TIME?: BigIntWithAggregatesFilter<"QRTZ_TRIGGERS"> | bigint | number
    END_TIME?: BigIntNullableWithAggregatesFilter<"QRTZ_TRIGGERS"> | bigint | number | null
    CALENDAR_NAME?: StringNullableWithAggregatesFilter<"QRTZ_TRIGGERS"> | string | null
    MISFIRE_INSTR?: IntNullableWithAggregatesFilter<"QRTZ_TRIGGERS"> | number | null
    JOB_DATA?: BytesNullableWithAggregatesFilter<"QRTZ_TRIGGERS"> | Uint8Array | null
  }

  export type bagWhereInput = {
    AND?: bagWhereInput | bagWhereInput[]
    OR?: bagWhereInput[]
    NOT?: bagWhereInput | bagWhereInput[]
    bag_id?: BigIntFilter<"bag"> | bigint | number
  }

  export type bagOrderByWithRelationInput = {
    bag_id?: SortOrder
  }

  export type bagWhereUniqueInput = Prisma.AtLeast<{
    bag_id?: bigint | number
    AND?: bagWhereInput | bagWhereInput[]
    OR?: bagWhereInput[]
    NOT?: bagWhereInput | bagWhereInput[]
  }, "bag_id">

  export type bagOrderByWithAggregationInput = {
    bag_id?: SortOrder
    _count?: bagCountOrderByAggregateInput
    _avg?: bagAvgOrderByAggregateInput
    _max?: bagMaxOrderByAggregateInput
    _min?: bagMinOrderByAggregateInput
    _sum?: bagSumOrderByAggregateInput
  }

  export type bagScalarWhereWithAggregatesInput = {
    AND?: bagScalarWhereWithAggregatesInput | bagScalarWhereWithAggregatesInput[]
    OR?: bagScalarWhereWithAggregatesInput[]
    NOT?: bagScalarWhereWithAggregatesInput | bagScalarWhereWithAggregatesInput[]
    bag_id?: BigIntWithAggregatesFilter<"bag"> | bigint | number
  }

  export type ban_wordWhereInput = {
    AND?: ban_wordWhereInput | ban_wordWhereInput[]
    OR?: ban_wordWhereInput[]
    NOT?: ban_wordWhereInput | ban_wordWhereInput[]
    id?: BigIntFilter<"ban_word"> | bigint | number
    word?: StringFilter<"ban_word"> | string
    created_at?: DateTimeFilter<"ban_word"> | Date | string
    modified_at?: DateTimeFilter<"ban_word"> | Date | string
  }

  export type ban_wordOrderByWithRelationInput = {
    id?: SortOrder
    word?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _relevance?: ban_wordOrderByRelevanceInput
  }

  export type ban_wordWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    word?: string
    AND?: ban_wordWhereInput | ban_wordWhereInput[]
    OR?: ban_wordWhereInput[]
    NOT?: ban_wordWhereInput | ban_wordWhereInput[]
    created_at?: DateTimeFilter<"ban_word"> | Date | string
    modified_at?: DateTimeFilter<"ban_word"> | Date | string
  }, "id" | "word">

  export type ban_wordOrderByWithAggregationInput = {
    id?: SortOrder
    word?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: ban_wordCountOrderByAggregateInput
    _avg?: ban_wordAvgOrderByAggregateInput
    _max?: ban_wordMaxOrderByAggregateInput
    _min?: ban_wordMinOrderByAggregateInput
    _sum?: ban_wordSumOrderByAggregateInput
  }

  export type ban_wordScalarWhereWithAggregatesInput = {
    AND?: ban_wordScalarWhereWithAggregatesInput | ban_wordScalarWhereWithAggregatesInput[]
    OR?: ban_wordScalarWhereWithAggregatesInput[]
    NOT?: ban_wordScalarWhereWithAggregatesInput | ban_wordScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ban_word"> | bigint | number
    word?: StringWithAggregatesFilter<"ban_word"> | string
    created_at?: DateTimeWithAggregatesFilter<"ban_word"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"ban_word"> | Date | string
  }

  export type flyway_schema_historyWhereInput = {
    AND?: flyway_schema_historyWhereInput | flyway_schema_historyWhereInput[]
    OR?: flyway_schema_historyWhereInput[]
    NOT?: flyway_schema_historyWhereInput | flyway_schema_historyWhereInput[]
    installed_rank?: IntFilter<"flyway_schema_history"> | number
    version?: StringNullableFilter<"flyway_schema_history"> | string | null
    description?: StringFilter<"flyway_schema_history"> | string
    type?: StringFilter<"flyway_schema_history"> | string
    script?: StringFilter<"flyway_schema_history"> | string
    checksum?: IntNullableFilter<"flyway_schema_history"> | number | null
    installed_by?: StringFilter<"flyway_schema_history"> | string
    installed_on?: DateTimeFilter<"flyway_schema_history"> | Date | string
    execution_time?: IntFilter<"flyway_schema_history"> | number
    success?: BoolFilter<"flyway_schema_history"> | boolean
  }

  export type flyway_schema_historyOrderByWithRelationInput = {
    installed_rank?: SortOrder
    version?: SortOrderInput | SortOrder
    description?: SortOrder
    type?: SortOrder
    script?: SortOrder
    checksum?: SortOrderInput | SortOrder
    installed_by?: SortOrder
    installed_on?: SortOrder
    execution_time?: SortOrder
    success?: SortOrder
    _relevance?: flyway_schema_historyOrderByRelevanceInput
  }

  export type flyway_schema_historyWhereUniqueInput = Prisma.AtLeast<{
    installed_rank?: number
    AND?: flyway_schema_historyWhereInput | flyway_schema_historyWhereInput[]
    OR?: flyway_schema_historyWhereInput[]
    NOT?: flyway_schema_historyWhereInput | flyway_schema_historyWhereInput[]
    version?: StringNullableFilter<"flyway_schema_history"> | string | null
    description?: StringFilter<"flyway_schema_history"> | string
    type?: StringFilter<"flyway_schema_history"> | string
    script?: StringFilter<"flyway_schema_history"> | string
    checksum?: IntNullableFilter<"flyway_schema_history"> | number | null
    installed_by?: StringFilter<"flyway_schema_history"> | string
    installed_on?: DateTimeFilter<"flyway_schema_history"> | Date | string
    execution_time?: IntFilter<"flyway_schema_history"> | number
    success?: BoolFilter<"flyway_schema_history"> | boolean
  }, "installed_rank">

  export type flyway_schema_historyOrderByWithAggregationInput = {
    installed_rank?: SortOrder
    version?: SortOrderInput | SortOrder
    description?: SortOrder
    type?: SortOrder
    script?: SortOrder
    checksum?: SortOrderInput | SortOrder
    installed_by?: SortOrder
    installed_on?: SortOrder
    execution_time?: SortOrder
    success?: SortOrder
    _count?: flyway_schema_historyCountOrderByAggregateInput
    _avg?: flyway_schema_historyAvgOrderByAggregateInput
    _max?: flyway_schema_historyMaxOrderByAggregateInput
    _min?: flyway_schema_historyMinOrderByAggregateInput
    _sum?: flyway_schema_historySumOrderByAggregateInput
  }

  export type flyway_schema_historyScalarWhereWithAggregatesInput = {
    AND?: flyway_schema_historyScalarWhereWithAggregatesInput | flyway_schema_historyScalarWhereWithAggregatesInput[]
    OR?: flyway_schema_historyScalarWhereWithAggregatesInput[]
    NOT?: flyway_schema_historyScalarWhereWithAggregatesInput | flyway_schema_historyScalarWhereWithAggregatesInput[]
    installed_rank?: IntWithAggregatesFilter<"flyway_schema_history"> | number
    version?: StringNullableWithAggregatesFilter<"flyway_schema_history"> | string | null
    description?: StringWithAggregatesFilter<"flyway_schema_history"> | string
    type?: StringWithAggregatesFilter<"flyway_schema_history"> | string
    script?: StringWithAggregatesFilter<"flyway_schema_history"> | string
    checksum?: IntNullableWithAggregatesFilter<"flyway_schema_history"> | number | null
    installed_by?: StringWithAggregatesFilter<"flyway_schema_history"> | string
    installed_on?: DateTimeWithAggregatesFilter<"flyway_schema_history"> | Date | string
    execution_time?: IntWithAggregatesFilter<"flyway_schema_history"> | number
    success?: BoolWithAggregatesFilter<"flyway_schema_history"> | boolean
  }

  export type followWhereInput = {
    AND?: followWhereInput | followWhereInput[]
    OR?: followWhereInput[]
    NOT?: followWhereInput | followWhereInput[]
    follow_id?: BigIntFilter<"follow"> | bigint | number
    user_id?: BigIntFilter<"follow"> | bigint | number
    target_user_id?: BigIntFilter<"follow"> | bigint | number
    created_at?: DateTimeFilter<"follow"> | Date | string
    modified_at?: DateTimeFilter<"follow"> | Date | string
    deleted?: BoolFilter<"follow"> | boolean
  }

  export type followOrderByWithRelationInput = {
    follow_id?: SortOrder
    user_id?: SortOrder
    target_user_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    deleted?: SortOrder
  }

  export type followWhereUniqueInput = Prisma.AtLeast<{
    follow_id?: bigint | number
    user_id_target_user_id?: followUser_idTarget_user_idCompoundUniqueInput
    AND?: followWhereInput | followWhereInput[]
    OR?: followWhereInput[]
    NOT?: followWhereInput | followWhereInput[]
    user_id?: BigIntFilter<"follow"> | bigint | number
    target_user_id?: BigIntFilter<"follow"> | bigint | number
    created_at?: DateTimeFilter<"follow"> | Date | string
    modified_at?: DateTimeFilter<"follow"> | Date | string
    deleted?: BoolFilter<"follow"> | boolean
  }, "follow_id" | "user_id_target_user_id">

  export type followOrderByWithAggregationInput = {
    follow_id?: SortOrder
    user_id?: SortOrder
    target_user_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    deleted?: SortOrder
    _count?: followCountOrderByAggregateInput
    _avg?: followAvgOrderByAggregateInput
    _max?: followMaxOrderByAggregateInput
    _min?: followMinOrderByAggregateInput
    _sum?: followSumOrderByAggregateInput
  }

  export type followScalarWhereWithAggregatesInput = {
    AND?: followScalarWhereWithAggregatesInput | followScalarWhereWithAggregatesInput[]
    OR?: followScalarWhereWithAggregatesInput[]
    NOT?: followScalarWhereWithAggregatesInput | followScalarWhereWithAggregatesInput[]
    follow_id?: BigIntWithAggregatesFilter<"follow"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"follow"> | bigint | number
    target_user_id?: BigIntWithAggregatesFilter<"follow"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"follow"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"follow"> | Date | string
    deleted?: BoolWithAggregatesFilter<"follow"> | boolean
  }

  export type hashtagWhereInput = {
    AND?: hashtagWhereInput | hashtagWhereInput[]
    OR?: hashtagWhereInput[]
    NOT?: hashtagWhereInput | hashtagWhereInput[]
    hashtag_id?: BigIntFilter<"hashtag"> | bigint | number
    hashtag?: StringFilter<"hashtag"> | string
    created_at?: DateTimeFilter<"hashtag"> | Date | string
    modified_at?: DateTimeFilter<"hashtag"> | Date | string
  }

  export type hashtagOrderByWithRelationInput = {
    hashtag_id?: SortOrder
    hashtag?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _relevance?: hashtagOrderByRelevanceInput
  }

  export type hashtagWhereUniqueInput = Prisma.AtLeast<{
    hashtag_id?: bigint | number
    hashtag?: string
    hashtag_id_hashtag?: hashtagHashtag_idHashtagCompoundUniqueInput
    AND?: hashtagWhereInput | hashtagWhereInput[]
    OR?: hashtagWhereInput[]
    NOT?: hashtagWhereInput | hashtagWhereInput[]
    created_at?: DateTimeFilter<"hashtag"> | Date | string
    modified_at?: DateTimeFilter<"hashtag"> | Date | string
  }, "hashtag_id" | "hashtag" | "hashtag_id_hashtag">

  export type hashtagOrderByWithAggregationInput = {
    hashtag_id?: SortOrder
    hashtag?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: hashtagCountOrderByAggregateInput
    _avg?: hashtagAvgOrderByAggregateInput
    _max?: hashtagMaxOrderByAggregateInput
    _min?: hashtagMinOrderByAggregateInput
    _sum?: hashtagSumOrderByAggregateInput
  }

  export type hashtagScalarWhereWithAggregatesInput = {
    AND?: hashtagScalarWhereWithAggregatesInput | hashtagScalarWhereWithAggregatesInput[]
    OR?: hashtagScalarWhereWithAggregatesInput[]
    NOT?: hashtagScalarWhereWithAggregatesInput | hashtagScalarWhereWithAggregatesInput[]
    hashtag_id?: BigIntWithAggregatesFilter<"hashtag"> | bigint | number
    hashtag?: StringWithAggregatesFilter<"hashtag"> | string
    created_at?: DateTimeWithAggregatesFilter<"hashtag"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"hashtag"> | Date | string
  }

  export type hobbyWhereInput = {
    AND?: hobbyWhereInput | hobbyWhereInput[]
    OR?: hobbyWhereInput[]
    NOT?: hobbyWhereInput | hobbyWhereInput[]
    hobby_id?: BigIntFilter<"hobby"> | bigint | number
    user_id?: BigIntFilter<"hobby"> | bigint | number
    hobby_category_id?: BigIntFilter<"hobby"> | bigint | number
    hobby_name?: StringFilter<"hobby"> | string
    hobby_group_id?: BigIntFilter<"hobby"> | bigint | number
    created_at?: DateTimeFilter<"hobby"> | Date | string
    created_by?: BigIntFilter<"hobby"> | bigint | number
    modified_at?: DateTimeFilter<"hobby"> | Date | string
    modified_by?: BigIntFilter<"hobby"> | bigint | number
    deleted?: BoolFilter<"hobby"> | boolean
  }

  export type hobbyOrderByWithRelationInput = {
    hobby_id?: SortOrder
    user_id?: SortOrder
    hobby_category_id?: SortOrder
    hobby_name?: SortOrder
    hobby_group_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    _relevance?: hobbyOrderByRelevanceInput
  }

  export type hobbyWhereUniqueInput = Prisma.AtLeast<{
    hobby_id?: bigint | number
    AND?: hobbyWhereInput | hobbyWhereInput[]
    OR?: hobbyWhereInput[]
    NOT?: hobbyWhereInput | hobbyWhereInput[]
    user_id?: BigIntFilter<"hobby"> | bigint | number
    hobby_category_id?: BigIntFilter<"hobby"> | bigint | number
    hobby_name?: StringFilter<"hobby"> | string
    hobby_group_id?: BigIntFilter<"hobby"> | bigint | number
    created_at?: DateTimeFilter<"hobby"> | Date | string
    created_by?: BigIntFilter<"hobby"> | bigint | number
    modified_at?: DateTimeFilter<"hobby"> | Date | string
    modified_by?: BigIntFilter<"hobby"> | bigint | number
    deleted?: BoolFilter<"hobby"> | boolean
  }, "hobby_id">

  export type hobbyOrderByWithAggregationInput = {
    hobby_id?: SortOrder
    user_id?: SortOrder
    hobby_category_id?: SortOrder
    hobby_name?: SortOrder
    hobby_group_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    _count?: hobbyCountOrderByAggregateInput
    _avg?: hobbyAvgOrderByAggregateInput
    _max?: hobbyMaxOrderByAggregateInput
    _min?: hobbyMinOrderByAggregateInput
    _sum?: hobbySumOrderByAggregateInput
  }

  export type hobbyScalarWhereWithAggregatesInput = {
    AND?: hobbyScalarWhereWithAggregatesInput | hobbyScalarWhereWithAggregatesInput[]
    OR?: hobbyScalarWhereWithAggregatesInput[]
    NOT?: hobbyScalarWhereWithAggregatesInput | hobbyScalarWhereWithAggregatesInput[]
    hobby_id?: BigIntWithAggregatesFilter<"hobby"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"hobby"> | bigint | number
    hobby_category_id?: BigIntWithAggregatesFilter<"hobby"> | bigint | number
    hobby_name?: StringWithAggregatesFilter<"hobby"> | string
    hobby_group_id?: BigIntWithAggregatesFilter<"hobby"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"hobby"> | Date | string
    created_by?: BigIntWithAggregatesFilter<"hobby"> | bigint | number
    modified_at?: DateTimeWithAggregatesFilter<"hobby"> | Date | string
    modified_by?: BigIntWithAggregatesFilter<"hobby"> | bigint | number
    deleted?: BoolWithAggregatesFilter<"hobby"> | boolean
  }

  export type hobby_categoryWhereInput = {
    AND?: hobby_categoryWhereInput | hobby_categoryWhereInput[]
    OR?: hobby_categoryWhereInput[]
    NOT?: hobby_categoryWhereInput | hobby_categoryWhereInput[]
    hobby_category_id?: BigIntFilter<"hobby_category"> | bigint | number
    hobby_category_name?: Enumhobby_category_hobby_category_nameFilter<"hobby_category"> | $Enums.hobby_category_hobby_category_name
    hobby_category_thumbnail?: StringFilter<"hobby_category"> | string
    created_at?: DateTimeFilter<"hobby_category"> | Date | string
    modified_at?: DateTimeFilter<"hobby_category"> | Date | string
  }

  export type hobby_categoryOrderByWithRelationInput = {
    hobby_category_id?: SortOrder
    hobby_category_name?: SortOrder
    hobby_category_thumbnail?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _relevance?: hobby_categoryOrderByRelevanceInput
  }

  export type hobby_categoryWhereUniqueInput = Prisma.AtLeast<{
    hobby_category_id?: bigint | number
    AND?: hobby_categoryWhereInput | hobby_categoryWhereInput[]
    OR?: hobby_categoryWhereInput[]
    NOT?: hobby_categoryWhereInput | hobby_categoryWhereInput[]
    hobby_category_name?: Enumhobby_category_hobby_category_nameFilter<"hobby_category"> | $Enums.hobby_category_hobby_category_name
    hobby_category_thumbnail?: StringFilter<"hobby_category"> | string
    created_at?: DateTimeFilter<"hobby_category"> | Date | string
    modified_at?: DateTimeFilter<"hobby_category"> | Date | string
  }, "hobby_category_id">

  export type hobby_categoryOrderByWithAggregationInput = {
    hobby_category_id?: SortOrder
    hobby_category_name?: SortOrder
    hobby_category_thumbnail?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: hobby_categoryCountOrderByAggregateInput
    _avg?: hobby_categoryAvgOrderByAggregateInput
    _max?: hobby_categoryMaxOrderByAggregateInput
    _min?: hobby_categoryMinOrderByAggregateInput
    _sum?: hobby_categorySumOrderByAggregateInput
  }

  export type hobby_categoryScalarWhereWithAggregatesInput = {
    AND?: hobby_categoryScalarWhereWithAggregatesInput | hobby_categoryScalarWhereWithAggregatesInput[]
    OR?: hobby_categoryScalarWhereWithAggregatesInput[]
    NOT?: hobby_categoryScalarWhereWithAggregatesInput | hobby_categoryScalarWhereWithAggregatesInput[]
    hobby_category_id?: BigIntWithAggregatesFilter<"hobby_category"> | bigint | number
    hobby_category_name?: Enumhobby_category_hobby_category_nameWithAggregatesFilter<"hobby_category"> | $Enums.hobby_category_hobby_category_name
    hobby_category_thumbnail?: StringWithAggregatesFilter<"hobby_category"> | string
    created_at?: DateTimeWithAggregatesFilter<"hobby_category"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"hobby_category"> | Date | string
  }

  export type hobby_commentWhereInput = {
    AND?: hobby_commentWhereInput | hobby_commentWhereInput[]
    OR?: hobby_commentWhereInput[]
    NOT?: hobby_commentWhereInput | hobby_commentWhereInput[]
    comment_id?: BigIntFilter<"hobby_comment"> | bigint | number
    post_id?: BigIntFilter<"hobby_comment"> | bigint | number
    comment?: StringFilter<"hobby_comment"> | string
    created_at?: DateTimeFilter<"hobby_comment"> | Date | string
    created_by?: BigIntFilter<"hobby_comment"> | bigint | number
    modified_at?: DateTimeFilter<"hobby_comment"> | Date | string
    modified_by?: BigIntFilter<"hobby_comment"> | bigint | number
    deleted?: BoolFilter<"hobby_comment"> | boolean
    deleted_at?: DateTimeNullableFilter<"hobby_comment"> | Date | string | null
  }

  export type hobby_commentOrderByWithRelationInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _relevance?: hobby_commentOrderByRelevanceInput
  }

  export type hobby_commentWhereUniqueInput = Prisma.AtLeast<{
    comment_id?: bigint | number
    created_by_post_id?: hobby_commentCreated_byPost_idCompoundUniqueInput
    AND?: hobby_commentWhereInput | hobby_commentWhereInput[]
    OR?: hobby_commentWhereInput[]
    NOT?: hobby_commentWhereInput | hobby_commentWhereInput[]
    post_id?: BigIntFilter<"hobby_comment"> | bigint | number
    comment?: StringFilter<"hobby_comment"> | string
    created_at?: DateTimeFilter<"hobby_comment"> | Date | string
    created_by?: BigIntFilter<"hobby_comment"> | bigint | number
    modified_at?: DateTimeFilter<"hobby_comment"> | Date | string
    modified_by?: BigIntFilter<"hobby_comment"> | bigint | number
    deleted?: BoolFilter<"hobby_comment"> | boolean
    deleted_at?: DateTimeNullableFilter<"hobby_comment"> | Date | string | null
  }, "comment_id" | "created_by_post_id">

  export type hobby_commentOrderByWithAggregationInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: hobby_commentCountOrderByAggregateInput
    _avg?: hobby_commentAvgOrderByAggregateInput
    _max?: hobby_commentMaxOrderByAggregateInput
    _min?: hobby_commentMinOrderByAggregateInput
    _sum?: hobby_commentSumOrderByAggregateInput
  }

  export type hobby_commentScalarWhereWithAggregatesInput = {
    AND?: hobby_commentScalarWhereWithAggregatesInput | hobby_commentScalarWhereWithAggregatesInput[]
    OR?: hobby_commentScalarWhereWithAggregatesInput[]
    NOT?: hobby_commentScalarWhereWithAggregatesInput | hobby_commentScalarWhereWithAggregatesInput[]
    comment_id?: BigIntWithAggregatesFilter<"hobby_comment"> | bigint | number
    post_id?: BigIntWithAggregatesFilter<"hobby_comment"> | bigint | number
    comment?: StringWithAggregatesFilter<"hobby_comment"> | string
    created_at?: DateTimeWithAggregatesFilter<"hobby_comment"> | Date | string
    created_by?: BigIntWithAggregatesFilter<"hobby_comment"> | bigint | number
    modified_at?: DateTimeWithAggregatesFilter<"hobby_comment"> | Date | string
    modified_by?: BigIntWithAggregatesFilter<"hobby_comment"> | bigint | number
    deleted?: BoolWithAggregatesFilter<"hobby_comment"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"hobby_comment"> | Date | string | null
  }

  export type hobby_groupWhereInput = {
    AND?: hobby_groupWhereInput | hobby_groupWhereInput[]
    OR?: hobby_groupWhereInput[]
    NOT?: hobby_groupWhereInput | hobby_groupWhereInput[]
    hobby_group_id?: BigIntFilter<"hobby_group"> | bigint | number
    user_id?: BigIntFilter<"hobby_group"> | bigint | number
    hobby_group_title?: StringFilter<"hobby_group"> | string
    deleted?: BoolFilter<"hobby_group"> | boolean
    created_at?: DateTimeFilter<"hobby_group"> | Date | string
    created_by?: BigIntFilter<"hobby_group"> | bigint | number
    modified_at?: DateTimeFilter<"hobby_group"> | Date | string
    modified_by?: BigIntFilter<"hobby_group"> | bigint | number
    deleted_at?: DateTimeNullableFilter<"hobby_group"> | Date | string | null
  }

  export type hobby_groupOrderByWithRelationInput = {
    hobby_group_id?: SortOrder
    user_id?: SortOrder
    hobby_group_title?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _relevance?: hobby_groupOrderByRelevanceInput
  }

  export type hobby_groupWhereUniqueInput = Prisma.AtLeast<{
    hobby_group_id?: bigint | number
    created_by_user_id_hobby_group_title?: hobby_groupCreated_byUser_idHobby_group_titleCompoundUniqueInput
    AND?: hobby_groupWhereInput | hobby_groupWhereInput[]
    OR?: hobby_groupWhereInput[]
    NOT?: hobby_groupWhereInput | hobby_groupWhereInput[]
    user_id?: BigIntFilter<"hobby_group"> | bigint | number
    hobby_group_title?: StringFilter<"hobby_group"> | string
    deleted?: BoolFilter<"hobby_group"> | boolean
    created_at?: DateTimeFilter<"hobby_group"> | Date | string
    created_by?: BigIntFilter<"hobby_group"> | bigint | number
    modified_at?: DateTimeFilter<"hobby_group"> | Date | string
    modified_by?: BigIntFilter<"hobby_group"> | bigint | number
    deleted_at?: DateTimeNullableFilter<"hobby_group"> | Date | string | null
  }, "hobby_group_id" | "created_by_user_id_hobby_group_title">

  export type hobby_groupOrderByWithAggregationInput = {
    hobby_group_id?: SortOrder
    user_id?: SortOrder
    hobby_group_title?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: hobby_groupCountOrderByAggregateInput
    _avg?: hobby_groupAvgOrderByAggregateInput
    _max?: hobby_groupMaxOrderByAggregateInput
    _min?: hobby_groupMinOrderByAggregateInput
    _sum?: hobby_groupSumOrderByAggregateInput
  }

  export type hobby_groupScalarWhereWithAggregatesInput = {
    AND?: hobby_groupScalarWhereWithAggregatesInput | hobby_groupScalarWhereWithAggregatesInput[]
    OR?: hobby_groupScalarWhereWithAggregatesInput[]
    NOT?: hobby_groupScalarWhereWithAggregatesInput | hobby_groupScalarWhereWithAggregatesInput[]
    hobby_group_id?: BigIntWithAggregatesFilter<"hobby_group"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"hobby_group"> | bigint | number
    hobby_group_title?: StringWithAggregatesFilter<"hobby_group"> | string
    deleted?: BoolWithAggregatesFilter<"hobby_group"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"hobby_group"> | Date | string
    created_by?: BigIntWithAggregatesFilter<"hobby_group"> | bigint | number
    modified_at?: DateTimeWithAggregatesFilter<"hobby_group"> | Date | string
    modified_by?: BigIntWithAggregatesFilter<"hobby_group"> | bigint | number
    deleted_at?: DateTimeNullableWithAggregatesFilter<"hobby_group"> | Date | string | null
  }

  export type hobby_likeWhereInput = {
    AND?: hobby_likeWhereInput | hobby_likeWhereInput[]
    OR?: hobby_likeWhereInput[]
    NOT?: hobby_likeWhereInput | hobby_likeWhereInput[]
    hobby_like_id?: BigIntFilter<"hobby_like"> | bigint | number
    user_id?: BigIntFilter<"hobby_like"> | bigint | number
    hobby_post_id?: BigIntFilter<"hobby_like"> | bigint | number
    created_at?: DateTimeFilter<"hobby_like"> | Date | string
    created_by?: BigIntFilter<"hobby_like"> | bigint | number
    modified_at?: DateTimeFilter<"hobby_like"> | Date | string
    modified_by?: BigIntFilter<"hobby_like"> | bigint | number
    deleted?: BoolFilter<"hobby_like"> | boolean
  }

  export type hobby_likeOrderByWithRelationInput = {
    hobby_like_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type hobby_likeWhereUniqueInput = Prisma.AtLeast<{
    hobby_like_id?: bigint | number
    user_id_hobby_post_id?: hobby_likeUser_idHobby_post_idCompoundUniqueInput
    AND?: hobby_likeWhereInput | hobby_likeWhereInput[]
    OR?: hobby_likeWhereInput[]
    NOT?: hobby_likeWhereInput | hobby_likeWhereInput[]
    user_id?: BigIntFilter<"hobby_like"> | bigint | number
    hobby_post_id?: BigIntFilter<"hobby_like"> | bigint | number
    created_at?: DateTimeFilter<"hobby_like"> | Date | string
    created_by?: BigIntFilter<"hobby_like"> | bigint | number
    modified_at?: DateTimeFilter<"hobby_like"> | Date | string
    modified_by?: BigIntFilter<"hobby_like"> | bigint | number
    deleted?: BoolFilter<"hobby_like"> | boolean
  }, "hobby_like_id" | "user_id_hobby_post_id">

  export type hobby_likeOrderByWithAggregationInput = {
    hobby_like_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    _count?: hobby_likeCountOrderByAggregateInput
    _avg?: hobby_likeAvgOrderByAggregateInput
    _max?: hobby_likeMaxOrderByAggregateInput
    _min?: hobby_likeMinOrderByAggregateInput
    _sum?: hobby_likeSumOrderByAggregateInput
  }

  export type hobby_likeScalarWhereWithAggregatesInput = {
    AND?: hobby_likeScalarWhereWithAggregatesInput | hobby_likeScalarWhereWithAggregatesInput[]
    OR?: hobby_likeScalarWhereWithAggregatesInput[]
    NOT?: hobby_likeScalarWhereWithAggregatesInput | hobby_likeScalarWhereWithAggregatesInput[]
    hobby_like_id?: BigIntWithAggregatesFilter<"hobby_like"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"hobby_like"> | bigint | number
    hobby_post_id?: BigIntWithAggregatesFilter<"hobby_like"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"hobby_like"> | Date | string
    created_by?: BigIntWithAggregatesFilter<"hobby_like"> | bigint | number
    modified_at?: DateTimeWithAggregatesFilter<"hobby_like"> | Date | string
    modified_by?: BigIntWithAggregatesFilter<"hobby_like"> | bigint | number
    deleted?: BoolWithAggregatesFilter<"hobby_like"> | boolean
  }

  export type hobby_photoWhereInput = {
    AND?: hobby_photoWhereInput | hobby_photoWhereInput[]
    OR?: hobby_photoWhereInput[]
    NOT?: hobby_photoWhereInput | hobby_photoWhereInput[]
    hobby_photo_id?: BigIntFilter<"hobby_photo"> | bigint | number
    hobby_post_id?: BigIntFilter<"hobby_photo"> | bigint | number
    hobby_photo_path?: StringFilter<"hobby_photo"> | string
    deleted?: BoolFilter<"hobby_photo"> | boolean
    created_at?: DateTimeFilter<"hobby_photo"> | Date | string
    created_by?: BigIntFilter<"hobby_photo"> | bigint | number
    modified_at?: DateTimeFilter<"hobby_photo"> | Date | string
    modified_by?: BigIntFilter<"hobby_photo"> | bigint | number
  }

  export type hobby_photoOrderByWithRelationInput = {
    hobby_photo_id?: SortOrder
    hobby_post_id?: SortOrder
    hobby_photo_path?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    _relevance?: hobby_photoOrderByRelevanceInput
  }

  export type hobby_photoWhereUniqueInput = Prisma.AtLeast<{
    hobby_photo_id?: bigint | number
    created_by_hobby_post_id_hobby_photo_path?: hobby_photoCreated_byHobby_post_idHobby_photo_pathCompoundUniqueInput
    AND?: hobby_photoWhereInput | hobby_photoWhereInput[]
    OR?: hobby_photoWhereInput[]
    NOT?: hobby_photoWhereInput | hobby_photoWhereInput[]
    hobby_post_id?: BigIntFilter<"hobby_photo"> | bigint | number
    hobby_photo_path?: StringFilter<"hobby_photo"> | string
    deleted?: BoolFilter<"hobby_photo"> | boolean
    created_at?: DateTimeFilter<"hobby_photo"> | Date | string
    created_by?: BigIntFilter<"hobby_photo"> | bigint | number
    modified_at?: DateTimeFilter<"hobby_photo"> | Date | string
    modified_by?: BigIntFilter<"hobby_photo"> | bigint | number
  }, "hobby_photo_id" | "created_by_hobby_post_id_hobby_photo_path">

  export type hobby_photoOrderByWithAggregationInput = {
    hobby_photo_id?: SortOrder
    hobby_post_id?: SortOrder
    hobby_photo_path?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    _count?: hobby_photoCountOrderByAggregateInput
    _avg?: hobby_photoAvgOrderByAggregateInput
    _max?: hobby_photoMaxOrderByAggregateInput
    _min?: hobby_photoMinOrderByAggregateInput
    _sum?: hobby_photoSumOrderByAggregateInput
  }

  export type hobby_photoScalarWhereWithAggregatesInput = {
    AND?: hobby_photoScalarWhereWithAggregatesInput | hobby_photoScalarWhereWithAggregatesInput[]
    OR?: hobby_photoScalarWhereWithAggregatesInput[]
    NOT?: hobby_photoScalarWhereWithAggregatesInput | hobby_photoScalarWhereWithAggregatesInput[]
    hobby_photo_id?: BigIntWithAggregatesFilter<"hobby_photo"> | bigint | number
    hobby_post_id?: BigIntWithAggregatesFilter<"hobby_photo"> | bigint | number
    hobby_photo_path?: StringWithAggregatesFilter<"hobby_photo"> | string
    deleted?: BoolWithAggregatesFilter<"hobby_photo"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"hobby_photo"> | Date | string
    created_by?: BigIntWithAggregatesFilter<"hobby_photo"> | bigint | number
    modified_at?: DateTimeWithAggregatesFilter<"hobby_photo"> | Date | string
    modified_by?: BigIntWithAggregatesFilter<"hobby_photo"> | bigint | number
  }

  export type hobby_postWhereInput = {
    AND?: hobby_postWhereInput | hobby_postWhereInput[]
    OR?: hobby_postWhereInput[]
    NOT?: hobby_postWhereInput | hobby_postWhereInput[]
    hobby_post_id?: BigIntFilter<"hobby_post"> | bigint | number
    user_id?: BigIntFilter<"hobby_post"> | bigint | number
    hobby_id?: BigIntFilter<"hobby_post"> | bigint | number
    hobby_post_content?: StringFilter<"hobby_post"> | string
    hobby_post_thumbnail?: StringFilter<"hobby_post"> | string
    deleted?: BoolFilter<"hobby_post"> | boolean
    created_at?: DateTimeFilter<"hobby_post"> | Date | string
    created_by?: BigIntFilter<"hobby_post"> | bigint | number
    modified_at?: DateTimeFilter<"hobby_post"> | Date | string
    modified_by?: BigIntFilter<"hobby_post"> | bigint | number
    deleted_at?: DateTimeNullableFilter<"hobby_post"> | Date | string | null
  }

  export type hobby_postOrderByWithRelationInput = {
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    hobby_id?: SortOrder
    hobby_post_content?: SortOrder
    hobby_post_thumbnail?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _relevance?: hobby_postOrderByRelevanceInput
  }

  export type hobby_postWhereUniqueInput = Prisma.AtLeast<{
    hobby_post_id?: bigint | number
    created_by_user_id_hobby_id?: hobby_postCreated_byUser_idHobby_idCompoundUniqueInput
    AND?: hobby_postWhereInput | hobby_postWhereInput[]
    OR?: hobby_postWhereInput[]
    NOT?: hobby_postWhereInput | hobby_postWhereInput[]
    user_id?: BigIntFilter<"hobby_post"> | bigint | number
    hobby_id?: BigIntFilter<"hobby_post"> | bigint | number
    hobby_post_content?: StringFilter<"hobby_post"> | string
    hobby_post_thumbnail?: StringFilter<"hobby_post"> | string
    deleted?: BoolFilter<"hobby_post"> | boolean
    created_at?: DateTimeFilter<"hobby_post"> | Date | string
    created_by?: BigIntFilter<"hobby_post"> | bigint | number
    modified_at?: DateTimeFilter<"hobby_post"> | Date | string
    modified_by?: BigIntFilter<"hobby_post"> | bigint | number
    deleted_at?: DateTimeNullableFilter<"hobby_post"> | Date | string | null
  }, "hobby_post_id" | "created_by_user_id_hobby_id">

  export type hobby_postOrderByWithAggregationInput = {
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    hobby_id?: SortOrder
    hobby_post_content?: SortOrder
    hobby_post_thumbnail?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: hobby_postCountOrderByAggregateInput
    _avg?: hobby_postAvgOrderByAggregateInput
    _max?: hobby_postMaxOrderByAggregateInput
    _min?: hobby_postMinOrderByAggregateInput
    _sum?: hobby_postSumOrderByAggregateInput
  }

  export type hobby_postScalarWhereWithAggregatesInput = {
    AND?: hobby_postScalarWhereWithAggregatesInput | hobby_postScalarWhereWithAggregatesInput[]
    OR?: hobby_postScalarWhereWithAggregatesInput[]
    NOT?: hobby_postScalarWhereWithAggregatesInput | hobby_postScalarWhereWithAggregatesInput[]
    hobby_post_id?: BigIntWithAggregatesFilter<"hobby_post"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"hobby_post"> | bigint | number
    hobby_id?: BigIntWithAggregatesFilter<"hobby_post"> | bigint | number
    hobby_post_content?: StringWithAggregatesFilter<"hobby_post"> | string
    hobby_post_thumbnail?: StringWithAggregatesFilter<"hobby_post"> | string
    deleted?: BoolWithAggregatesFilter<"hobby_post"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"hobby_post"> | Date | string
    created_by?: BigIntWithAggregatesFilter<"hobby_post"> | bigint | number
    modified_at?: DateTimeWithAggregatesFilter<"hobby_post"> | Date | string
    modified_by?: BigIntWithAggregatesFilter<"hobby_post"> | bigint | number
    deleted_at?: DateTimeNullableWithAggregatesFilter<"hobby_post"> | Date | string | null
  }

  export type hobby_sub_commentWhereInput = {
    AND?: hobby_sub_commentWhereInput | hobby_sub_commentWhereInput[]
    OR?: hobby_sub_commentWhereInput[]
    NOT?: hobby_sub_commentWhereInput | hobby_sub_commentWhereInput[]
    sub_comment_id?: BigIntFilter<"hobby_sub_comment"> | bigint | number
    comment_id?: BigIntFilter<"hobby_sub_comment"> | bigint | number
    post_id?: BigIntFilter<"hobby_sub_comment"> | bigint | number
    sub_comment?: StringFilter<"hobby_sub_comment"> | string
    created_at?: DateTimeFilter<"hobby_sub_comment"> | Date | string
    created_by?: BigIntFilter<"hobby_sub_comment"> | bigint | number
    modified_at?: DateTimeFilter<"hobby_sub_comment"> | Date | string
    modified_by?: BigIntFilter<"hobby_sub_comment"> | bigint | number
    deleted?: BoolFilter<"hobby_sub_comment"> | boolean
    deleted_at?: DateTimeNullableFilter<"hobby_sub_comment"> | Date | string | null
  }

  export type hobby_sub_commentOrderByWithRelationInput = {
    sub_comment_id?: SortOrder
    comment_id?: SortOrder
    post_id?: SortOrder
    sub_comment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _relevance?: hobby_sub_commentOrderByRelevanceInput
  }

  export type hobby_sub_commentWhereUniqueInput = Prisma.AtLeast<{
    sub_comment_id?: bigint | number
    created_by_comment_id_post_id?: hobby_sub_commentCreated_byComment_idPost_idCompoundUniqueInput
    AND?: hobby_sub_commentWhereInput | hobby_sub_commentWhereInput[]
    OR?: hobby_sub_commentWhereInput[]
    NOT?: hobby_sub_commentWhereInput | hobby_sub_commentWhereInput[]
    comment_id?: BigIntFilter<"hobby_sub_comment"> | bigint | number
    post_id?: BigIntFilter<"hobby_sub_comment"> | bigint | number
    sub_comment?: StringFilter<"hobby_sub_comment"> | string
    created_at?: DateTimeFilter<"hobby_sub_comment"> | Date | string
    created_by?: BigIntFilter<"hobby_sub_comment"> | bigint | number
    modified_at?: DateTimeFilter<"hobby_sub_comment"> | Date | string
    modified_by?: BigIntFilter<"hobby_sub_comment"> | bigint | number
    deleted?: BoolFilter<"hobby_sub_comment"> | boolean
    deleted_at?: DateTimeNullableFilter<"hobby_sub_comment"> | Date | string | null
  }, "sub_comment_id" | "created_by_comment_id_post_id">

  export type hobby_sub_commentOrderByWithAggregationInput = {
    sub_comment_id?: SortOrder
    comment_id?: SortOrder
    post_id?: SortOrder
    sub_comment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: hobby_sub_commentCountOrderByAggregateInput
    _avg?: hobby_sub_commentAvgOrderByAggregateInput
    _max?: hobby_sub_commentMaxOrderByAggregateInput
    _min?: hobby_sub_commentMinOrderByAggregateInput
    _sum?: hobby_sub_commentSumOrderByAggregateInput
  }

  export type hobby_sub_commentScalarWhereWithAggregatesInput = {
    AND?: hobby_sub_commentScalarWhereWithAggregatesInput | hobby_sub_commentScalarWhereWithAggregatesInput[]
    OR?: hobby_sub_commentScalarWhereWithAggregatesInput[]
    NOT?: hobby_sub_commentScalarWhereWithAggregatesInput | hobby_sub_commentScalarWhereWithAggregatesInput[]
    sub_comment_id?: BigIntWithAggregatesFilter<"hobby_sub_comment"> | bigint | number
    comment_id?: BigIntWithAggregatesFilter<"hobby_sub_comment"> | bigint | number
    post_id?: BigIntWithAggregatesFilter<"hobby_sub_comment"> | bigint | number
    sub_comment?: StringWithAggregatesFilter<"hobby_sub_comment"> | string
    created_at?: DateTimeWithAggregatesFilter<"hobby_sub_comment"> | Date | string
    created_by?: BigIntWithAggregatesFilter<"hobby_sub_comment"> | bigint | number
    modified_at?: DateTimeWithAggregatesFilter<"hobby_sub_comment"> | Date | string
    modified_by?: BigIntWithAggregatesFilter<"hobby_sub_comment"> | bigint | number
    deleted?: BoolWithAggregatesFilter<"hobby_sub_comment"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"hobby_sub_comment"> | Date | string | null
  }

  export type hobby_top_tenWhereInput = {
    AND?: hobby_top_tenWhereInput | hobby_top_tenWhereInput[]
    OR?: hobby_top_tenWhereInput[]
    NOT?: hobby_top_tenWhereInput | hobby_top_tenWhereInput[]
    hobby_top_ten_id?: BigIntFilter<"hobby_top_ten"> | bigint | number
    hobby_post_id?: BigIntFilter<"hobby_top_ten"> | bigint | number
    view_count?: BigIntFilter<"hobby_top_ten"> | bigint | number
    category?: Enumhobby_top_ten_categoryFilter<"hobby_top_ten"> | $Enums.hobby_top_ten_category
    created_at?: DateTimeFilter<"hobby_top_ten"> | Date | string
  }

  export type hobby_top_tenOrderByWithRelationInput = {
    hobby_top_ten_id?: SortOrder
    hobby_post_id?: SortOrder
    view_count?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
  }

  export type hobby_top_tenWhereUniqueInput = Prisma.AtLeast<{
    hobby_top_ten_id?: bigint | number
    hobby_post_id_view_count_created_at?: hobby_top_tenHobby_post_idView_countCreated_atCompoundUniqueInput
    AND?: hobby_top_tenWhereInput | hobby_top_tenWhereInput[]
    OR?: hobby_top_tenWhereInput[]
    NOT?: hobby_top_tenWhereInput | hobby_top_tenWhereInput[]
    hobby_post_id?: BigIntFilter<"hobby_top_ten"> | bigint | number
    view_count?: BigIntFilter<"hobby_top_ten"> | bigint | number
    category?: Enumhobby_top_ten_categoryFilter<"hobby_top_ten"> | $Enums.hobby_top_ten_category
    created_at?: DateTimeFilter<"hobby_top_ten"> | Date | string
  }, "hobby_top_ten_id" | "hobby_post_id_view_count_created_at">

  export type hobby_top_tenOrderByWithAggregationInput = {
    hobby_top_ten_id?: SortOrder
    hobby_post_id?: SortOrder
    view_count?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    _count?: hobby_top_tenCountOrderByAggregateInput
    _avg?: hobby_top_tenAvgOrderByAggregateInput
    _max?: hobby_top_tenMaxOrderByAggregateInput
    _min?: hobby_top_tenMinOrderByAggregateInput
    _sum?: hobby_top_tenSumOrderByAggregateInput
  }

  export type hobby_top_tenScalarWhereWithAggregatesInput = {
    AND?: hobby_top_tenScalarWhereWithAggregatesInput | hobby_top_tenScalarWhereWithAggregatesInput[]
    OR?: hobby_top_tenScalarWhereWithAggregatesInput[]
    NOT?: hobby_top_tenScalarWhereWithAggregatesInput | hobby_top_tenScalarWhereWithAggregatesInput[]
    hobby_top_ten_id?: BigIntWithAggregatesFilter<"hobby_top_ten"> | bigint | number
    hobby_post_id?: BigIntWithAggregatesFilter<"hobby_top_ten"> | bigint | number
    view_count?: BigIntWithAggregatesFilter<"hobby_top_ten"> | bigint | number
    category?: Enumhobby_top_ten_categoryWithAggregatesFilter<"hobby_top_ten"> | $Enums.hobby_top_ten_category
    created_at?: DateTimeWithAggregatesFilter<"hobby_top_ten"> | Date | string
  }

  export type hobby_view_historyWhereInput = {
    AND?: hobby_view_historyWhereInput | hobby_view_historyWhereInput[]
    OR?: hobby_view_historyWhereInput[]
    NOT?: hobby_view_historyWhereInput | hobby_view_historyWhereInput[]
    hobby_view_history_id?: BigIntFilter<"hobby_view_history"> | bigint | number
    hobby_post_id?: BigIntFilter<"hobby_view_history"> | bigint | number
    user_id?: BigIntFilter<"hobby_view_history"> | bigint | number
    category?: Enumhobby_view_history_categoryFilter<"hobby_view_history"> | $Enums.hobby_view_history_category
    created_at?: DateTimeFilter<"hobby_view_history"> | Date | string
    modified_at?: DateTimeFilter<"hobby_view_history"> | Date | string
    created_by?: BigIntFilter<"hobby_view_history"> | bigint | number
    modified_by?: BigIntFilter<"hobby_view_history"> | bigint | number
    deleted?: BoolFilter<"hobby_view_history"> | boolean
  }

  export type hobby_view_historyOrderByWithRelationInput = {
    hobby_view_history_id?: SortOrder
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type hobby_view_historyWhereUniqueInput = Prisma.AtLeast<{
    hobby_view_history_id?: bigint | number
    user_id_hobby_post_id?: hobby_view_historyUser_idHobby_post_idCompoundUniqueInput
    AND?: hobby_view_historyWhereInput | hobby_view_historyWhereInput[]
    OR?: hobby_view_historyWhereInput[]
    NOT?: hobby_view_historyWhereInput | hobby_view_historyWhereInput[]
    hobby_post_id?: BigIntFilter<"hobby_view_history"> | bigint | number
    user_id?: BigIntFilter<"hobby_view_history"> | bigint | number
    category?: Enumhobby_view_history_categoryFilter<"hobby_view_history"> | $Enums.hobby_view_history_category
    created_at?: DateTimeFilter<"hobby_view_history"> | Date | string
    modified_at?: DateTimeFilter<"hobby_view_history"> | Date | string
    created_by?: BigIntFilter<"hobby_view_history"> | bigint | number
    modified_by?: BigIntFilter<"hobby_view_history"> | bigint | number
    deleted?: BoolFilter<"hobby_view_history"> | boolean
  }, "hobby_view_history_id" | "user_id_hobby_post_id">

  export type hobby_view_historyOrderByWithAggregationInput = {
    hobby_view_history_id?: SortOrder
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    _count?: hobby_view_historyCountOrderByAggregateInput
    _avg?: hobby_view_historyAvgOrderByAggregateInput
    _max?: hobby_view_historyMaxOrderByAggregateInput
    _min?: hobby_view_historyMinOrderByAggregateInput
    _sum?: hobby_view_historySumOrderByAggregateInput
  }

  export type hobby_view_historyScalarWhereWithAggregatesInput = {
    AND?: hobby_view_historyScalarWhereWithAggregatesInput | hobby_view_historyScalarWhereWithAggregatesInput[]
    OR?: hobby_view_historyScalarWhereWithAggregatesInput[]
    NOT?: hobby_view_historyScalarWhereWithAggregatesInput | hobby_view_historyScalarWhereWithAggregatesInput[]
    hobby_view_history_id?: BigIntWithAggregatesFilter<"hobby_view_history"> | bigint | number
    hobby_post_id?: BigIntWithAggregatesFilter<"hobby_view_history"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"hobby_view_history"> | bigint | number
    category?: Enumhobby_view_history_categoryWithAggregatesFilter<"hobby_view_history"> | $Enums.hobby_view_history_category
    created_at?: DateTimeWithAggregatesFilter<"hobby_view_history"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"hobby_view_history"> | Date | string
    created_by?: BigIntWithAggregatesFilter<"hobby_view_history"> | bigint | number
    modified_by?: BigIntWithAggregatesFilter<"hobby_view_history"> | bigint | number
    deleted?: BoolWithAggregatesFilter<"hobby_view_history"> | boolean
  }

  export type itemWhereInput = {
    AND?: itemWhereInput | itemWhereInput[]
    OR?: itemWhereInput[]
    NOT?: itemWhereInput | itemWhereInput[]
    item_id?: BigIntFilter<"item"> | bigint | number
    item_name?: StringNullableFilter<"item"> | string | null
    bag_id?: BigIntNullableFilter<"item"> | bigint | number | null
  }

  export type itemOrderByWithRelationInput = {
    item_id?: SortOrder
    item_name?: SortOrderInput | SortOrder
    bag_id?: SortOrderInput | SortOrder
    _relevance?: itemOrderByRelevanceInput
  }

  export type itemWhereUniqueInput = Prisma.AtLeast<{
    item_id?: bigint | number
    AND?: itemWhereInput | itemWhereInput[]
    OR?: itemWhereInput[]
    NOT?: itemWhereInput | itemWhereInput[]
    item_name?: StringNullableFilter<"item"> | string | null
    bag_id?: BigIntNullableFilter<"item"> | bigint | number | null
  }, "item_id">

  export type itemOrderByWithAggregationInput = {
    item_id?: SortOrder
    item_name?: SortOrderInput | SortOrder
    bag_id?: SortOrderInput | SortOrder
    _count?: itemCountOrderByAggregateInput
    _avg?: itemAvgOrderByAggregateInput
    _max?: itemMaxOrderByAggregateInput
    _min?: itemMinOrderByAggregateInput
    _sum?: itemSumOrderByAggregateInput
  }

  export type itemScalarWhereWithAggregatesInput = {
    AND?: itemScalarWhereWithAggregatesInput | itemScalarWhereWithAggregatesInput[]
    OR?: itemScalarWhereWithAggregatesInput[]
    NOT?: itemScalarWhereWithAggregatesInput | itemScalarWhereWithAggregatesInput[]
    item_id?: BigIntWithAggregatesFilter<"item"> | bigint | number
    item_name?: StringNullableWithAggregatesFilter<"item"> | string | null
    bag_id?: BigIntNullableWithAggregatesFilter<"item"> | bigint | number | null
  }

  export type memberWhereInput = {
    AND?: memberWhereInput | memberWhereInput[]
    OR?: memberWhereInput[]
    NOT?: memberWhereInput | memberWhereInput[]
    studentId?: BigIntFilter<"member"> | bigint | number
    studentName?: StringNullableFilter<"member"> | string | null
    studentEmail?: StringNullableFilter<"member"> | string | null
  }

  export type memberOrderByWithRelationInput = {
    studentId?: SortOrder
    studentName?: SortOrderInput | SortOrder
    studentEmail?: SortOrderInput | SortOrder
    _relevance?: memberOrderByRelevanceInput
  }

  export type memberWhereUniqueInput = Prisma.AtLeast<{
    studentId?: bigint | number
    AND?: memberWhereInput | memberWhereInput[]
    OR?: memberWhereInput[]
    NOT?: memberWhereInput | memberWhereInput[]
    studentName?: StringNullableFilter<"member"> | string | null
    studentEmail?: StringNullableFilter<"member"> | string | null
  }, "studentId">

  export type memberOrderByWithAggregationInput = {
    studentId?: SortOrder
    studentName?: SortOrderInput | SortOrder
    studentEmail?: SortOrderInput | SortOrder
    _count?: memberCountOrderByAggregateInput
    _avg?: memberAvgOrderByAggregateInput
    _max?: memberMaxOrderByAggregateInput
    _min?: memberMinOrderByAggregateInput
    _sum?: memberSumOrderByAggregateInput
  }

  export type memberScalarWhereWithAggregatesInput = {
    AND?: memberScalarWhereWithAggregatesInput | memberScalarWhereWithAggregatesInput[]
    OR?: memberScalarWhereWithAggregatesInput[]
    NOT?: memberScalarWhereWithAggregatesInput | memberScalarWhereWithAggregatesInput[]
    studentId?: BigIntWithAggregatesFilter<"member"> | bigint | number
    studentName?: StringNullableWithAggregatesFilter<"member"> | string | null
    studentEmail?: StringNullableWithAggregatesFilter<"member"> | string | null
  }

  export type policy_agreeWhereInput = {
    AND?: policy_agreeWhereInput | policy_agreeWhereInput[]
    OR?: policy_agreeWhereInput[]
    NOT?: policy_agreeWhereInput | policy_agreeWhereInput[]
    policy_agree_id?: BigIntFilter<"policy_agree"> | bigint | number
    policy_type?: Enumpolicy_agree_policy_typeFilter<"policy_agree"> | $Enums.policy_agree_policy_type
    policy_history_id?: BigIntFilter<"policy_agree"> | bigint | number
    user_id?: BigIntFilter<"policy_agree"> | bigint | number
    created_at?: DateTimeFilter<"policy_agree"> | Date | string
    modified_at?: DateTimeFilter<"policy_agree"> | Date | string
  }

  export type policy_agreeOrderByWithRelationInput = {
    policy_agree_id?: SortOrder
    policy_type?: SortOrder
    policy_history_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type policy_agreeWhereUniqueInput = Prisma.AtLeast<{
    policy_agree_id?: bigint | number
    AND?: policy_agreeWhereInput | policy_agreeWhereInput[]
    OR?: policy_agreeWhereInput[]
    NOT?: policy_agreeWhereInput | policy_agreeWhereInput[]
    policy_type?: Enumpolicy_agree_policy_typeFilter<"policy_agree"> | $Enums.policy_agree_policy_type
    policy_history_id?: BigIntFilter<"policy_agree"> | bigint | number
    user_id?: BigIntFilter<"policy_agree"> | bigint | number
    created_at?: DateTimeFilter<"policy_agree"> | Date | string
    modified_at?: DateTimeFilter<"policy_agree"> | Date | string
  }, "policy_agree_id">

  export type policy_agreeOrderByWithAggregationInput = {
    policy_agree_id?: SortOrder
    policy_type?: SortOrder
    policy_history_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: policy_agreeCountOrderByAggregateInput
    _avg?: policy_agreeAvgOrderByAggregateInput
    _max?: policy_agreeMaxOrderByAggregateInput
    _min?: policy_agreeMinOrderByAggregateInput
    _sum?: policy_agreeSumOrderByAggregateInput
  }

  export type policy_agreeScalarWhereWithAggregatesInput = {
    AND?: policy_agreeScalarWhereWithAggregatesInput | policy_agreeScalarWhereWithAggregatesInput[]
    OR?: policy_agreeScalarWhereWithAggregatesInput[]
    NOT?: policy_agreeScalarWhereWithAggregatesInput | policy_agreeScalarWhereWithAggregatesInput[]
    policy_agree_id?: BigIntWithAggregatesFilter<"policy_agree"> | bigint | number
    policy_type?: Enumpolicy_agree_policy_typeWithAggregatesFilter<"policy_agree"> | $Enums.policy_agree_policy_type
    policy_history_id?: BigIntWithAggregatesFilter<"policy_agree"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"policy_agree"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"policy_agree"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"policy_agree"> | Date | string
  }

  export type policy_historyWhereInput = {
    AND?: policy_historyWhereInput | policy_historyWhereInput[]
    OR?: policy_historyWhereInput[]
    NOT?: policy_historyWhereInput | policy_historyWhereInput[]
    policy_history_id?: BigIntFilter<"policy_history"> | bigint | number
    policy_type?: Enumpolicy_history_policy_typeFilter<"policy_history"> | $Enums.policy_history_policy_type
    revision_date?: DateTimeFilter<"policy_history"> | Date | string
    pdf_file_path?: StringFilter<"policy_history"> | string
    required?: BoolFilter<"policy_history"> | boolean
    is_latest_revision?: BoolFilter<"policy_history"> | boolean
    created_at?: DateTimeFilter<"policy_history"> | Date | string
    modified_at?: DateTimeFilter<"policy_history"> | Date | string
  }

  export type policy_historyOrderByWithRelationInput = {
    policy_history_id?: SortOrder
    policy_type?: SortOrder
    revision_date?: SortOrder
    pdf_file_path?: SortOrder
    required?: SortOrder
    is_latest_revision?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _relevance?: policy_historyOrderByRelevanceInput
  }

  export type policy_historyWhereUniqueInput = Prisma.AtLeast<{
    policy_history_id?: bigint | number
    AND?: policy_historyWhereInput | policy_historyWhereInput[]
    OR?: policy_historyWhereInput[]
    NOT?: policy_historyWhereInput | policy_historyWhereInput[]
    policy_type?: Enumpolicy_history_policy_typeFilter<"policy_history"> | $Enums.policy_history_policy_type
    revision_date?: DateTimeFilter<"policy_history"> | Date | string
    pdf_file_path?: StringFilter<"policy_history"> | string
    required?: BoolFilter<"policy_history"> | boolean
    is_latest_revision?: BoolFilter<"policy_history"> | boolean
    created_at?: DateTimeFilter<"policy_history"> | Date | string
    modified_at?: DateTimeFilter<"policy_history"> | Date | string
  }, "policy_history_id">

  export type policy_historyOrderByWithAggregationInput = {
    policy_history_id?: SortOrder
    policy_type?: SortOrder
    revision_date?: SortOrder
    pdf_file_path?: SortOrder
    required?: SortOrder
    is_latest_revision?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: policy_historyCountOrderByAggregateInput
    _avg?: policy_historyAvgOrderByAggregateInput
    _max?: policy_historyMaxOrderByAggregateInput
    _min?: policy_historyMinOrderByAggregateInput
    _sum?: policy_historySumOrderByAggregateInput
  }

  export type policy_historyScalarWhereWithAggregatesInput = {
    AND?: policy_historyScalarWhereWithAggregatesInput | policy_historyScalarWhereWithAggregatesInput[]
    OR?: policy_historyScalarWhereWithAggregatesInput[]
    NOT?: policy_historyScalarWhereWithAggregatesInput | policy_historyScalarWhereWithAggregatesInput[]
    policy_history_id?: BigIntWithAggregatesFilter<"policy_history"> | bigint | number
    policy_type?: Enumpolicy_history_policy_typeWithAggregatesFilter<"policy_history"> | $Enums.policy_history_policy_type
    revision_date?: DateTimeWithAggregatesFilter<"policy_history"> | Date | string
    pdf_file_path?: StringWithAggregatesFilter<"policy_history"> | string
    required?: BoolWithAggregatesFilter<"policy_history"> | boolean
    is_latest_revision?: BoolWithAggregatesFilter<"policy_history"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"policy_history"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"policy_history"> | Date | string
  }

  export type post_hashtagWhereInput = {
    AND?: post_hashtagWhereInput | post_hashtagWhereInput[]
    OR?: post_hashtagWhereInput[]
    NOT?: post_hashtagWhereInput | post_hashtagWhereInput[]
    post_hashtags_id?: BigIntFilter<"post_hashtag"> | bigint | number
    post_id?: BigIntFilter<"post_hashtag"> | bigint | number
    hashtag_id?: BigIntFilter<"post_hashtag"> | bigint | number
    created_at?: DateTimeFilter<"post_hashtag"> | Date | string
    modified_at?: DateTimeFilter<"post_hashtag"> | Date | string
    deleted?: BoolFilter<"post_hashtag"> | boolean
    deleted_at?: DateTimeNullableFilter<"post_hashtag"> | Date | string | null
  }

  export type post_hashtagOrderByWithRelationInput = {
    post_hashtags_id?: SortOrder
    post_id?: SortOrder
    hashtag_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
  }

  export type post_hashtagWhereUniqueInput = Prisma.AtLeast<{
    post_hashtags_id?: bigint | number
    post_hashtags_id_post_id_hashtag_id?: post_hashtagPost_hashtags_idPost_idHashtag_idCompoundUniqueInput
    AND?: post_hashtagWhereInput | post_hashtagWhereInput[]
    OR?: post_hashtagWhereInput[]
    NOT?: post_hashtagWhereInput | post_hashtagWhereInput[]
    post_id?: BigIntFilter<"post_hashtag"> | bigint | number
    hashtag_id?: BigIntFilter<"post_hashtag"> | bigint | number
    created_at?: DateTimeFilter<"post_hashtag"> | Date | string
    modified_at?: DateTimeFilter<"post_hashtag"> | Date | string
    deleted?: BoolFilter<"post_hashtag"> | boolean
    deleted_at?: DateTimeNullableFilter<"post_hashtag"> | Date | string | null
  }, "post_hashtags_id" | "post_hashtags_id_post_id_hashtag_id">

  export type post_hashtagOrderByWithAggregationInput = {
    post_hashtags_id?: SortOrder
    post_id?: SortOrder
    hashtag_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: post_hashtagCountOrderByAggregateInput
    _avg?: post_hashtagAvgOrderByAggregateInput
    _max?: post_hashtagMaxOrderByAggregateInput
    _min?: post_hashtagMinOrderByAggregateInput
    _sum?: post_hashtagSumOrderByAggregateInput
  }

  export type post_hashtagScalarWhereWithAggregatesInput = {
    AND?: post_hashtagScalarWhereWithAggregatesInput | post_hashtagScalarWhereWithAggregatesInput[]
    OR?: post_hashtagScalarWhereWithAggregatesInput[]
    NOT?: post_hashtagScalarWhereWithAggregatesInput | post_hashtagScalarWhereWithAggregatesInput[]
    post_hashtags_id?: BigIntWithAggregatesFilter<"post_hashtag"> | bigint | number
    post_id?: BigIntWithAggregatesFilter<"post_hashtag"> | bigint | number
    hashtag_id?: BigIntWithAggregatesFilter<"post_hashtag"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"post_hashtag"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"post_hashtag"> | Date | string
    deleted?: BoolWithAggregatesFilter<"post_hashtag"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"post_hashtag"> | Date | string | null
  }

  export type recommended_feedWhereInput = {
    AND?: recommended_feedWhereInput | recommended_feedWhereInput[]
    OR?: recommended_feedWhereInput[]
    NOT?: recommended_feedWhereInput | recommended_feedWhereInput[]
    recommended_feed_id?: BigIntFilter<"recommended_feed"> | bigint | number
    hobby_post_id?: BigIntFilter<"recommended_feed"> | bigint | number
    recommended_type?: Enumrecommended_feed_recommended_typeNullableFilter<"recommended_feed"> | $Enums.recommended_feed_recommended_type | null
    created_at?: DateTimeFilter<"recommended_feed"> | Date | string
    created_by?: BigIntFilter<"recommended_feed"> | bigint | number
    modified_at?: DateTimeFilter<"recommended_feed"> | Date | string
    modified_by?: BigIntFilter<"recommended_feed"> | bigint | number
    deleted?: BoolFilter<"recommended_feed"> | boolean
  }

  export type recommended_feedOrderByWithRelationInput = {
    recommended_feed_id?: SortOrder
    hobby_post_id?: SortOrder
    recommended_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type recommended_feedWhereUniqueInput = Prisma.AtLeast<{
    recommended_feed_id?: bigint | number
    AND?: recommended_feedWhereInput | recommended_feedWhereInput[]
    OR?: recommended_feedWhereInput[]
    NOT?: recommended_feedWhereInput | recommended_feedWhereInput[]
    hobby_post_id?: BigIntFilter<"recommended_feed"> | bigint | number
    recommended_type?: Enumrecommended_feed_recommended_typeNullableFilter<"recommended_feed"> | $Enums.recommended_feed_recommended_type | null
    created_at?: DateTimeFilter<"recommended_feed"> | Date | string
    created_by?: BigIntFilter<"recommended_feed"> | bigint | number
    modified_at?: DateTimeFilter<"recommended_feed"> | Date | string
    modified_by?: BigIntFilter<"recommended_feed"> | bigint | number
    deleted?: BoolFilter<"recommended_feed"> | boolean
  }, "recommended_feed_id">

  export type recommended_feedOrderByWithAggregationInput = {
    recommended_feed_id?: SortOrder
    hobby_post_id?: SortOrder
    recommended_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    _count?: recommended_feedCountOrderByAggregateInput
    _avg?: recommended_feedAvgOrderByAggregateInput
    _max?: recommended_feedMaxOrderByAggregateInput
    _min?: recommended_feedMinOrderByAggregateInput
    _sum?: recommended_feedSumOrderByAggregateInput
  }

  export type recommended_feedScalarWhereWithAggregatesInput = {
    AND?: recommended_feedScalarWhereWithAggregatesInput | recommended_feedScalarWhereWithAggregatesInput[]
    OR?: recommended_feedScalarWhereWithAggregatesInput[]
    NOT?: recommended_feedScalarWhereWithAggregatesInput | recommended_feedScalarWhereWithAggregatesInput[]
    recommended_feed_id?: BigIntWithAggregatesFilter<"recommended_feed"> | bigint | number
    hobby_post_id?: BigIntWithAggregatesFilter<"recommended_feed"> | bigint | number
    recommended_type?: Enumrecommended_feed_recommended_typeNullableWithAggregatesFilter<"recommended_feed"> | $Enums.recommended_feed_recommended_type | null
    created_at?: DateTimeWithAggregatesFilter<"recommended_feed"> | Date | string
    created_by?: BigIntWithAggregatesFilter<"recommended_feed"> | bigint | number
    modified_at?: DateTimeWithAggregatesFilter<"recommended_feed"> | Date | string
    modified_by?: BigIntWithAggregatesFilter<"recommended_feed"> | bigint | number
    deleted?: BoolWithAggregatesFilter<"recommended_feed"> | boolean
  }

  export type reportWhereInput = {
    AND?: reportWhereInput | reportWhereInput[]
    OR?: reportWhereInput[]
    NOT?: reportWhereInput | reportWhereInput[]
    report_id?: BigIntFilter<"report"> | bigint | number
    user_id?: BigIntFilter<"report"> | bigint | number
    hobby_post_id?: BigIntNullableFilter<"report"> | bigint | number | null
    comment_id?: BigIntNullableFilter<"report"> | bigint | number | null
    sub_comment_id?: BigIntNullableFilter<"report"> | bigint | number | null
    report_content?: StringFilter<"report"> | string
    report_status?: Enumreport_report_statusFilter<"report"> | $Enums.report_report_status
    created_at?: DateTimeFilter<"report"> | Date | string
    created_by?: BigIntFilter<"report"> | bigint | number
    modified_at?: DateTimeFilter<"report"> | Date | string
    modified_by?: BigIntFilter<"report"> | bigint | number
    deleted?: BoolFilter<"report"> | boolean
  }

  export type reportOrderByWithRelationInput = {
    report_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrderInput | SortOrder
    comment_id?: SortOrderInput | SortOrder
    sub_comment_id?: SortOrderInput | SortOrder
    report_content?: SortOrder
    report_status?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    _relevance?: reportOrderByRelevanceInput
  }

  export type reportWhereUniqueInput = Prisma.AtLeast<{
    report_id?: bigint | number
    created_at_user_id?: reportCreated_atUser_idCompoundUniqueInput
    AND?: reportWhereInput | reportWhereInput[]
    OR?: reportWhereInput[]
    NOT?: reportWhereInput | reportWhereInput[]
    user_id?: BigIntFilter<"report"> | bigint | number
    hobby_post_id?: BigIntNullableFilter<"report"> | bigint | number | null
    comment_id?: BigIntNullableFilter<"report"> | bigint | number | null
    sub_comment_id?: BigIntNullableFilter<"report"> | bigint | number | null
    report_content?: StringFilter<"report"> | string
    report_status?: Enumreport_report_statusFilter<"report"> | $Enums.report_report_status
    created_at?: DateTimeFilter<"report"> | Date | string
    created_by?: BigIntFilter<"report"> | bigint | number
    modified_at?: DateTimeFilter<"report"> | Date | string
    modified_by?: BigIntFilter<"report"> | bigint | number
    deleted?: BoolFilter<"report"> | boolean
  }, "report_id" | "created_at_user_id">

  export type reportOrderByWithAggregationInput = {
    report_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrderInput | SortOrder
    comment_id?: SortOrderInput | SortOrder
    sub_comment_id?: SortOrderInput | SortOrder
    report_content?: SortOrder
    report_status?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    _count?: reportCountOrderByAggregateInput
    _avg?: reportAvgOrderByAggregateInput
    _max?: reportMaxOrderByAggregateInput
    _min?: reportMinOrderByAggregateInput
    _sum?: reportSumOrderByAggregateInput
  }

  export type reportScalarWhereWithAggregatesInput = {
    AND?: reportScalarWhereWithAggregatesInput | reportScalarWhereWithAggregatesInput[]
    OR?: reportScalarWhereWithAggregatesInput[]
    NOT?: reportScalarWhereWithAggregatesInput | reportScalarWhereWithAggregatesInput[]
    report_id?: BigIntWithAggregatesFilter<"report"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"report"> | bigint | number
    hobby_post_id?: BigIntNullableWithAggregatesFilter<"report"> | bigint | number | null
    comment_id?: BigIntNullableWithAggregatesFilter<"report"> | bigint | number | null
    sub_comment_id?: BigIntNullableWithAggregatesFilter<"report"> | bigint | number | null
    report_content?: StringWithAggregatesFilter<"report"> | string
    report_status?: Enumreport_report_statusWithAggregatesFilter<"report"> | $Enums.report_report_status
    created_at?: DateTimeWithAggregatesFilter<"report"> | Date | string
    created_by?: BigIntWithAggregatesFilter<"report"> | bigint | number
    modified_at?: DateTimeWithAggregatesFilter<"report"> | Date | string
    modified_by?: BigIntWithAggregatesFilter<"report"> | bigint | number
    deleted?: BoolWithAggregatesFilter<"report"> | boolean
  }

  export type settingWhereInput = {
    AND?: settingWhereInput | settingWhereInput[]
    OR?: settingWhereInput[]
    NOT?: settingWhereInput | settingWhereInput[]
    setting_id?: BigIntFilter<"setting"> | bigint | number
    user_id?: BigIntFilter<"setting"> | bigint | number
    notification?: BoolFilter<"setting"> | boolean
    marketing?: BoolFilter<"setting"> | boolean
    created_at?: DateTimeFilter<"setting"> | Date | string
    created_by?: BigIntFilter<"setting"> | bigint | number
    modified_at?: DateTimeFilter<"setting"> | Date | string
    modified_by?: BigIntFilter<"setting"> | bigint | number
    deleted?: BoolFilter<"setting"> | boolean
  }

  export type settingOrderByWithRelationInput = {
    setting_id?: SortOrder
    user_id?: SortOrder
    notification?: SortOrder
    marketing?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type settingWhereUniqueInput = Prisma.AtLeast<{
    setting_id?: bigint | number
    AND?: settingWhereInput | settingWhereInput[]
    OR?: settingWhereInput[]
    NOT?: settingWhereInput | settingWhereInput[]
    user_id?: BigIntFilter<"setting"> | bigint | number
    notification?: BoolFilter<"setting"> | boolean
    marketing?: BoolFilter<"setting"> | boolean
    created_at?: DateTimeFilter<"setting"> | Date | string
    created_by?: BigIntFilter<"setting"> | bigint | number
    modified_at?: DateTimeFilter<"setting"> | Date | string
    modified_by?: BigIntFilter<"setting"> | bigint | number
    deleted?: BoolFilter<"setting"> | boolean
  }, "setting_id">

  export type settingOrderByWithAggregationInput = {
    setting_id?: SortOrder
    user_id?: SortOrder
    notification?: SortOrder
    marketing?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    _count?: settingCountOrderByAggregateInput
    _avg?: settingAvgOrderByAggregateInput
    _max?: settingMaxOrderByAggregateInput
    _min?: settingMinOrderByAggregateInput
    _sum?: settingSumOrderByAggregateInput
  }

  export type settingScalarWhereWithAggregatesInput = {
    AND?: settingScalarWhereWithAggregatesInput | settingScalarWhereWithAggregatesInput[]
    OR?: settingScalarWhereWithAggregatesInput[]
    NOT?: settingScalarWhereWithAggregatesInput | settingScalarWhereWithAggregatesInput[]
    setting_id?: BigIntWithAggregatesFilter<"setting"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"setting"> | bigint | number
    notification?: BoolWithAggregatesFilter<"setting"> | boolean
    marketing?: BoolWithAggregatesFilter<"setting"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"setting"> | Date | string
    created_by?: BigIntWithAggregatesFilter<"setting"> | bigint | number
    modified_at?: DateTimeWithAggregatesFilter<"setting"> | Date | string
    modified_by?: BigIntWithAggregatesFilter<"setting"> | bigint | number
    deleted?: BoolWithAggregatesFilter<"setting"> | boolean
  }

  export type today_hobbyWhereInput = {
    AND?: today_hobbyWhereInput | today_hobbyWhereInput[]
    OR?: today_hobbyWhereInput[]
    NOT?: today_hobbyWhereInput | today_hobbyWhereInput[]
    today_hobby_id?: BigIntFilter<"today_hobby"> | bigint | number
    hobby_category_id?: BigIntNullableFilter<"today_hobby"> | bigint | number | null
    today_theme_code?: BigIntNullableFilter<"today_hobby"> | bigint | number | null
    today_theme_name?: StringFilter<"today_hobby"> | string
    today_hobby_details_name?: StringFilter<"today_hobby"> | string
    today_hobby_details_description?: StringFilter<"today_hobby"> | string
    today_hobby_details_attributes?: StringFilter<"today_hobby"> | string
    today_hobby_thumbnail?: StringFilter<"today_hobby"> | string
    created_at?: DateTimeFilter<"today_hobby"> | Date | string
    modified_at?: DateTimeFilter<"today_hobby"> | Date | string
  }

  export type today_hobbyOrderByWithRelationInput = {
    today_hobby_id?: SortOrder
    hobby_category_id?: SortOrderInput | SortOrder
    today_theme_code?: SortOrderInput | SortOrder
    today_theme_name?: SortOrder
    today_hobby_details_name?: SortOrder
    today_hobby_details_description?: SortOrder
    today_hobby_details_attributes?: SortOrder
    today_hobby_thumbnail?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _relevance?: today_hobbyOrderByRelevanceInput
  }

  export type today_hobbyWhereUniqueInput = Prisma.AtLeast<{
    today_hobby_id?: bigint | number
    today_hobby_details_name?: string
    AND?: today_hobbyWhereInput | today_hobbyWhereInput[]
    OR?: today_hobbyWhereInput[]
    NOT?: today_hobbyWhereInput | today_hobbyWhereInput[]
    hobby_category_id?: BigIntNullableFilter<"today_hobby"> | bigint | number | null
    today_theme_code?: BigIntNullableFilter<"today_hobby"> | bigint | number | null
    today_theme_name?: StringFilter<"today_hobby"> | string
    today_hobby_details_description?: StringFilter<"today_hobby"> | string
    today_hobby_details_attributes?: StringFilter<"today_hobby"> | string
    today_hobby_thumbnail?: StringFilter<"today_hobby"> | string
    created_at?: DateTimeFilter<"today_hobby"> | Date | string
    modified_at?: DateTimeFilter<"today_hobby"> | Date | string
  }, "today_hobby_id" | "today_hobby_details_name">

  export type today_hobbyOrderByWithAggregationInput = {
    today_hobby_id?: SortOrder
    hobby_category_id?: SortOrderInput | SortOrder
    today_theme_code?: SortOrderInput | SortOrder
    today_theme_name?: SortOrder
    today_hobby_details_name?: SortOrder
    today_hobby_details_description?: SortOrder
    today_hobby_details_attributes?: SortOrder
    today_hobby_thumbnail?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: today_hobbyCountOrderByAggregateInput
    _avg?: today_hobbyAvgOrderByAggregateInput
    _max?: today_hobbyMaxOrderByAggregateInput
    _min?: today_hobbyMinOrderByAggregateInput
    _sum?: today_hobbySumOrderByAggregateInput
  }

  export type today_hobbyScalarWhereWithAggregatesInput = {
    AND?: today_hobbyScalarWhereWithAggregatesInput | today_hobbyScalarWhereWithAggregatesInput[]
    OR?: today_hobbyScalarWhereWithAggregatesInput[]
    NOT?: today_hobbyScalarWhereWithAggregatesInput | today_hobbyScalarWhereWithAggregatesInput[]
    today_hobby_id?: BigIntWithAggregatesFilter<"today_hobby"> | bigint | number
    hobby_category_id?: BigIntNullableWithAggregatesFilter<"today_hobby"> | bigint | number | null
    today_theme_code?: BigIntNullableWithAggregatesFilter<"today_hobby"> | bigint | number | null
    today_theme_name?: StringWithAggregatesFilter<"today_hobby"> | string
    today_hobby_details_name?: StringWithAggregatesFilter<"today_hobby"> | string
    today_hobby_details_description?: StringWithAggregatesFilter<"today_hobby"> | string
    today_hobby_details_attributes?: StringWithAggregatesFilter<"today_hobby"> | string
    today_hobby_thumbnail?: StringWithAggregatesFilter<"today_hobby"> | string
    created_at?: DateTimeWithAggregatesFilter<"today_hobby"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"today_hobby"> | Date | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    user_id?: BigIntFilter<"user"> | bigint | number
    user_email?: StringNullableFilter<"user"> | string | null
    user_profile?: StringNullableFilter<"user"> | string | null
    user_password?: StringNullableFilter<"user"> | string | null
    user_type?: Enumuser_user_typeFilter<"user"> | $Enums.user_user_type
    user_nickname?: StringNullableFilter<"user"> | string | null
    provider_type?: Enumuser_provider_typeFilter<"user"> | $Enums.user_provider_type
    provider_key?: StringNullableFilter<"user"> | string | null
    created_at?: DateTimeFilter<"user"> | Date | string
    modified_at?: DateTimeFilter<"user"> | Date | string
    user_last_login_date?: DateTimeFilter<"user"> | Date | string
    deleted?: BoolFilter<"user"> | boolean
    dormancy?: BoolFilter<"user"> | boolean
    refresh_token?: StringNullableFilter<"user"> | string | null
    profile_description?: StringNullableFilter<"user"> | string | null
  }

  export type userOrderByWithRelationInput = {
    user_id?: SortOrder
    user_email?: SortOrderInput | SortOrder
    user_profile?: SortOrderInput | SortOrder
    user_password?: SortOrderInput | SortOrder
    user_type?: SortOrder
    user_nickname?: SortOrderInput | SortOrder
    provider_type?: SortOrder
    provider_key?: SortOrderInput | SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    user_last_login_date?: SortOrder
    deleted?: SortOrder
    dormancy?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    profile_description?: SortOrderInput | SortOrder
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    user_id?: bigint | number
    user_email?: string
    user_nickname?: string
    provider_key?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    user_profile?: StringNullableFilter<"user"> | string | null
    user_password?: StringNullableFilter<"user"> | string | null
    user_type?: Enumuser_user_typeFilter<"user"> | $Enums.user_user_type
    provider_type?: Enumuser_provider_typeFilter<"user"> | $Enums.user_provider_type
    created_at?: DateTimeFilter<"user"> | Date | string
    modified_at?: DateTimeFilter<"user"> | Date | string
    user_last_login_date?: DateTimeFilter<"user"> | Date | string
    deleted?: BoolFilter<"user"> | boolean
    dormancy?: BoolFilter<"user"> | boolean
    refresh_token?: StringNullableFilter<"user"> | string | null
    profile_description?: StringNullableFilter<"user"> | string | null
  }, "user_id" | "user_email" | "user_nickname" | "provider_key">

  export type userOrderByWithAggregationInput = {
    user_id?: SortOrder
    user_email?: SortOrderInput | SortOrder
    user_profile?: SortOrderInput | SortOrder
    user_password?: SortOrderInput | SortOrder
    user_type?: SortOrder
    user_nickname?: SortOrderInput | SortOrder
    provider_type?: SortOrder
    provider_key?: SortOrderInput | SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    user_last_login_date?: SortOrder
    deleted?: SortOrder
    dormancy?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    profile_description?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"user"> | bigint | number
    user_email?: StringNullableWithAggregatesFilter<"user"> | string | null
    user_profile?: StringNullableWithAggregatesFilter<"user"> | string | null
    user_password?: StringNullableWithAggregatesFilter<"user"> | string | null
    user_type?: Enumuser_user_typeWithAggregatesFilter<"user"> | $Enums.user_user_type
    user_nickname?: StringNullableWithAggregatesFilter<"user"> | string | null
    provider_type?: Enumuser_provider_typeWithAggregatesFilter<"user"> | $Enums.user_provider_type
    provider_key?: StringNullableWithAggregatesFilter<"user"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    user_last_login_date?: DateTimeWithAggregatesFilter<"user"> | Date | string
    deleted?: BoolWithAggregatesFilter<"user"> | boolean
    dormancy?: BoolWithAggregatesFilter<"user"> | boolean
    refresh_token?: StringNullableWithAggregatesFilter<"user"> | string | null
    profile_description?: StringNullableWithAggregatesFilter<"user"> | string | null
  }

  export type user_metricsWhereInput = {
    AND?: user_metricsWhereInput | user_metricsWhereInput[]
    OR?: user_metricsWhereInput[]
    NOT?: user_metricsWhereInput | user_metricsWhereInput[]
    id?: BigIntFilter<"user_metrics"> | bigint | number
    new_users?: BigIntFilter<"user_metrics"> | bigint | number
    total_users?: BigIntFilter<"user_metrics"> | bigint | number
    created_at?: DateTimeFilter<"user_metrics"> | Date | string
    modified_at?: DateTimeFilter<"user_metrics"> | Date | string
  }

  export type user_metricsOrderByWithRelationInput = {
    id?: SortOrder
    new_users?: SortOrder
    total_users?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type user_metricsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: user_metricsWhereInput | user_metricsWhereInput[]
    OR?: user_metricsWhereInput[]
    NOT?: user_metricsWhereInput | user_metricsWhereInput[]
    new_users?: BigIntFilter<"user_metrics"> | bigint | number
    total_users?: BigIntFilter<"user_metrics"> | bigint | number
    created_at?: DateTimeFilter<"user_metrics"> | Date | string
    modified_at?: DateTimeFilter<"user_metrics"> | Date | string
  }, "id">

  export type user_metricsOrderByWithAggregationInput = {
    id?: SortOrder
    new_users?: SortOrder
    total_users?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    _count?: user_metricsCountOrderByAggregateInput
    _avg?: user_metricsAvgOrderByAggregateInput
    _max?: user_metricsMaxOrderByAggregateInput
    _min?: user_metricsMinOrderByAggregateInput
    _sum?: user_metricsSumOrderByAggregateInput
  }

  export type user_metricsScalarWhereWithAggregatesInput = {
    AND?: user_metricsScalarWhereWithAggregatesInput | user_metricsScalarWhereWithAggregatesInput[]
    OR?: user_metricsScalarWhereWithAggregatesInput[]
    NOT?: user_metricsScalarWhereWithAggregatesInput | user_metricsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"user_metrics"> | bigint | number
    new_users?: BigIntWithAggregatesFilter<"user_metrics"> | bigint | number
    total_users?: BigIntWithAggregatesFilter<"user_metrics"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"user_metrics"> | Date | string
    modified_at?: DateTimeWithAggregatesFilter<"user_metrics"> | Date | string
  }

  export type QRTZ_BLOB_TRIGGERSCreateInput = {
    BLOB_DATA?: Uint8Array | null
    QRTZ_TRIGGERS: QRTZ_TRIGGERSCreateNestedOneWithoutQRTZ_BLOB_TRIGGERSInput
  }

  export type QRTZ_BLOB_TRIGGERSUncheckedCreateInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    BLOB_DATA?: Uint8Array | null
  }

  export type QRTZ_BLOB_TRIGGERSUpdateInput = {
    BLOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSUpdateOneRequiredWithoutQRTZ_BLOB_TRIGGERSNestedInput
  }

  export type QRTZ_BLOB_TRIGGERSUncheckedUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    BLOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type QRTZ_BLOB_TRIGGERSCreateManyInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    BLOB_DATA?: Uint8Array | null
  }

  export type QRTZ_BLOB_TRIGGERSUpdateManyMutationInput = {
    BLOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type QRTZ_BLOB_TRIGGERSUncheckedUpdateManyInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    BLOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type QRTZ_CALENDARSCreateInput = {
    SCHED_NAME: string
    CALENDAR_NAME: string
    CALENDAR: Uint8Array
  }

  export type QRTZ_CALENDARSUncheckedCreateInput = {
    SCHED_NAME: string
    CALENDAR_NAME: string
    CALENDAR: Uint8Array
  }

  export type QRTZ_CALENDARSUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    CALENDAR_NAME?: StringFieldUpdateOperationsInput | string
    CALENDAR?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type QRTZ_CALENDARSUncheckedUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    CALENDAR_NAME?: StringFieldUpdateOperationsInput | string
    CALENDAR?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type QRTZ_CALENDARSCreateManyInput = {
    SCHED_NAME: string
    CALENDAR_NAME: string
    CALENDAR: Uint8Array
  }

  export type QRTZ_CALENDARSUpdateManyMutationInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    CALENDAR_NAME?: StringFieldUpdateOperationsInput | string
    CALENDAR?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type QRTZ_CALENDARSUncheckedUpdateManyInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    CALENDAR_NAME?: StringFieldUpdateOperationsInput | string
    CALENDAR?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type QRTZ_CRON_TRIGGERSCreateInput = {
    CRON_EXPRESSION: string
    TIME_ZONE_ID?: string | null
    QRTZ_TRIGGERS: QRTZ_TRIGGERSCreateNestedOneWithoutQRTZ_CRON_TRIGGERSInput
  }

  export type QRTZ_CRON_TRIGGERSUncheckedCreateInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    CRON_EXPRESSION: string
    TIME_ZONE_ID?: string | null
  }

  export type QRTZ_CRON_TRIGGERSUpdateInput = {
    CRON_EXPRESSION?: StringFieldUpdateOperationsInput | string
    TIME_ZONE_ID?: NullableStringFieldUpdateOperationsInput | string | null
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSUpdateOneRequiredWithoutQRTZ_CRON_TRIGGERSNestedInput
  }

  export type QRTZ_CRON_TRIGGERSUncheckedUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    CRON_EXPRESSION?: StringFieldUpdateOperationsInput | string
    TIME_ZONE_ID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_CRON_TRIGGERSCreateManyInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    CRON_EXPRESSION: string
    TIME_ZONE_ID?: string | null
  }

  export type QRTZ_CRON_TRIGGERSUpdateManyMutationInput = {
    CRON_EXPRESSION?: StringFieldUpdateOperationsInput | string
    TIME_ZONE_ID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_CRON_TRIGGERSUncheckedUpdateManyInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    CRON_EXPRESSION?: StringFieldUpdateOperationsInput | string
    TIME_ZONE_ID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_FIRED_TRIGGERSCreateInput = {
    SCHED_NAME: string
    ENTRY_ID: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    INSTANCE_NAME: string
    FIRED_TIME: bigint | number
    SCHED_TIME: bigint | number
    PRIORITY: number
    STATE: string
    JOB_NAME?: string | null
    JOB_GROUP?: string | null
    IS_NONCONCURRENT?: string | null
    REQUESTS_RECOVERY?: string | null
  }

  export type QRTZ_FIRED_TRIGGERSUncheckedCreateInput = {
    SCHED_NAME: string
    ENTRY_ID: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    INSTANCE_NAME: string
    FIRED_TIME: bigint | number
    SCHED_TIME: bigint | number
    PRIORITY: number
    STATE: string
    JOB_NAME?: string | null
    JOB_GROUP?: string | null
    IS_NONCONCURRENT?: string | null
    REQUESTS_RECOVERY?: string | null
  }

  export type QRTZ_FIRED_TRIGGERSUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    ENTRY_ID?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    INSTANCE_NAME?: StringFieldUpdateOperationsInput | string
    FIRED_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    SCHED_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    PRIORITY?: IntFieldUpdateOperationsInput | number
    STATE?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    JOB_GROUP?: NullableStringFieldUpdateOperationsInput | string | null
    IS_NONCONCURRENT?: NullableStringFieldUpdateOperationsInput | string | null
    REQUESTS_RECOVERY?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_FIRED_TRIGGERSUncheckedUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    ENTRY_ID?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    INSTANCE_NAME?: StringFieldUpdateOperationsInput | string
    FIRED_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    SCHED_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    PRIORITY?: IntFieldUpdateOperationsInput | number
    STATE?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    JOB_GROUP?: NullableStringFieldUpdateOperationsInput | string | null
    IS_NONCONCURRENT?: NullableStringFieldUpdateOperationsInput | string | null
    REQUESTS_RECOVERY?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_FIRED_TRIGGERSCreateManyInput = {
    SCHED_NAME: string
    ENTRY_ID: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    INSTANCE_NAME: string
    FIRED_TIME: bigint | number
    SCHED_TIME: bigint | number
    PRIORITY: number
    STATE: string
    JOB_NAME?: string | null
    JOB_GROUP?: string | null
    IS_NONCONCURRENT?: string | null
    REQUESTS_RECOVERY?: string | null
  }

  export type QRTZ_FIRED_TRIGGERSUpdateManyMutationInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    ENTRY_ID?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    INSTANCE_NAME?: StringFieldUpdateOperationsInput | string
    FIRED_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    SCHED_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    PRIORITY?: IntFieldUpdateOperationsInput | number
    STATE?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    JOB_GROUP?: NullableStringFieldUpdateOperationsInput | string | null
    IS_NONCONCURRENT?: NullableStringFieldUpdateOperationsInput | string | null
    REQUESTS_RECOVERY?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_FIRED_TRIGGERSUncheckedUpdateManyInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    ENTRY_ID?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    INSTANCE_NAME?: StringFieldUpdateOperationsInput | string
    FIRED_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    SCHED_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    PRIORITY?: IntFieldUpdateOperationsInput | number
    STATE?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    JOB_GROUP?: NullableStringFieldUpdateOperationsInput | string | null
    IS_NONCONCURRENT?: NullableStringFieldUpdateOperationsInput | string | null
    REQUESTS_RECOVERY?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_JOB_DETAILSCreateInput = {
    SCHED_NAME: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION?: string | null
    JOB_CLASS_NAME: string
    IS_DURABLE: string
    IS_NONCONCURRENT: string
    IS_UPDATE_DATA: string
    REQUESTS_RECOVERY: string
    JOB_DATA?: Uint8Array | null
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSCreateNestedManyWithoutQRTZ_JOB_DETAILSInput
  }

  export type QRTZ_JOB_DETAILSUncheckedCreateInput = {
    SCHED_NAME: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION?: string | null
    JOB_CLASS_NAME: string
    IS_DURABLE: string
    IS_NONCONCURRENT: string
    IS_UPDATE_DATA: string
    REQUESTS_RECOVERY: string
    JOB_DATA?: Uint8Array | null
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSUncheckedCreateNestedManyWithoutQRTZ_JOB_DETAILSInput
  }

  export type QRTZ_JOB_DETAILSUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: StringFieldUpdateOperationsInput | string
    JOB_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    JOB_CLASS_NAME?: StringFieldUpdateOperationsInput | string
    IS_DURABLE?: StringFieldUpdateOperationsInput | string
    IS_NONCONCURRENT?: StringFieldUpdateOperationsInput | string
    IS_UPDATE_DATA?: StringFieldUpdateOperationsInput | string
    REQUESTS_RECOVERY?: StringFieldUpdateOperationsInput | string
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSUpdateManyWithoutQRTZ_JOB_DETAILSNestedInput
  }

  export type QRTZ_JOB_DETAILSUncheckedUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: StringFieldUpdateOperationsInput | string
    JOB_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    JOB_CLASS_NAME?: StringFieldUpdateOperationsInput | string
    IS_DURABLE?: StringFieldUpdateOperationsInput | string
    IS_NONCONCURRENT?: StringFieldUpdateOperationsInput | string
    IS_UPDATE_DATA?: StringFieldUpdateOperationsInput | string
    REQUESTS_RECOVERY?: StringFieldUpdateOperationsInput | string
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSUncheckedUpdateManyWithoutQRTZ_JOB_DETAILSNestedInput
  }

  export type QRTZ_JOB_DETAILSCreateManyInput = {
    SCHED_NAME: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION?: string | null
    JOB_CLASS_NAME: string
    IS_DURABLE: string
    IS_NONCONCURRENT: string
    IS_UPDATE_DATA: string
    REQUESTS_RECOVERY: string
    JOB_DATA?: Uint8Array | null
  }

  export type QRTZ_JOB_DETAILSUpdateManyMutationInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: StringFieldUpdateOperationsInput | string
    JOB_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    JOB_CLASS_NAME?: StringFieldUpdateOperationsInput | string
    IS_DURABLE?: StringFieldUpdateOperationsInput | string
    IS_NONCONCURRENT?: StringFieldUpdateOperationsInput | string
    IS_UPDATE_DATA?: StringFieldUpdateOperationsInput | string
    REQUESTS_RECOVERY?: StringFieldUpdateOperationsInput | string
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type QRTZ_JOB_DETAILSUncheckedUpdateManyInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: StringFieldUpdateOperationsInput | string
    JOB_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    JOB_CLASS_NAME?: StringFieldUpdateOperationsInput | string
    IS_DURABLE?: StringFieldUpdateOperationsInput | string
    IS_NONCONCURRENT?: StringFieldUpdateOperationsInput | string
    IS_UPDATE_DATA?: StringFieldUpdateOperationsInput | string
    REQUESTS_RECOVERY?: StringFieldUpdateOperationsInput | string
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type QRTZ_LOCKSCreateInput = {
    SCHED_NAME: string
    LOCK_NAME: string
  }

  export type QRTZ_LOCKSUncheckedCreateInput = {
    SCHED_NAME: string
    LOCK_NAME: string
  }

  export type QRTZ_LOCKSUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    LOCK_NAME?: StringFieldUpdateOperationsInput | string
  }

  export type QRTZ_LOCKSUncheckedUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    LOCK_NAME?: StringFieldUpdateOperationsInput | string
  }

  export type QRTZ_LOCKSCreateManyInput = {
    SCHED_NAME: string
    LOCK_NAME: string
  }

  export type QRTZ_LOCKSUpdateManyMutationInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    LOCK_NAME?: StringFieldUpdateOperationsInput | string
  }

  export type QRTZ_LOCKSUncheckedUpdateManyInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    LOCK_NAME?: StringFieldUpdateOperationsInput | string
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSCreateInput = {
    SCHED_NAME: string
    TRIGGER_GROUP: string
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSUncheckedCreateInput = {
    SCHED_NAME: string
    TRIGGER_GROUP: string
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSUncheckedUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSCreateManyInput = {
    SCHED_NAME: string
    TRIGGER_GROUP: string
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSUpdateManyMutationInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSUncheckedUpdateManyInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
  }

  export type QRTZ_SCHEDULER_STATECreateInput = {
    SCHED_NAME: string
    INSTANCE_NAME: string
    LAST_CHECKIN_TIME: bigint | number
    CHECKIN_INTERVAL: bigint | number
  }

  export type QRTZ_SCHEDULER_STATEUncheckedCreateInput = {
    SCHED_NAME: string
    INSTANCE_NAME: string
    LAST_CHECKIN_TIME: bigint | number
    CHECKIN_INTERVAL: bigint | number
  }

  export type QRTZ_SCHEDULER_STATEUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    INSTANCE_NAME?: StringFieldUpdateOperationsInput | string
    LAST_CHECKIN_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    CHECKIN_INTERVAL?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type QRTZ_SCHEDULER_STATEUncheckedUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    INSTANCE_NAME?: StringFieldUpdateOperationsInput | string
    LAST_CHECKIN_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    CHECKIN_INTERVAL?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type QRTZ_SCHEDULER_STATECreateManyInput = {
    SCHED_NAME: string
    INSTANCE_NAME: string
    LAST_CHECKIN_TIME: bigint | number
    CHECKIN_INTERVAL: bigint | number
  }

  export type QRTZ_SCHEDULER_STATEUpdateManyMutationInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    INSTANCE_NAME?: StringFieldUpdateOperationsInput | string
    LAST_CHECKIN_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    CHECKIN_INTERVAL?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type QRTZ_SCHEDULER_STATEUncheckedUpdateManyInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    INSTANCE_NAME?: StringFieldUpdateOperationsInput | string
    LAST_CHECKIN_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    CHECKIN_INTERVAL?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type QRTZ_SIMPLE_TRIGGERSCreateInput = {
    REPEAT_COUNT: bigint | number
    REPEAT_INTERVAL: bigint | number
    TIMES_TRIGGERED: bigint | number
    QRTZ_TRIGGERS: QRTZ_TRIGGERSCreateNestedOneWithoutQRTZ_SIMPLE_TRIGGERSInput
  }

  export type QRTZ_SIMPLE_TRIGGERSUncheckedCreateInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    REPEAT_COUNT: bigint | number
    REPEAT_INTERVAL: bigint | number
    TIMES_TRIGGERED: bigint | number
  }

  export type QRTZ_SIMPLE_TRIGGERSUpdateInput = {
    REPEAT_COUNT?: BigIntFieldUpdateOperationsInput | bigint | number
    REPEAT_INTERVAL?: BigIntFieldUpdateOperationsInput | bigint | number
    TIMES_TRIGGERED?: BigIntFieldUpdateOperationsInput | bigint | number
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSUpdateOneRequiredWithoutQRTZ_SIMPLE_TRIGGERSNestedInput
  }

  export type QRTZ_SIMPLE_TRIGGERSUncheckedUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    REPEAT_COUNT?: BigIntFieldUpdateOperationsInput | bigint | number
    REPEAT_INTERVAL?: BigIntFieldUpdateOperationsInput | bigint | number
    TIMES_TRIGGERED?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type QRTZ_SIMPLE_TRIGGERSCreateManyInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    REPEAT_COUNT: bigint | number
    REPEAT_INTERVAL: bigint | number
    TIMES_TRIGGERED: bigint | number
  }

  export type QRTZ_SIMPLE_TRIGGERSUpdateManyMutationInput = {
    REPEAT_COUNT?: BigIntFieldUpdateOperationsInput | bigint | number
    REPEAT_INTERVAL?: BigIntFieldUpdateOperationsInput | bigint | number
    TIMES_TRIGGERED?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type QRTZ_SIMPLE_TRIGGERSUncheckedUpdateManyInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    REPEAT_COUNT?: BigIntFieldUpdateOperationsInput | bigint | number
    REPEAT_INTERVAL?: BigIntFieldUpdateOperationsInput | bigint | number
    TIMES_TRIGGERED?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type QRTZ_SIMPROP_TRIGGERSCreateInput = {
    STR_PROP_1?: string | null
    STR_PROP_2?: string | null
    STR_PROP_3?: string | null
    INT_PROP_1?: number | null
    INT_PROP_2?: number | null
    LONG_PROP_1?: bigint | number | null
    LONG_PROP_2?: bigint | number | null
    DEC_PROP_1?: Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: string | null
    BOOL_PROP_2?: string | null
    QRTZ_TRIGGERS: QRTZ_TRIGGERSCreateNestedOneWithoutQRTZ_SIMPROP_TRIGGERSInput
  }

  export type QRTZ_SIMPROP_TRIGGERSUncheckedCreateInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    STR_PROP_1?: string | null
    STR_PROP_2?: string | null
    STR_PROP_3?: string | null
    INT_PROP_1?: number | null
    INT_PROP_2?: number | null
    LONG_PROP_1?: bigint | number | null
    LONG_PROP_2?: bigint | number | null
    DEC_PROP_1?: Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: string | null
    BOOL_PROP_2?: string | null
  }

  export type QRTZ_SIMPROP_TRIGGERSUpdateInput = {
    STR_PROP_1?: NullableStringFieldUpdateOperationsInput | string | null
    STR_PROP_2?: NullableStringFieldUpdateOperationsInput | string | null
    STR_PROP_3?: NullableStringFieldUpdateOperationsInput | string | null
    INT_PROP_1?: NullableIntFieldUpdateOperationsInput | number | null
    INT_PROP_2?: NullableIntFieldUpdateOperationsInput | number | null
    LONG_PROP_1?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    LONG_PROP_2?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    DEC_PROP_1?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: NullableStringFieldUpdateOperationsInput | string | null
    BOOL_PROP_2?: NullableStringFieldUpdateOperationsInput | string | null
    QRTZ_TRIGGERS?: QRTZ_TRIGGERSUpdateOneRequiredWithoutQRTZ_SIMPROP_TRIGGERSNestedInput
  }

  export type QRTZ_SIMPROP_TRIGGERSUncheckedUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    STR_PROP_1?: NullableStringFieldUpdateOperationsInput | string | null
    STR_PROP_2?: NullableStringFieldUpdateOperationsInput | string | null
    STR_PROP_3?: NullableStringFieldUpdateOperationsInput | string | null
    INT_PROP_1?: NullableIntFieldUpdateOperationsInput | number | null
    INT_PROP_2?: NullableIntFieldUpdateOperationsInput | number | null
    LONG_PROP_1?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    LONG_PROP_2?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    DEC_PROP_1?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: NullableStringFieldUpdateOperationsInput | string | null
    BOOL_PROP_2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_SIMPROP_TRIGGERSCreateManyInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    STR_PROP_1?: string | null
    STR_PROP_2?: string | null
    STR_PROP_3?: string | null
    INT_PROP_1?: number | null
    INT_PROP_2?: number | null
    LONG_PROP_1?: bigint | number | null
    LONG_PROP_2?: bigint | number | null
    DEC_PROP_1?: Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: string | null
    BOOL_PROP_2?: string | null
  }

  export type QRTZ_SIMPROP_TRIGGERSUpdateManyMutationInput = {
    STR_PROP_1?: NullableStringFieldUpdateOperationsInput | string | null
    STR_PROP_2?: NullableStringFieldUpdateOperationsInput | string | null
    STR_PROP_3?: NullableStringFieldUpdateOperationsInput | string | null
    INT_PROP_1?: NullableIntFieldUpdateOperationsInput | number | null
    INT_PROP_2?: NullableIntFieldUpdateOperationsInput | number | null
    LONG_PROP_1?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    LONG_PROP_2?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    DEC_PROP_1?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: NullableStringFieldUpdateOperationsInput | string | null
    BOOL_PROP_2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_SIMPROP_TRIGGERSUncheckedUpdateManyInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    STR_PROP_1?: NullableStringFieldUpdateOperationsInput | string | null
    STR_PROP_2?: NullableStringFieldUpdateOperationsInput | string | null
    STR_PROP_3?: NullableStringFieldUpdateOperationsInput | string | null
    INT_PROP_1?: NullableIntFieldUpdateOperationsInput | number | null
    INT_PROP_2?: NullableIntFieldUpdateOperationsInput | number | null
    LONG_PROP_1?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    LONG_PROP_2?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    DEC_PROP_1?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: NullableStringFieldUpdateOperationsInput | string | null
    BOOL_PROP_2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_TRIGGERSCreateInput = {
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_JOB_DETAILS: QRTZ_JOB_DETAILSCreateNestedOneWithoutQRTZ_TRIGGERSInput
  }

  export type QRTZ_TRIGGERSUncheckedCreateInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
  }

  export type QRTZ_TRIGGERSUpdateInput = {
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_JOB_DETAILS?: QRTZ_JOB_DETAILSUpdateOneRequiredWithoutQRTZ_TRIGGERSNestedInput
  }

  export type QRTZ_TRIGGERSUncheckedUpdateInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: StringFieldUpdateOperationsInput | string
    JOB_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
  }

  export type QRTZ_TRIGGERSCreateManyInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
  }

  export type QRTZ_TRIGGERSUpdateManyMutationInput = {
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type QRTZ_TRIGGERSUncheckedUpdateManyInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: StringFieldUpdateOperationsInput | string
    JOB_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type bagCreateInput = {
    bag_id?: bigint | number
  }

  export type bagUncheckedCreateInput = {
    bag_id?: bigint | number
  }

  export type bagUpdateInput = {
    bag_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type bagUncheckedUpdateInput = {
    bag_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type bagCreateManyInput = {
    bag_id?: bigint | number
  }

  export type bagUpdateManyMutationInput = {
    bag_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type bagUncheckedUpdateManyInput = {
    bag_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ban_wordCreateInput = {
    id?: bigint | number
    word: string
    created_at: Date | string
    modified_at: Date | string
  }

  export type ban_wordUncheckedCreateInput = {
    id?: bigint | number
    word: string
    created_at: Date | string
    modified_at: Date | string
  }

  export type ban_wordUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    word?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ban_wordUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    word?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ban_wordCreateManyInput = {
    id?: bigint | number
    word: string
    created_at: Date | string
    modified_at: Date | string
  }

  export type ban_wordUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    word?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ban_wordUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    word?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type flyway_schema_historyCreateInput = {
    installed_rank: number
    version?: string | null
    description: string
    type: string
    script: string
    checksum?: number | null
    installed_by: string
    installed_on?: Date | string
    execution_time: number
    success: boolean
  }

  export type flyway_schema_historyUncheckedCreateInput = {
    installed_rank: number
    version?: string | null
    description: string
    type: string
    script: string
    checksum?: number | null
    installed_by: string
    installed_on?: Date | string
    execution_time: number
    success: boolean
  }

  export type flyway_schema_historyUpdateInput = {
    installed_rank?: IntFieldUpdateOperationsInput | number
    version?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    script?: StringFieldUpdateOperationsInput | string
    checksum?: NullableIntFieldUpdateOperationsInput | number | null
    installed_by?: StringFieldUpdateOperationsInput | string
    installed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    execution_time?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type flyway_schema_historyUncheckedUpdateInput = {
    installed_rank?: IntFieldUpdateOperationsInput | number
    version?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    script?: StringFieldUpdateOperationsInput | string
    checksum?: NullableIntFieldUpdateOperationsInput | number | null
    installed_by?: StringFieldUpdateOperationsInput | string
    installed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    execution_time?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type flyway_schema_historyCreateManyInput = {
    installed_rank: number
    version?: string | null
    description: string
    type: string
    script: string
    checksum?: number | null
    installed_by: string
    installed_on?: Date | string
    execution_time: number
    success: boolean
  }

  export type flyway_schema_historyUpdateManyMutationInput = {
    installed_rank?: IntFieldUpdateOperationsInput | number
    version?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    script?: StringFieldUpdateOperationsInput | string
    checksum?: NullableIntFieldUpdateOperationsInput | number | null
    installed_by?: StringFieldUpdateOperationsInput | string
    installed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    execution_time?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type flyway_schema_historyUncheckedUpdateManyInput = {
    installed_rank?: IntFieldUpdateOperationsInput | number
    version?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    script?: StringFieldUpdateOperationsInput | string
    checksum?: NullableIntFieldUpdateOperationsInput | number | null
    installed_by?: StringFieldUpdateOperationsInput | string
    installed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    execution_time?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type followCreateInput = {
    follow_id?: bigint | number
    user_id: bigint | number
    target_user_id: bigint | number
    created_at: Date | string
    modified_at: Date | string
    deleted?: boolean
  }

  export type followUncheckedCreateInput = {
    follow_id?: bigint | number
    user_id: bigint | number
    target_user_id: bigint | number
    created_at: Date | string
    modified_at: Date | string
    deleted?: boolean
  }

  export type followUpdateInput = {
    follow_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    target_user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type followUncheckedUpdateInput = {
    follow_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    target_user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type followCreateManyInput = {
    follow_id?: bigint | number
    user_id: bigint | number
    target_user_id: bigint | number
    created_at: Date | string
    modified_at: Date | string
    deleted?: boolean
  }

  export type followUpdateManyMutationInput = {
    follow_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    target_user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type followUncheckedUpdateManyInput = {
    follow_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    target_user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type hashtagCreateInput = {
    hashtag_id?: bigint | number
    hashtag: string
    created_at?: Date | string
    modified_at: Date | string
  }

  export type hashtagUncheckedCreateInput = {
    hashtag_id?: bigint | number
    hashtag: string
    created_at?: Date | string
    modified_at: Date | string
  }

  export type hashtagUpdateInput = {
    hashtag_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hashtag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hashtagUncheckedUpdateInput = {
    hashtag_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hashtag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hashtagCreateManyInput = {
    hashtag_id?: bigint | number
    hashtag: string
    created_at?: Date | string
    modified_at: Date | string
  }

  export type hashtagUpdateManyMutationInput = {
    hashtag_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hashtag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hashtagUncheckedUpdateManyInput = {
    hashtag_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hashtag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hobbyCreateInput = {
    hobby_id?: bigint | number
    user_id: bigint | number
    hobby_category_id: bigint | number
    hobby_name: string
    hobby_group_id: bigint | number
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type hobbyUncheckedCreateInput = {
    hobby_id?: bigint | number
    user_id: bigint | number
    hobby_category_id: bigint | number
    hobby_name: string
    hobby_group_id: bigint | number
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type hobbyUpdateInput = {
    hobby_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_name?: StringFieldUpdateOperationsInput | string
    hobby_group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type hobbyUncheckedUpdateInput = {
    hobby_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_name?: StringFieldUpdateOperationsInput | string
    hobby_group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type hobbyCreateManyInput = {
    hobby_id?: bigint | number
    user_id: bigint | number
    hobby_category_id: bigint | number
    hobby_name: string
    hobby_group_id: bigint | number
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type hobbyUpdateManyMutationInput = {
    hobby_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_name?: StringFieldUpdateOperationsInput | string
    hobby_group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type hobbyUncheckedUpdateManyInput = {
    hobby_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_name?: StringFieldUpdateOperationsInput | string
    hobby_group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type hobby_categoryCreateInput = {
    hobby_category_id?: bigint | number
    hobby_category_name: $Enums.hobby_category_hobby_category_name
    hobby_category_thumbnail: string
    created_at: Date | string
    modified_at: Date | string
  }

  export type hobby_categoryUncheckedCreateInput = {
    hobby_category_id?: bigint | number
    hobby_category_name: $Enums.hobby_category_hobby_category_name
    hobby_category_thumbnail: string
    created_at: Date | string
    modified_at: Date | string
  }

  export type hobby_categoryUpdateInput = {
    hobby_category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_category_name?: Enumhobby_category_hobby_category_nameFieldUpdateOperationsInput | $Enums.hobby_category_hobby_category_name
    hobby_category_thumbnail?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hobby_categoryUncheckedUpdateInput = {
    hobby_category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_category_name?: Enumhobby_category_hobby_category_nameFieldUpdateOperationsInput | $Enums.hobby_category_hobby_category_name
    hobby_category_thumbnail?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hobby_categoryCreateManyInput = {
    hobby_category_id?: bigint | number
    hobby_category_name: $Enums.hobby_category_hobby_category_name
    hobby_category_thumbnail: string
    created_at: Date | string
    modified_at: Date | string
  }

  export type hobby_categoryUpdateManyMutationInput = {
    hobby_category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_category_name?: Enumhobby_category_hobby_category_nameFieldUpdateOperationsInput | $Enums.hobby_category_hobby_category_name
    hobby_category_thumbnail?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hobby_categoryUncheckedUpdateManyInput = {
    hobby_category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_category_name?: Enumhobby_category_hobby_category_nameFieldUpdateOperationsInput | $Enums.hobby_category_hobby_category_name
    hobby_category_thumbnail?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hobby_commentCreateInput = {
    comment_id?: bigint | number
    post_id: bigint | number
    comment: string
    created_at: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type hobby_commentUncheckedCreateInput = {
    comment_id?: bigint | number
    post_id: bigint | number
    comment: string
    created_at: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type hobby_commentUpdateInput = {
    comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_commentUncheckedUpdateInput = {
    comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_commentCreateManyInput = {
    comment_id?: bigint | number
    post_id: bigint | number
    comment: string
    created_at: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type hobby_commentUpdateManyMutationInput = {
    comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_commentUncheckedUpdateManyInput = {
    comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_groupCreateInput = {
    hobby_group_id?: bigint | number
    user_id: bigint | number
    hobby_group_title: string
    deleted?: boolean
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted_at?: Date | string | null
  }

  export type hobby_groupUncheckedCreateInput = {
    hobby_group_id?: bigint | number
    user_id: bigint | number
    hobby_group_title: string
    deleted?: boolean
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted_at?: Date | string | null
  }

  export type hobby_groupUpdateInput = {
    hobby_group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_group_title?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_groupUncheckedUpdateInput = {
    hobby_group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_group_title?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_groupCreateManyInput = {
    hobby_group_id?: bigint | number
    user_id: bigint | number
    hobby_group_title: string
    deleted?: boolean
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted_at?: Date | string | null
  }

  export type hobby_groupUpdateManyMutationInput = {
    hobby_group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_group_title?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_groupUncheckedUpdateManyInput = {
    hobby_group_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_group_title?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_likeCreateInput = {
    hobby_like_id?: bigint | number
    user_id: bigint | number
    hobby_post_id: bigint | number
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type hobby_likeUncheckedCreateInput = {
    hobby_like_id?: bigint | number
    user_id: bigint | number
    hobby_post_id: bigint | number
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type hobby_likeUpdateInput = {
    hobby_like_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type hobby_likeUncheckedUpdateInput = {
    hobby_like_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type hobby_likeCreateManyInput = {
    hobby_like_id?: bigint | number
    user_id: bigint | number
    hobby_post_id: bigint | number
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type hobby_likeUpdateManyMutationInput = {
    hobby_like_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type hobby_likeUncheckedUpdateManyInput = {
    hobby_like_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type hobby_photoCreateInput = {
    hobby_photo_id?: bigint | number
    hobby_post_id: bigint | number
    hobby_photo_path: string
    deleted?: boolean
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
  }

  export type hobby_photoUncheckedCreateInput = {
    hobby_photo_id?: bigint | number
    hobby_post_id: bigint | number
    hobby_photo_path: string
    deleted?: boolean
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
  }

  export type hobby_photoUpdateInput = {
    hobby_photo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_photo_path?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type hobby_photoUncheckedUpdateInput = {
    hobby_photo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_photo_path?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type hobby_photoCreateManyInput = {
    hobby_photo_id?: bigint | number
    hobby_post_id: bigint | number
    hobby_photo_path: string
    deleted?: boolean
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
  }

  export type hobby_photoUpdateManyMutationInput = {
    hobby_photo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_photo_path?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type hobby_photoUncheckedUpdateManyInput = {
    hobby_photo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_photo_path?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type hobby_postCreateInput = {
    hobby_post_id?: bigint | number
    user_id: bigint | number
    hobby_id: bigint | number
    hobby_post_content: string
    hobby_post_thumbnail: string
    deleted?: boolean
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted_at?: Date | string | null
  }

  export type hobby_postUncheckedCreateInput = {
    hobby_post_id?: bigint | number
    user_id: bigint | number
    hobby_id: bigint | number
    hobby_post_content: string
    hobby_post_thumbnail: string
    deleted?: boolean
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted_at?: Date | string | null
  }

  export type hobby_postUpdateInput = {
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_content?: StringFieldUpdateOperationsInput | string
    hobby_post_thumbnail?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_postUncheckedUpdateInput = {
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_content?: StringFieldUpdateOperationsInput | string
    hobby_post_thumbnail?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_postCreateManyInput = {
    hobby_post_id?: bigint | number
    user_id: bigint | number
    hobby_id: bigint | number
    hobby_post_content: string
    hobby_post_thumbnail: string
    deleted?: boolean
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted_at?: Date | string | null
  }

  export type hobby_postUpdateManyMutationInput = {
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_content?: StringFieldUpdateOperationsInput | string
    hobby_post_thumbnail?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_postUncheckedUpdateManyInput = {
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_content?: StringFieldUpdateOperationsInput | string
    hobby_post_thumbnail?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_sub_commentCreateInput = {
    sub_comment_id?: bigint | number
    comment_id: bigint | number
    post_id: bigint | number
    sub_comment: string
    created_at: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type hobby_sub_commentUncheckedCreateInput = {
    sub_comment_id?: bigint | number
    comment_id: bigint | number
    post_id: bigint | number
    sub_comment: string
    created_at: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type hobby_sub_commentUpdateInput = {
    sub_comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sub_comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_sub_commentUncheckedUpdateInput = {
    sub_comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sub_comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_sub_commentCreateManyInput = {
    sub_comment_id?: bigint | number
    comment_id: bigint | number
    post_id: bigint | number
    sub_comment: string
    created_at: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type hobby_sub_commentUpdateManyMutationInput = {
    sub_comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sub_comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_sub_commentUncheckedUpdateManyInput = {
    sub_comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    comment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    sub_comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hobby_top_tenCreateInput = {
    hobby_top_ten_id?: bigint | number
    hobby_post_id: bigint | number
    view_count: bigint | number
    category: $Enums.hobby_top_ten_category
    created_at: Date | string
  }

  export type hobby_top_tenUncheckedCreateInput = {
    hobby_top_ten_id?: bigint | number
    hobby_post_id: bigint | number
    view_count: bigint | number
    category: $Enums.hobby_top_ten_category
    created_at: Date | string
  }

  export type hobby_top_tenUpdateInput = {
    hobby_top_ten_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    view_count?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: Enumhobby_top_ten_categoryFieldUpdateOperationsInput | $Enums.hobby_top_ten_category
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hobby_top_tenUncheckedUpdateInput = {
    hobby_top_ten_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    view_count?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: Enumhobby_top_ten_categoryFieldUpdateOperationsInput | $Enums.hobby_top_ten_category
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hobby_top_tenCreateManyInput = {
    hobby_top_ten_id?: bigint | number
    hobby_post_id: bigint | number
    view_count: bigint | number
    category: $Enums.hobby_top_ten_category
    created_at: Date | string
  }

  export type hobby_top_tenUpdateManyMutationInput = {
    hobby_top_ten_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    view_count?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: Enumhobby_top_ten_categoryFieldUpdateOperationsInput | $Enums.hobby_top_ten_category
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hobby_top_tenUncheckedUpdateManyInput = {
    hobby_top_ten_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    view_count?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: Enumhobby_top_ten_categoryFieldUpdateOperationsInput | $Enums.hobby_top_ten_category
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hobby_view_historyCreateInput = {
    hobby_view_history_id?: bigint | number
    hobby_post_id: bigint | number
    user_id: bigint | number
    category: $Enums.hobby_view_history_category
    created_at: Date | string
    modified_at: Date | string
    created_by: bigint | number
    modified_by: bigint | number
    deleted?: boolean
  }

  export type hobby_view_historyUncheckedCreateInput = {
    hobby_view_history_id?: bigint | number
    hobby_post_id: bigint | number
    user_id: bigint | number
    category: $Enums.hobby_view_history_category
    created_at: Date | string
    modified_at: Date | string
    created_by: bigint | number
    modified_by: bigint | number
    deleted?: boolean
  }

  export type hobby_view_historyUpdateInput = {
    hobby_view_history_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: Enumhobby_view_history_categoryFieldUpdateOperationsInput | $Enums.hobby_view_history_category
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type hobby_view_historyUncheckedUpdateInput = {
    hobby_view_history_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: Enumhobby_view_history_categoryFieldUpdateOperationsInput | $Enums.hobby_view_history_category
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type hobby_view_historyCreateManyInput = {
    hobby_view_history_id?: bigint | number
    hobby_post_id: bigint | number
    user_id: bigint | number
    category: $Enums.hobby_view_history_category
    created_at: Date | string
    modified_at: Date | string
    created_by: bigint | number
    modified_by: bigint | number
    deleted?: boolean
  }

  export type hobby_view_historyUpdateManyMutationInput = {
    hobby_view_history_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: Enumhobby_view_history_categoryFieldUpdateOperationsInput | $Enums.hobby_view_history_category
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type hobby_view_historyUncheckedUpdateManyInput = {
    hobby_view_history_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: Enumhobby_view_history_categoryFieldUpdateOperationsInput | $Enums.hobby_view_history_category
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type itemCreateInput = {
    item_id?: bigint | number
    item_name?: string | null
    bag_id?: bigint | number | null
  }

  export type itemUncheckedCreateInput = {
    item_id?: bigint | number
    item_name?: string | null
    bag_id?: bigint | number | null
  }

  export type itemUpdateInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    bag_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type itemUncheckedUpdateInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    bag_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type itemCreateManyInput = {
    item_id?: bigint | number
    item_name?: string | null
    bag_id?: bigint | number | null
  }

  export type itemUpdateManyMutationInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    bag_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type itemUncheckedUpdateManyInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    bag_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type memberCreateInput = {
    studentId?: bigint | number
    studentName?: string | null
    studentEmail?: string | null
  }

  export type memberUncheckedCreateInput = {
    studentId?: bigint | number
    studentName?: string | null
    studentEmail?: string | null
  }

  export type memberUpdateInput = {
    studentId?: BigIntFieldUpdateOperationsInput | bigint | number
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    studentEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type memberUncheckedUpdateInput = {
    studentId?: BigIntFieldUpdateOperationsInput | bigint | number
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    studentEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type memberCreateManyInput = {
    studentId?: bigint | number
    studentName?: string | null
    studentEmail?: string | null
  }

  export type memberUpdateManyMutationInput = {
    studentId?: BigIntFieldUpdateOperationsInput | bigint | number
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    studentEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type memberUncheckedUpdateManyInput = {
    studentId?: BigIntFieldUpdateOperationsInput | bigint | number
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    studentEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type policy_agreeCreateInput = {
    policy_agree_id?: bigint | number
    policy_type: $Enums.policy_agree_policy_type
    policy_history_id: bigint | number
    user_id: bigint | number
    created_at: Date | string
    modified_at: Date | string
  }

  export type policy_agreeUncheckedCreateInput = {
    policy_agree_id?: bigint | number
    policy_type: $Enums.policy_agree_policy_type
    policy_history_id: bigint | number
    user_id: bigint | number
    created_at: Date | string
    modified_at: Date | string
  }

  export type policy_agreeUpdateInput = {
    policy_agree_id?: BigIntFieldUpdateOperationsInput | bigint | number
    policy_type?: Enumpolicy_agree_policy_typeFieldUpdateOperationsInput | $Enums.policy_agree_policy_type
    policy_history_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type policy_agreeUncheckedUpdateInput = {
    policy_agree_id?: BigIntFieldUpdateOperationsInput | bigint | number
    policy_type?: Enumpolicy_agree_policy_typeFieldUpdateOperationsInput | $Enums.policy_agree_policy_type
    policy_history_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type policy_agreeCreateManyInput = {
    policy_agree_id?: bigint | number
    policy_type: $Enums.policy_agree_policy_type
    policy_history_id: bigint | number
    user_id: bigint | number
    created_at: Date | string
    modified_at: Date | string
  }

  export type policy_agreeUpdateManyMutationInput = {
    policy_agree_id?: BigIntFieldUpdateOperationsInput | bigint | number
    policy_type?: Enumpolicy_agree_policy_typeFieldUpdateOperationsInput | $Enums.policy_agree_policy_type
    policy_history_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type policy_agreeUncheckedUpdateManyInput = {
    policy_agree_id?: BigIntFieldUpdateOperationsInput | bigint | number
    policy_type?: Enumpolicy_agree_policy_typeFieldUpdateOperationsInput | $Enums.policy_agree_policy_type
    policy_history_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type policy_historyCreateInput = {
    policy_history_id?: bigint | number
    policy_type: $Enums.policy_history_policy_type
    revision_date: Date | string
    pdf_file_path: string
    required?: boolean
    is_latest_revision?: boolean
    created_at: Date | string
    modified_at: Date | string
  }

  export type policy_historyUncheckedCreateInput = {
    policy_history_id?: bigint | number
    policy_type: $Enums.policy_history_policy_type
    revision_date: Date | string
    pdf_file_path: string
    required?: boolean
    is_latest_revision?: boolean
    created_at: Date | string
    modified_at: Date | string
  }

  export type policy_historyUpdateInput = {
    policy_history_id?: BigIntFieldUpdateOperationsInput | bigint | number
    policy_type?: Enumpolicy_history_policy_typeFieldUpdateOperationsInput | $Enums.policy_history_policy_type
    revision_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf_file_path?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    is_latest_revision?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type policy_historyUncheckedUpdateInput = {
    policy_history_id?: BigIntFieldUpdateOperationsInput | bigint | number
    policy_type?: Enumpolicy_history_policy_typeFieldUpdateOperationsInput | $Enums.policy_history_policy_type
    revision_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf_file_path?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    is_latest_revision?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type policy_historyCreateManyInput = {
    policy_history_id?: bigint | number
    policy_type: $Enums.policy_history_policy_type
    revision_date: Date | string
    pdf_file_path: string
    required?: boolean
    is_latest_revision?: boolean
    created_at: Date | string
    modified_at: Date | string
  }

  export type policy_historyUpdateManyMutationInput = {
    policy_history_id?: BigIntFieldUpdateOperationsInput | bigint | number
    policy_type?: Enumpolicy_history_policy_typeFieldUpdateOperationsInput | $Enums.policy_history_policy_type
    revision_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf_file_path?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    is_latest_revision?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type policy_historyUncheckedUpdateManyInput = {
    policy_history_id?: BigIntFieldUpdateOperationsInput | bigint | number
    policy_type?: Enumpolicy_history_policy_typeFieldUpdateOperationsInput | $Enums.policy_history_policy_type
    revision_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pdf_file_path?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    is_latest_revision?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type post_hashtagCreateInput = {
    post_hashtags_id?: bigint | number
    post_id: bigint | number
    hashtag_id: bigint | number
    created_at?: Date | string
    modified_at: Date | string
    deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type post_hashtagUncheckedCreateInput = {
    post_hashtags_id?: bigint | number
    post_id: bigint | number
    hashtag_id: bigint | number
    created_at?: Date | string
    modified_at: Date | string
    deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type post_hashtagUpdateInput = {
    post_hashtags_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hashtag_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type post_hashtagUncheckedUpdateInput = {
    post_hashtags_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hashtag_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type post_hashtagCreateManyInput = {
    post_hashtags_id?: bigint | number
    post_id: bigint | number
    hashtag_id: bigint | number
    created_at?: Date | string
    modified_at: Date | string
    deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type post_hashtagUpdateManyMutationInput = {
    post_hashtags_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hashtag_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type post_hashtagUncheckedUpdateManyInput = {
    post_hashtags_id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hashtag_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type recommended_feedCreateInput = {
    recommended_feed_id?: bigint | number
    hobby_post_id: bigint | number
    recommended_type?: $Enums.recommended_feed_recommended_type | null
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type recommended_feedUncheckedCreateInput = {
    recommended_feed_id?: bigint | number
    hobby_post_id: bigint | number
    recommended_type?: $Enums.recommended_feed_recommended_type | null
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type recommended_feedUpdateInput = {
    recommended_feed_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recommended_type?: NullableEnumrecommended_feed_recommended_typeFieldUpdateOperationsInput | $Enums.recommended_feed_recommended_type | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recommended_feedUncheckedUpdateInput = {
    recommended_feed_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recommended_type?: NullableEnumrecommended_feed_recommended_typeFieldUpdateOperationsInput | $Enums.recommended_feed_recommended_type | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recommended_feedCreateManyInput = {
    recommended_feed_id?: bigint | number
    hobby_post_id: bigint | number
    recommended_type?: $Enums.recommended_feed_recommended_type | null
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type recommended_feedUpdateManyMutationInput = {
    recommended_feed_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recommended_type?: NullableEnumrecommended_feed_recommended_typeFieldUpdateOperationsInput | $Enums.recommended_feed_recommended_type | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recommended_feedUncheckedUpdateManyInput = {
    recommended_feed_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recommended_type?: NullableEnumrecommended_feed_recommended_typeFieldUpdateOperationsInput | $Enums.recommended_feed_recommended_type | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type reportCreateInput = {
    report_id?: bigint | number
    user_id: bigint | number
    hobby_post_id?: bigint | number | null
    comment_id?: bigint | number | null
    sub_comment_id?: bigint | number | null
    report_content: string
    report_status: $Enums.report_report_status
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type reportUncheckedCreateInput = {
    report_id?: bigint | number
    user_id: bigint | number
    hobby_post_id?: bigint | number | null
    comment_id?: bigint | number | null
    sub_comment_id?: bigint | number | null
    report_content: string
    report_status: $Enums.report_report_status
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type reportUpdateInput = {
    report_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comment_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub_comment_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    report_content?: StringFieldUpdateOperationsInput | string
    report_status?: Enumreport_report_statusFieldUpdateOperationsInput | $Enums.report_report_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type reportUncheckedUpdateInput = {
    report_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comment_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub_comment_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    report_content?: StringFieldUpdateOperationsInput | string
    report_status?: Enumreport_report_statusFieldUpdateOperationsInput | $Enums.report_report_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type reportCreateManyInput = {
    report_id?: bigint | number
    user_id: bigint | number
    hobby_post_id?: bigint | number | null
    comment_id?: bigint | number | null
    sub_comment_id?: bigint | number | null
    report_content: string
    report_status: $Enums.report_report_status
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type reportUpdateManyMutationInput = {
    report_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comment_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub_comment_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    report_content?: StringFieldUpdateOperationsInput | string
    report_status?: Enumreport_report_statusFieldUpdateOperationsInput | $Enums.report_report_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type reportUncheckedUpdateManyInput = {
    report_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    comment_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub_comment_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    report_content?: StringFieldUpdateOperationsInput | string
    report_status?: Enumreport_report_statusFieldUpdateOperationsInput | $Enums.report_report_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type settingCreateInput = {
    setting_id?: bigint | number
    user_id: bigint | number
    notification?: boolean
    marketing?: boolean
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type settingUncheckedCreateInput = {
    setting_id?: bigint | number
    user_id: bigint | number
    notification?: boolean
    marketing?: boolean
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type settingUpdateInput = {
    setting_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    notification?: BoolFieldUpdateOperationsInput | boolean
    marketing?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type settingUncheckedUpdateInput = {
    setting_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    notification?: BoolFieldUpdateOperationsInput | boolean
    marketing?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type settingCreateManyInput = {
    setting_id?: bigint | number
    user_id: bigint | number
    notification?: boolean
    marketing?: boolean
    created_at?: Date | string
    created_by: bigint | number
    modified_at: Date | string
    modified_by: bigint | number
    deleted?: boolean
  }

  export type settingUpdateManyMutationInput = {
    setting_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    notification?: BoolFieldUpdateOperationsInput | boolean
    marketing?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type settingUncheckedUpdateManyInput = {
    setting_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    notification?: BoolFieldUpdateOperationsInput | boolean
    marketing?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: BigIntFieldUpdateOperationsInput | bigint | number
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_by?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type today_hobbyCreateInput = {
    today_hobby_id?: bigint | number
    hobby_category_id?: bigint | number | null
    today_theme_code?: bigint | number | null
    today_theme_name: string
    today_hobby_details_name: string
    today_hobby_details_description: string
    today_hobby_details_attributes: string
    today_hobby_thumbnail: string
    created_at?: Date | string
    modified_at: Date | string
  }

  export type today_hobbyUncheckedCreateInput = {
    today_hobby_id?: bigint | number
    hobby_category_id?: bigint | number | null
    today_theme_code?: bigint | number | null
    today_theme_name: string
    today_hobby_details_name: string
    today_hobby_details_description: string
    today_hobby_details_attributes: string
    today_hobby_thumbnail: string
    created_at?: Date | string
    modified_at: Date | string
  }

  export type today_hobbyUpdateInput = {
    today_hobby_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    today_theme_code?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    today_theme_name?: StringFieldUpdateOperationsInput | string
    today_hobby_details_name?: StringFieldUpdateOperationsInput | string
    today_hobby_details_description?: StringFieldUpdateOperationsInput | string
    today_hobby_details_attributes?: StringFieldUpdateOperationsInput | string
    today_hobby_thumbnail?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type today_hobbyUncheckedUpdateInput = {
    today_hobby_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    today_theme_code?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    today_theme_name?: StringFieldUpdateOperationsInput | string
    today_hobby_details_name?: StringFieldUpdateOperationsInput | string
    today_hobby_details_description?: StringFieldUpdateOperationsInput | string
    today_hobby_details_attributes?: StringFieldUpdateOperationsInput | string
    today_hobby_thumbnail?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type today_hobbyCreateManyInput = {
    today_hobby_id?: bigint | number
    hobby_category_id?: bigint | number | null
    today_theme_code?: bigint | number | null
    today_theme_name: string
    today_hobby_details_name: string
    today_hobby_details_description: string
    today_hobby_details_attributes: string
    today_hobby_thumbnail: string
    created_at?: Date | string
    modified_at: Date | string
  }

  export type today_hobbyUpdateManyMutationInput = {
    today_hobby_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    today_theme_code?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    today_theme_name?: StringFieldUpdateOperationsInput | string
    today_hobby_details_name?: StringFieldUpdateOperationsInput | string
    today_hobby_details_description?: StringFieldUpdateOperationsInput | string
    today_hobby_details_attributes?: StringFieldUpdateOperationsInput | string
    today_hobby_thumbnail?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type today_hobbyUncheckedUpdateManyInput = {
    today_hobby_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hobby_category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    today_theme_code?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    today_theme_name?: StringFieldUpdateOperationsInput | string
    today_hobby_details_name?: StringFieldUpdateOperationsInput | string
    today_hobby_details_description?: StringFieldUpdateOperationsInput | string
    today_hobby_details_attributes?: StringFieldUpdateOperationsInput | string
    today_hobby_thumbnail?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateInput = {
    user_id?: bigint | number
    user_email?: string | null
    user_profile?: string | null
    user_password?: string | null
    user_type?: $Enums.user_user_type
    user_nickname?: string | null
    provider_type: $Enums.user_provider_type
    provider_key?: string | null
    created_at: Date | string
    modified_at: Date | string
    user_last_login_date: Date | string
    deleted?: boolean
    dormancy?: boolean
    refresh_token?: string | null
    profile_description?: string | null
  }

  export type userUncheckedCreateInput = {
    user_id?: bigint | number
    user_email?: string | null
    user_profile?: string | null
    user_password?: string | null
    user_type?: $Enums.user_user_type
    user_nickname?: string | null
    provider_type: $Enums.user_provider_type
    provider_key?: string | null
    created_at: Date | string
    modified_at: Date | string
    user_last_login_date: Date | string
    deleted?: boolean
    dormancy?: boolean
    refresh_token?: string | null
    profile_description?: string | null
  }

  export type userUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_profile?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    user_type?: Enumuser_user_typeFieldUpdateOperationsInput | $Enums.user_user_type
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    provider_type?: Enumuser_provider_typeFieldUpdateOperationsInput | $Enums.user_provider_type
    provider_key?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_last_login_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    dormancy?: BoolFieldUpdateOperationsInput | boolean
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_profile?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    user_type?: Enumuser_user_typeFieldUpdateOperationsInput | $Enums.user_user_type
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    provider_type?: Enumuser_provider_typeFieldUpdateOperationsInput | $Enums.user_provider_type
    provider_key?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_last_login_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    dormancy?: BoolFieldUpdateOperationsInput | boolean
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userCreateManyInput = {
    user_id?: bigint | number
    user_email?: string | null
    user_profile?: string | null
    user_password?: string | null
    user_type?: $Enums.user_user_type
    user_nickname?: string | null
    provider_type: $Enums.user_provider_type
    provider_key?: string | null
    created_at: Date | string
    modified_at: Date | string
    user_last_login_date: Date | string
    deleted?: boolean
    dormancy?: boolean
    refresh_token?: string | null
    profile_description?: string | null
  }

  export type userUpdateManyMutationInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_profile?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    user_type?: Enumuser_user_typeFieldUpdateOperationsInput | $Enums.user_user_type
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    provider_type?: Enumuser_provider_typeFieldUpdateOperationsInput | $Enums.user_provider_type
    provider_key?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_last_login_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    dormancy?: BoolFieldUpdateOperationsInput | boolean
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_profile?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    user_type?: Enumuser_user_typeFieldUpdateOperationsInput | $Enums.user_user_type
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    provider_type?: Enumuser_provider_typeFieldUpdateOperationsInput | $Enums.user_provider_type
    provider_key?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_last_login_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    dormancy?: BoolFieldUpdateOperationsInput | boolean
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_metricsCreateInput = {
    id?: bigint | number
    new_users?: bigint | number
    total_users?: bigint | number
    created_at: Date | string
    modified_at: Date | string
  }

  export type user_metricsUncheckedCreateInput = {
    id?: bigint | number
    new_users?: bigint | number
    total_users?: bigint | number
    created_at: Date | string
    modified_at: Date | string
  }

  export type user_metricsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    new_users?: BigIntFieldUpdateOperationsInput | bigint | number
    total_users?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_metricsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    new_users?: BigIntFieldUpdateOperationsInput | bigint | number
    total_users?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_metricsCreateManyInput = {
    id?: bigint | number
    new_users?: bigint | number
    total_users?: bigint | number
    created_at: Date | string
    modified_at: Date | string
  }

  export type user_metricsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    new_users?: BigIntFieldUpdateOperationsInput | bigint | number
    total_users?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_metricsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    new_users?: BigIntFieldUpdateOperationsInput | bigint | number
    total_users?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type QRTZ_TRIGGERSScalarRelationFilter = {
    is?: QRTZ_TRIGGERSWhereInput
    isNot?: QRTZ_TRIGGERSWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type QRTZ_BLOB_TRIGGERSOrderByRelevanceInput = {
    fields: QRTZ_BLOB_TRIGGERSOrderByRelevanceFieldEnum | QRTZ_BLOB_TRIGGERSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QRTZ_BLOB_TRIGGERSSCHED_NAMETRIGGER_NAMETRIGGER_GROUPCompoundUniqueInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
  }

  export type QRTZ_BLOB_TRIGGERSCountOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    BLOB_DATA?: SortOrder
  }

  export type QRTZ_BLOB_TRIGGERSMaxOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    BLOB_DATA?: SortOrder
  }

  export type QRTZ_BLOB_TRIGGERSMinOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    BLOB_DATA?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type QRTZ_CALENDARSOrderByRelevanceInput = {
    fields: QRTZ_CALENDARSOrderByRelevanceFieldEnum | QRTZ_CALENDARSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QRTZ_CALENDARSSCHED_NAMECALENDAR_NAMECompoundUniqueInput = {
    SCHED_NAME: string
    CALENDAR_NAME: string
  }

  export type QRTZ_CALENDARSCountOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    CALENDAR_NAME?: SortOrder
    CALENDAR?: SortOrder
  }

  export type QRTZ_CALENDARSMaxOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    CALENDAR_NAME?: SortOrder
    CALENDAR?: SortOrder
  }

  export type QRTZ_CALENDARSMinOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    CALENDAR_NAME?: SortOrder
    CALENDAR?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type QRTZ_CRON_TRIGGERSOrderByRelevanceInput = {
    fields: QRTZ_CRON_TRIGGERSOrderByRelevanceFieldEnum | QRTZ_CRON_TRIGGERSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QRTZ_CRON_TRIGGERSSCHED_NAMETRIGGER_NAMETRIGGER_GROUPCompoundUniqueInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
  }

  export type QRTZ_CRON_TRIGGERSCountOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    CRON_EXPRESSION?: SortOrder
    TIME_ZONE_ID?: SortOrder
  }

  export type QRTZ_CRON_TRIGGERSMaxOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    CRON_EXPRESSION?: SortOrder
    TIME_ZONE_ID?: SortOrder
  }

  export type QRTZ_CRON_TRIGGERSMinOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    CRON_EXPRESSION?: SortOrder
    TIME_ZONE_ID?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type QRTZ_FIRED_TRIGGERSOrderByRelevanceInput = {
    fields: QRTZ_FIRED_TRIGGERSOrderByRelevanceFieldEnum | QRTZ_FIRED_TRIGGERSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QRTZ_FIRED_TRIGGERSSCHED_NAMEENTRY_IDCompoundUniqueInput = {
    SCHED_NAME: string
    ENTRY_ID: string
  }

  export type QRTZ_FIRED_TRIGGERSCountOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    ENTRY_ID?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    INSTANCE_NAME?: SortOrder
    FIRED_TIME?: SortOrder
    SCHED_TIME?: SortOrder
    PRIORITY?: SortOrder
    STATE?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    IS_NONCONCURRENT?: SortOrder
    REQUESTS_RECOVERY?: SortOrder
  }

  export type QRTZ_FIRED_TRIGGERSAvgOrderByAggregateInput = {
    FIRED_TIME?: SortOrder
    SCHED_TIME?: SortOrder
    PRIORITY?: SortOrder
  }

  export type QRTZ_FIRED_TRIGGERSMaxOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    ENTRY_ID?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    INSTANCE_NAME?: SortOrder
    FIRED_TIME?: SortOrder
    SCHED_TIME?: SortOrder
    PRIORITY?: SortOrder
    STATE?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    IS_NONCONCURRENT?: SortOrder
    REQUESTS_RECOVERY?: SortOrder
  }

  export type QRTZ_FIRED_TRIGGERSMinOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    ENTRY_ID?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    INSTANCE_NAME?: SortOrder
    FIRED_TIME?: SortOrder
    SCHED_TIME?: SortOrder
    PRIORITY?: SortOrder
    STATE?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    IS_NONCONCURRENT?: SortOrder
    REQUESTS_RECOVERY?: SortOrder
  }

  export type QRTZ_FIRED_TRIGGERSSumOrderByAggregateInput = {
    FIRED_TIME?: SortOrder
    SCHED_TIME?: SortOrder
    PRIORITY?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type QRTZ_TRIGGERSListRelationFilter = {
    every?: QRTZ_TRIGGERSWhereInput
    some?: QRTZ_TRIGGERSWhereInput
    none?: QRTZ_TRIGGERSWhereInput
  }

  export type QRTZ_TRIGGERSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QRTZ_JOB_DETAILSOrderByRelevanceInput = {
    fields: QRTZ_JOB_DETAILSOrderByRelevanceFieldEnum | QRTZ_JOB_DETAILSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QRTZ_JOB_DETAILSSCHED_NAMEJOB_NAMEJOB_GROUPCompoundUniqueInput = {
    SCHED_NAME: string
    JOB_NAME: string
    JOB_GROUP: string
  }

  export type QRTZ_JOB_DETAILSCountOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    DESCRIPTION?: SortOrder
    JOB_CLASS_NAME?: SortOrder
    IS_DURABLE?: SortOrder
    IS_NONCONCURRENT?: SortOrder
    IS_UPDATE_DATA?: SortOrder
    REQUESTS_RECOVERY?: SortOrder
    JOB_DATA?: SortOrder
  }

  export type QRTZ_JOB_DETAILSMaxOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    DESCRIPTION?: SortOrder
    JOB_CLASS_NAME?: SortOrder
    IS_DURABLE?: SortOrder
    IS_NONCONCURRENT?: SortOrder
    IS_UPDATE_DATA?: SortOrder
    REQUESTS_RECOVERY?: SortOrder
    JOB_DATA?: SortOrder
  }

  export type QRTZ_JOB_DETAILSMinOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    DESCRIPTION?: SortOrder
    JOB_CLASS_NAME?: SortOrder
    IS_DURABLE?: SortOrder
    IS_NONCONCURRENT?: SortOrder
    IS_UPDATE_DATA?: SortOrder
    REQUESTS_RECOVERY?: SortOrder
    JOB_DATA?: SortOrder
  }

  export type QRTZ_LOCKSOrderByRelevanceInput = {
    fields: QRTZ_LOCKSOrderByRelevanceFieldEnum | QRTZ_LOCKSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QRTZ_LOCKSSCHED_NAMELOCK_NAMECompoundUniqueInput = {
    SCHED_NAME: string
    LOCK_NAME: string
  }

  export type QRTZ_LOCKSCountOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    LOCK_NAME?: SortOrder
  }

  export type QRTZ_LOCKSMaxOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    LOCK_NAME?: SortOrder
  }

  export type QRTZ_LOCKSMinOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    LOCK_NAME?: SortOrder
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSOrderByRelevanceInput = {
    fields: QRTZ_PAUSED_TRIGGER_GRPSOrderByRelevanceFieldEnum | QRTZ_PAUSED_TRIGGER_GRPSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSSCHED_NAMETRIGGER_GROUPCompoundUniqueInput = {
    SCHED_NAME: string
    TRIGGER_GROUP: string
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSCountOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSMaxOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
  }

  export type QRTZ_PAUSED_TRIGGER_GRPSMinOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
  }

  export type QRTZ_SCHEDULER_STATEOrderByRelevanceInput = {
    fields: QRTZ_SCHEDULER_STATEOrderByRelevanceFieldEnum | QRTZ_SCHEDULER_STATEOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QRTZ_SCHEDULER_STATESCHED_NAMEINSTANCE_NAMECompoundUniqueInput = {
    SCHED_NAME: string
    INSTANCE_NAME: string
  }

  export type QRTZ_SCHEDULER_STATECountOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    INSTANCE_NAME?: SortOrder
    LAST_CHECKIN_TIME?: SortOrder
    CHECKIN_INTERVAL?: SortOrder
  }

  export type QRTZ_SCHEDULER_STATEAvgOrderByAggregateInput = {
    LAST_CHECKIN_TIME?: SortOrder
    CHECKIN_INTERVAL?: SortOrder
  }

  export type QRTZ_SCHEDULER_STATEMaxOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    INSTANCE_NAME?: SortOrder
    LAST_CHECKIN_TIME?: SortOrder
    CHECKIN_INTERVAL?: SortOrder
  }

  export type QRTZ_SCHEDULER_STATEMinOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    INSTANCE_NAME?: SortOrder
    LAST_CHECKIN_TIME?: SortOrder
    CHECKIN_INTERVAL?: SortOrder
  }

  export type QRTZ_SCHEDULER_STATESumOrderByAggregateInput = {
    LAST_CHECKIN_TIME?: SortOrder
    CHECKIN_INTERVAL?: SortOrder
  }

  export type QRTZ_SIMPLE_TRIGGERSOrderByRelevanceInput = {
    fields: QRTZ_SIMPLE_TRIGGERSOrderByRelevanceFieldEnum | QRTZ_SIMPLE_TRIGGERSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QRTZ_SIMPLE_TRIGGERSSCHED_NAMETRIGGER_NAMETRIGGER_GROUPCompoundUniqueInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
  }

  export type QRTZ_SIMPLE_TRIGGERSCountOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    REPEAT_COUNT?: SortOrder
    REPEAT_INTERVAL?: SortOrder
    TIMES_TRIGGERED?: SortOrder
  }

  export type QRTZ_SIMPLE_TRIGGERSAvgOrderByAggregateInput = {
    REPEAT_COUNT?: SortOrder
    REPEAT_INTERVAL?: SortOrder
    TIMES_TRIGGERED?: SortOrder
  }

  export type QRTZ_SIMPLE_TRIGGERSMaxOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    REPEAT_COUNT?: SortOrder
    REPEAT_INTERVAL?: SortOrder
    TIMES_TRIGGERED?: SortOrder
  }

  export type QRTZ_SIMPLE_TRIGGERSMinOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    REPEAT_COUNT?: SortOrder
    REPEAT_INTERVAL?: SortOrder
    TIMES_TRIGGERED?: SortOrder
  }

  export type QRTZ_SIMPLE_TRIGGERSSumOrderByAggregateInput = {
    REPEAT_COUNT?: SortOrder
    REPEAT_INTERVAL?: SortOrder
    TIMES_TRIGGERED?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type QRTZ_SIMPROP_TRIGGERSOrderByRelevanceInput = {
    fields: QRTZ_SIMPROP_TRIGGERSOrderByRelevanceFieldEnum | QRTZ_SIMPROP_TRIGGERSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QRTZ_SIMPROP_TRIGGERSSCHED_NAMETRIGGER_NAMETRIGGER_GROUPCompoundUniqueInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
  }

  export type QRTZ_SIMPROP_TRIGGERSCountOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    STR_PROP_1?: SortOrder
    STR_PROP_2?: SortOrder
    STR_PROP_3?: SortOrder
    INT_PROP_1?: SortOrder
    INT_PROP_2?: SortOrder
    LONG_PROP_1?: SortOrder
    LONG_PROP_2?: SortOrder
    DEC_PROP_1?: SortOrder
    DEC_PROP_2?: SortOrder
    BOOL_PROP_1?: SortOrder
    BOOL_PROP_2?: SortOrder
  }

  export type QRTZ_SIMPROP_TRIGGERSAvgOrderByAggregateInput = {
    INT_PROP_1?: SortOrder
    INT_PROP_2?: SortOrder
    LONG_PROP_1?: SortOrder
    LONG_PROP_2?: SortOrder
    DEC_PROP_1?: SortOrder
    DEC_PROP_2?: SortOrder
  }

  export type QRTZ_SIMPROP_TRIGGERSMaxOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    STR_PROP_1?: SortOrder
    STR_PROP_2?: SortOrder
    STR_PROP_3?: SortOrder
    INT_PROP_1?: SortOrder
    INT_PROP_2?: SortOrder
    LONG_PROP_1?: SortOrder
    LONG_PROP_2?: SortOrder
    DEC_PROP_1?: SortOrder
    DEC_PROP_2?: SortOrder
    BOOL_PROP_1?: SortOrder
    BOOL_PROP_2?: SortOrder
  }

  export type QRTZ_SIMPROP_TRIGGERSMinOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    STR_PROP_1?: SortOrder
    STR_PROP_2?: SortOrder
    STR_PROP_3?: SortOrder
    INT_PROP_1?: SortOrder
    INT_PROP_2?: SortOrder
    LONG_PROP_1?: SortOrder
    LONG_PROP_2?: SortOrder
    DEC_PROP_1?: SortOrder
    DEC_PROP_2?: SortOrder
    BOOL_PROP_1?: SortOrder
    BOOL_PROP_2?: SortOrder
  }

  export type QRTZ_SIMPROP_TRIGGERSSumOrderByAggregateInput = {
    INT_PROP_1?: SortOrder
    INT_PROP_2?: SortOrder
    LONG_PROP_1?: SortOrder
    LONG_PROP_2?: SortOrder
    DEC_PROP_1?: SortOrder
    DEC_PROP_2?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type QRTZ_BLOB_TRIGGERSNullableScalarRelationFilter = {
    is?: QRTZ_BLOB_TRIGGERSWhereInput | null
    isNot?: QRTZ_BLOB_TRIGGERSWhereInput | null
  }

  export type QRTZ_CRON_TRIGGERSNullableScalarRelationFilter = {
    is?: QRTZ_CRON_TRIGGERSWhereInput | null
    isNot?: QRTZ_CRON_TRIGGERSWhereInput | null
  }

  export type QRTZ_SIMPLE_TRIGGERSNullableScalarRelationFilter = {
    is?: QRTZ_SIMPLE_TRIGGERSWhereInput | null
    isNot?: QRTZ_SIMPLE_TRIGGERSWhereInput | null
  }

  export type QRTZ_SIMPROP_TRIGGERSNullableScalarRelationFilter = {
    is?: QRTZ_SIMPROP_TRIGGERSWhereInput | null
    isNot?: QRTZ_SIMPROP_TRIGGERSWhereInput | null
  }

  export type QRTZ_JOB_DETAILSScalarRelationFilter = {
    is?: QRTZ_JOB_DETAILSWhereInput
    isNot?: QRTZ_JOB_DETAILSWhereInput
  }

  export type QRTZ_TRIGGERSOrderByRelevanceInput = {
    fields: QRTZ_TRIGGERSOrderByRelevanceFieldEnum | QRTZ_TRIGGERSOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QRTZ_TRIGGERSSCHED_NAMETRIGGER_NAMETRIGGER_GROUPCompoundUniqueInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
  }

  export type QRTZ_TRIGGERSCountOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    DESCRIPTION?: SortOrder
    NEXT_FIRE_TIME?: SortOrder
    PREV_FIRE_TIME?: SortOrder
    PRIORITY?: SortOrder
    TRIGGER_STATE?: SortOrder
    TRIGGER_TYPE?: SortOrder
    START_TIME?: SortOrder
    END_TIME?: SortOrder
    CALENDAR_NAME?: SortOrder
    MISFIRE_INSTR?: SortOrder
    JOB_DATA?: SortOrder
  }

  export type QRTZ_TRIGGERSAvgOrderByAggregateInput = {
    NEXT_FIRE_TIME?: SortOrder
    PREV_FIRE_TIME?: SortOrder
    PRIORITY?: SortOrder
    START_TIME?: SortOrder
    END_TIME?: SortOrder
    MISFIRE_INSTR?: SortOrder
  }

  export type QRTZ_TRIGGERSMaxOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    DESCRIPTION?: SortOrder
    NEXT_FIRE_TIME?: SortOrder
    PREV_FIRE_TIME?: SortOrder
    PRIORITY?: SortOrder
    TRIGGER_STATE?: SortOrder
    TRIGGER_TYPE?: SortOrder
    START_TIME?: SortOrder
    END_TIME?: SortOrder
    CALENDAR_NAME?: SortOrder
    MISFIRE_INSTR?: SortOrder
    JOB_DATA?: SortOrder
  }

  export type QRTZ_TRIGGERSMinOrderByAggregateInput = {
    SCHED_NAME?: SortOrder
    TRIGGER_NAME?: SortOrder
    TRIGGER_GROUP?: SortOrder
    JOB_NAME?: SortOrder
    JOB_GROUP?: SortOrder
    DESCRIPTION?: SortOrder
    NEXT_FIRE_TIME?: SortOrder
    PREV_FIRE_TIME?: SortOrder
    PRIORITY?: SortOrder
    TRIGGER_STATE?: SortOrder
    TRIGGER_TYPE?: SortOrder
    START_TIME?: SortOrder
    END_TIME?: SortOrder
    CALENDAR_NAME?: SortOrder
    MISFIRE_INSTR?: SortOrder
    JOB_DATA?: SortOrder
  }

  export type QRTZ_TRIGGERSSumOrderByAggregateInput = {
    NEXT_FIRE_TIME?: SortOrder
    PREV_FIRE_TIME?: SortOrder
    PRIORITY?: SortOrder
    START_TIME?: SortOrder
    END_TIME?: SortOrder
    MISFIRE_INSTR?: SortOrder
  }

  export type bagCountOrderByAggregateInput = {
    bag_id?: SortOrder
  }

  export type bagAvgOrderByAggregateInput = {
    bag_id?: SortOrder
  }

  export type bagMaxOrderByAggregateInput = {
    bag_id?: SortOrder
  }

  export type bagMinOrderByAggregateInput = {
    bag_id?: SortOrder
  }

  export type bagSumOrderByAggregateInput = {
    bag_id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ban_wordOrderByRelevanceInput = {
    fields: ban_wordOrderByRelevanceFieldEnum | ban_wordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ban_wordCountOrderByAggregateInput = {
    id?: SortOrder
    word?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type ban_wordAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ban_wordMaxOrderByAggregateInput = {
    id?: SortOrder
    word?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type ban_wordMinOrderByAggregateInput = {
    id?: SortOrder
    word?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type ban_wordSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type flyway_schema_historyOrderByRelevanceInput = {
    fields: flyway_schema_historyOrderByRelevanceFieldEnum | flyway_schema_historyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type flyway_schema_historyCountOrderByAggregateInput = {
    installed_rank?: SortOrder
    version?: SortOrder
    description?: SortOrder
    type?: SortOrder
    script?: SortOrder
    checksum?: SortOrder
    installed_by?: SortOrder
    installed_on?: SortOrder
    execution_time?: SortOrder
    success?: SortOrder
  }

  export type flyway_schema_historyAvgOrderByAggregateInput = {
    installed_rank?: SortOrder
    checksum?: SortOrder
    execution_time?: SortOrder
  }

  export type flyway_schema_historyMaxOrderByAggregateInput = {
    installed_rank?: SortOrder
    version?: SortOrder
    description?: SortOrder
    type?: SortOrder
    script?: SortOrder
    checksum?: SortOrder
    installed_by?: SortOrder
    installed_on?: SortOrder
    execution_time?: SortOrder
    success?: SortOrder
  }

  export type flyway_schema_historyMinOrderByAggregateInput = {
    installed_rank?: SortOrder
    version?: SortOrder
    description?: SortOrder
    type?: SortOrder
    script?: SortOrder
    checksum?: SortOrder
    installed_by?: SortOrder
    installed_on?: SortOrder
    execution_time?: SortOrder
    success?: SortOrder
  }

  export type flyway_schema_historySumOrderByAggregateInput = {
    installed_rank?: SortOrder
    checksum?: SortOrder
    execution_time?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type followUser_idTarget_user_idCompoundUniqueInput = {
    user_id: bigint | number
    target_user_id: bigint | number
  }

  export type followCountOrderByAggregateInput = {
    follow_id?: SortOrder
    user_id?: SortOrder
    target_user_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    deleted?: SortOrder
  }

  export type followAvgOrderByAggregateInput = {
    follow_id?: SortOrder
    user_id?: SortOrder
    target_user_id?: SortOrder
  }

  export type followMaxOrderByAggregateInput = {
    follow_id?: SortOrder
    user_id?: SortOrder
    target_user_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    deleted?: SortOrder
  }

  export type followMinOrderByAggregateInput = {
    follow_id?: SortOrder
    user_id?: SortOrder
    target_user_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    deleted?: SortOrder
  }

  export type followSumOrderByAggregateInput = {
    follow_id?: SortOrder
    user_id?: SortOrder
    target_user_id?: SortOrder
  }

  export type hashtagOrderByRelevanceInput = {
    fields: hashtagOrderByRelevanceFieldEnum | hashtagOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type hashtagHashtag_idHashtagCompoundUniqueInput = {
    hashtag_id: bigint | number
    hashtag: string
  }

  export type hashtagCountOrderByAggregateInput = {
    hashtag_id?: SortOrder
    hashtag?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type hashtagAvgOrderByAggregateInput = {
    hashtag_id?: SortOrder
  }

  export type hashtagMaxOrderByAggregateInput = {
    hashtag_id?: SortOrder
    hashtag?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type hashtagMinOrderByAggregateInput = {
    hashtag_id?: SortOrder
    hashtag?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type hashtagSumOrderByAggregateInput = {
    hashtag_id?: SortOrder
  }

  export type hobbyOrderByRelevanceInput = {
    fields: hobbyOrderByRelevanceFieldEnum | hobbyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type hobbyCountOrderByAggregateInput = {
    hobby_id?: SortOrder
    user_id?: SortOrder
    hobby_category_id?: SortOrder
    hobby_name?: SortOrder
    hobby_group_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type hobbyAvgOrderByAggregateInput = {
    hobby_id?: SortOrder
    user_id?: SortOrder
    hobby_category_id?: SortOrder
    hobby_group_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type hobbyMaxOrderByAggregateInput = {
    hobby_id?: SortOrder
    user_id?: SortOrder
    hobby_category_id?: SortOrder
    hobby_name?: SortOrder
    hobby_group_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type hobbyMinOrderByAggregateInput = {
    hobby_id?: SortOrder
    user_id?: SortOrder
    hobby_category_id?: SortOrder
    hobby_name?: SortOrder
    hobby_group_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type hobbySumOrderByAggregateInput = {
    hobby_id?: SortOrder
    user_id?: SortOrder
    hobby_category_id?: SortOrder
    hobby_group_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type Enumhobby_category_hobby_category_nameFilter<$PrismaModel = never> = {
    equals?: $Enums.hobby_category_hobby_category_name | Enumhobby_category_hobby_category_nameFieldRefInput<$PrismaModel>
    in?: $Enums.hobby_category_hobby_category_name[]
    notIn?: $Enums.hobby_category_hobby_category_name[]
    not?: NestedEnumhobby_category_hobby_category_nameFilter<$PrismaModel> | $Enums.hobby_category_hobby_category_name
  }

  export type hobby_categoryOrderByRelevanceInput = {
    fields: hobby_categoryOrderByRelevanceFieldEnum | hobby_categoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type hobby_categoryCountOrderByAggregateInput = {
    hobby_category_id?: SortOrder
    hobby_category_name?: SortOrder
    hobby_category_thumbnail?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type hobby_categoryAvgOrderByAggregateInput = {
    hobby_category_id?: SortOrder
  }

  export type hobby_categoryMaxOrderByAggregateInput = {
    hobby_category_id?: SortOrder
    hobby_category_name?: SortOrder
    hobby_category_thumbnail?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type hobby_categoryMinOrderByAggregateInput = {
    hobby_category_id?: SortOrder
    hobby_category_name?: SortOrder
    hobby_category_thumbnail?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type hobby_categorySumOrderByAggregateInput = {
    hobby_category_id?: SortOrder
  }

  export type Enumhobby_category_hobby_category_nameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.hobby_category_hobby_category_name | Enumhobby_category_hobby_category_nameFieldRefInput<$PrismaModel>
    in?: $Enums.hobby_category_hobby_category_name[]
    notIn?: $Enums.hobby_category_hobby_category_name[]
    not?: NestedEnumhobby_category_hobby_category_nameWithAggregatesFilter<$PrismaModel> | $Enums.hobby_category_hobby_category_name
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumhobby_category_hobby_category_nameFilter<$PrismaModel>
    _max?: NestedEnumhobby_category_hobby_category_nameFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type hobby_commentOrderByRelevanceInput = {
    fields: hobby_commentOrderByRelevanceFieldEnum | hobby_commentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type hobby_commentCreated_byPost_idCompoundUniqueInput = {
    created_by: bigint | number
    post_id: bigint | number
  }

  export type hobby_commentCountOrderByAggregateInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type hobby_commentAvgOrderByAggregateInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_commentMaxOrderByAggregateInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type hobby_commentMinOrderByAggregateInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type hobby_commentSumOrderByAggregateInput = {
    comment_id?: SortOrder
    post_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type hobby_groupOrderByRelevanceInput = {
    fields: hobby_groupOrderByRelevanceFieldEnum | hobby_groupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type hobby_groupCreated_byUser_idHobby_group_titleCompoundUniqueInput = {
    created_by: bigint | number
    user_id: bigint | number
    hobby_group_title: string
  }

  export type hobby_groupCountOrderByAggregateInput = {
    hobby_group_id?: SortOrder
    user_id?: SortOrder
    hobby_group_title?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type hobby_groupAvgOrderByAggregateInput = {
    hobby_group_id?: SortOrder
    user_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_groupMaxOrderByAggregateInput = {
    hobby_group_id?: SortOrder
    user_id?: SortOrder
    hobby_group_title?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type hobby_groupMinOrderByAggregateInput = {
    hobby_group_id?: SortOrder
    user_id?: SortOrder
    hobby_group_title?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type hobby_groupSumOrderByAggregateInput = {
    hobby_group_id?: SortOrder
    user_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_likeUser_idHobby_post_idCompoundUniqueInput = {
    user_id: bigint | number
    hobby_post_id: bigint | number
  }

  export type hobby_likeCountOrderByAggregateInput = {
    hobby_like_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type hobby_likeAvgOrderByAggregateInput = {
    hobby_like_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_likeMaxOrderByAggregateInput = {
    hobby_like_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type hobby_likeMinOrderByAggregateInput = {
    hobby_like_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type hobby_likeSumOrderByAggregateInput = {
    hobby_like_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_photoOrderByRelevanceInput = {
    fields: hobby_photoOrderByRelevanceFieldEnum | hobby_photoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type hobby_photoCreated_byHobby_post_idHobby_photo_pathCompoundUniqueInput = {
    created_by: bigint | number
    hobby_post_id: bigint | number
    hobby_photo_path: string
  }

  export type hobby_photoCountOrderByAggregateInput = {
    hobby_photo_id?: SortOrder
    hobby_post_id?: SortOrder
    hobby_photo_path?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_photoAvgOrderByAggregateInput = {
    hobby_photo_id?: SortOrder
    hobby_post_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_photoMaxOrderByAggregateInput = {
    hobby_photo_id?: SortOrder
    hobby_post_id?: SortOrder
    hobby_photo_path?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_photoMinOrderByAggregateInput = {
    hobby_photo_id?: SortOrder
    hobby_post_id?: SortOrder
    hobby_photo_path?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_photoSumOrderByAggregateInput = {
    hobby_photo_id?: SortOrder
    hobby_post_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_postOrderByRelevanceInput = {
    fields: hobby_postOrderByRelevanceFieldEnum | hobby_postOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type hobby_postCreated_byUser_idHobby_idCompoundUniqueInput = {
    created_by: bigint | number
    user_id: bigint | number
    hobby_id: bigint | number
  }

  export type hobby_postCountOrderByAggregateInput = {
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    hobby_id?: SortOrder
    hobby_post_content?: SortOrder
    hobby_post_thumbnail?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type hobby_postAvgOrderByAggregateInput = {
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    hobby_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_postMaxOrderByAggregateInput = {
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    hobby_id?: SortOrder
    hobby_post_content?: SortOrder
    hobby_post_thumbnail?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type hobby_postMinOrderByAggregateInput = {
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    hobby_id?: SortOrder
    hobby_post_content?: SortOrder
    hobby_post_thumbnail?: SortOrder
    deleted?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type hobby_postSumOrderByAggregateInput = {
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    hobby_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_sub_commentOrderByRelevanceInput = {
    fields: hobby_sub_commentOrderByRelevanceFieldEnum | hobby_sub_commentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type hobby_sub_commentCreated_byComment_idPost_idCompoundUniqueInput = {
    created_by: bigint | number
    comment_id: bigint | number
    post_id: bigint | number
  }

  export type hobby_sub_commentCountOrderByAggregateInput = {
    sub_comment_id?: SortOrder
    comment_id?: SortOrder
    post_id?: SortOrder
    sub_comment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type hobby_sub_commentAvgOrderByAggregateInput = {
    sub_comment_id?: SortOrder
    comment_id?: SortOrder
    post_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_sub_commentMaxOrderByAggregateInput = {
    sub_comment_id?: SortOrder
    comment_id?: SortOrder
    post_id?: SortOrder
    sub_comment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type hobby_sub_commentMinOrderByAggregateInput = {
    sub_comment_id?: SortOrder
    comment_id?: SortOrder
    post_id?: SortOrder
    sub_comment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type hobby_sub_commentSumOrderByAggregateInput = {
    sub_comment_id?: SortOrder
    comment_id?: SortOrder
    post_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type Enumhobby_top_ten_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.hobby_top_ten_category | Enumhobby_top_ten_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.hobby_top_ten_category[]
    notIn?: $Enums.hobby_top_ten_category[]
    not?: NestedEnumhobby_top_ten_categoryFilter<$PrismaModel> | $Enums.hobby_top_ten_category
  }

  export type hobby_top_tenHobby_post_idView_countCreated_atCompoundUniqueInput = {
    hobby_post_id: bigint | number
    view_count: bigint | number
    created_at: Date | string
  }

  export type hobby_top_tenCountOrderByAggregateInput = {
    hobby_top_ten_id?: SortOrder
    hobby_post_id?: SortOrder
    view_count?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
  }

  export type hobby_top_tenAvgOrderByAggregateInput = {
    hobby_top_ten_id?: SortOrder
    hobby_post_id?: SortOrder
    view_count?: SortOrder
  }

  export type hobby_top_tenMaxOrderByAggregateInput = {
    hobby_top_ten_id?: SortOrder
    hobby_post_id?: SortOrder
    view_count?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
  }

  export type hobby_top_tenMinOrderByAggregateInput = {
    hobby_top_ten_id?: SortOrder
    hobby_post_id?: SortOrder
    view_count?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
  }

  export type hobby_top_tenSumOrderByAggregateInput = {
    hobby_top_ten_id?: SortOrder
    hobby_post_id?: SortOrder
    view_count?: SortOrder
  }

  export type Enumhobby_top_ten_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.hobby_top_ten_category | Enumhobby_top_ten_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.hobby_top_ten_category[]
    notIn?: $Enums.hobby_top_ten_category[]
    not?: NestedEnumhobby_top_ten_categoryWithAggregatesFilter<$PrismaModel> | $Enums.hobby_top_ten_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumhobby_top_ten_categoryFilter<$PrismaModel>
    _max?: NestedEnumhobby_top_ten_categoryFilter<$PrismaModel>
  }

  export type Enumhobby_view_history_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.hobby_view_history_category | Enumhobby_view_history_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.hobby_view_history_category[]
    notIn?: $Enums.hobby_view_history_category[]
    not?: NestedEnumhobby_view_history_categoryFilter<$PrismaModel> | $Enums.hobby_view_history_category
  }

  export type hobby_view_historyUser_idHobby_post_idCompoundUniqueInput = {
    user_id: bigint | number
    hobby_post_id: bigint | number
  }

  export type hobby_view_historyCountOrderByAggregateInput = {
    hobby_view_history_id?: SortOrder
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type hobby_view_historyAvgOrderByAggregateInput = {
    hobby_view_history_id?: SortOrder
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type hobby_view_historyMaxOrderByAggregateInput = {
    hobby_view_history_id?: SortOrder
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type hobby_view_historyMinOrderByAggregateInput = {
    hobby_view_history_id?: SortOrder
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type hobby_view_historySumOrderByAggregateInput = {
    hobby_view_history_id?: SortOrder
    hobby_post_id?: SortOrder
    user_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type Enumhobby_view_history_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.hobby_view_history_category | Enumhobby_view_history_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.hobby_view_history_category[]
    notIn?: $Enums.hobby_view_history_category[]
    not?: NestedEnumhobby_view_history_categoryWithAggregatesFilter<$PrismaModel> | $Enums.hobby_view_history_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumhobby_view_history_categoryFilter<$PrismaModel>
    _max?: NestedEnumhobby_view_history_categoryFilter<$PrismaModel>
  }

  export type itemOrderByRelevanceInput = {
    fields: itemOrderByRelevanceFieldEnum | itemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type itemCountOrderByAggregateInput = {
    item_id?: SortOrder
    item_name?: SortOrder
    bag_id?: SortOrder
  }

  export type itemAvgOrderByAggregateInput = {
    item_id?: SortOrder
    bag_id?: SortOrder
  }

  export type itemMaxOrderByAggregateInput = {
    item_id?: SortOrder
    item_name?: SortOrder
    bag_id?: SortOrder
  }

  export type itemMinOrderByAggregateInput = {
    item_id?: SortOrder
    item_name?: SortOrder
    bag_id?: SortOrder
  }

  export type itemSumOrderByAggregateInput = {
    item_id?: SortOrder
    bag_id?: SortOrder
  }

  export type memberOrderByRelevanceInput = {
    fields: memberOrderByRelevanceFieldEnum | memberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type memberCountOrderByAggregateInput = {
    studentId?: SortOrder
    studentName?: SortOrder
    studentEmail?: SortOrder
  }

  export type memberAvgOrderByAggregateInput = {
    studentId?: SortOrder
  }

  export type memberMaxOrderByAggregateInput = {
    studentId?: SortOrder
    studentName?: SortOrder
    studentEmail?: SortOrder
  }

  export type memberMinOrderByAggregateInput = {
    studentId?: SortOrder
    studentName?: SortOrder
    studentEmail?: SortOrder
  }

  export type memberSumOrderByAggregateInput = {
    studentId?: SortOrder
  }

  export type Enumpolicy_agree_policy_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.policy_agree_policy_type | Enumpolicy_agree_policy_typeFieldRefInput<$PrismaModel>
    in?: $Enums.policy_agree_policy_type[]
    notIn?: $Enums.policy_agree_policy_type[]
    not?: NestedEnumpolicy_agree_policy_typeFilter<$PrismaModel> | $Enums.policy_agree_policy_type
  }

  export type policy_agreeCountOrderByAggregateInput = {
    policy_agree_id?: SortOrder
    policy_type?: SortOrder
    policy_history_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type policy_agreeAvgOrderByAggregateInput = {
    policy_agree_id?: SortOrder
    policy_history_id?: SortOrder
    user_id?: SortOrder
  }

  export type policy_agreeMaxOrderByAggregateInput = {
    policy_agree_id?: SortOrder
    policy_type?: SortOrder
    policy_history_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type policy_agreeMinOrderByAggregateInput = {
    policy_agree_id?: SortOrder
    policy_type?: SortOrder
    policy_history_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type policy_agreeSumOrderByAggregateInput = {
    policy_agree_id?: SortOrder
    policy_history_id?: SortOrder
    user_id?: SortOrder
  }

  export type Enumpolicy_agree_policy_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.policy_agree_policy_type | Enumpolicy_agree_policy_typeFieldRefInput<$PrismaModel>
    in?: $Enums.policy_agree_policy_type[]
    notIn?: $Enums.policy_agree_policy_type[]
    not?: NestedEnumpolicy_agree_policy_typeWithAggregatesFilter<$PrismaModel> | $Enums.policy_agree_policy_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpolicy_agree_policy_typeFilter<$PrismaModel>
    _max?: NestedEnumpolicy_agree_policy_typeFilter<$PrismaModel>
  }

  export type Enumpolicy_history_policy_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.policy_history_policy_type | Enumpolicy_history_policy_typeFieldRefInput<$PrismaModel>
    in?: $Enums.policy_history_policy_type[]
    notIn?: $Enums.policy_history_policy_type[]
    not?: NestedEnumpolicy_history_policy_typeFilter<$PrismaModel> | $Enums.policy_history_policy_type
  }

  export type policy_historyOrderByRelevanceInput = {
    fields: policy_historyOrderByRelevanceFieldEnum | policy_historyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type policy_historyCountOrderByAggregateInput = {
    policy_history_id?: SortOrder
    policy_type?: SortOrder
    revision_date?: SortOrder
    pdf_file_path?: SortOrder
    required?: SortOrder
    is_latest_revision?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type policy_historyAvgOrderByAggregateInput = {
    policy_history_id?: SortOrder
  }

  export type policy_historyMaxOrderByAggregateInput = {
    policy_history_id?: SortOrder
    policy_type?: SortOrder
    revision_date?: SortOrder
    pdf_file_path?: SortOrder
    required?: SortOrder
    is_latest_revision?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type policy_historyMinOrderByAggregateInput = {
    policy_history_id?: SortOrder
    policy_type?: SortOrder
    revision_date?: SortOrder
    pdf_file_path?: SortOrder
    required?: SortOrder
    is_latest_revision?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type policy_historySumOrderByAggregateInput = {
    policy_history_id?: SortOrder
  }

  export type Enumpolicy_history_policy_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.policy_history_policy_type | Enumpolicy_history_policy_typeFieldRefInput<$PrismaModel>
    in?: $Enums.policy_history_policy_type[]
    notIn?: $Enums.policy_history_policy_type[]
    not?: NestedEnumpolicy_history_policy_typeWithAggregatesFilter<$PrismaModel> | $Enums.policy_history_policy_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpolicy_history_policy_typeFilter<$PrismaModel>
    _max?: NestedEnumpolicy_history_policy_typeFilter<$PrismaModel>
  }

  export type post_hashtagPost_hashtags_idPost_idHashtag_idCompoundUniqueInput = {
    post_hashtags_id: bigint | number
    post_id: bigint | number
    hashtag_id: bigint | number
  }

  export type post_hashtagCountOrderByAggregateInput = {
    post_hashtags_id?: SortOrder
    post_id?: SortOrder
    hashtag_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type post_hashtagAvgOrderByAggregateInput = {
    post_hashtags_id?: SortOrder
    post_id?: SortOrder
    hashtag_id?: SortOrder
  }

  export type post_hashtagMaxOrderByAggregateInput = {
    post_hashtags_id?: SortOrder
    post_id?: SortOrder
    hashtag_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type post_hashtagMinOrderByAggregateInput = {
    post_hashtags_id?: SortOrder
    post_id?: SortOrder
    hashtag_id?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type post_hashtagSumOrderByAggregateInput = {
    post_hashtags_id?: SortOrder
    post_id?: SortOrder
    hashtag_id?: SortOrder
  }

  export type Enumrecommended_feed_recommended_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.recommended_feed_recommended_type | Enumrecommended_feed_recommended_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.recommended_feed_recommended_type[] | null
    notIn?: $Enums.recommended_feed_recommended_type[] | null
    not?: NestedEnumrecommended_feed_recommended_typeNullableFilter<$PrismaModel> | $Enums.recommended_feed_recommended_type | null
  }

  export type recommended_feedCountOrderByAggregateInput = {
    recommended_feed_id?: SortOrder
    hobby_post_id?: SortOrder
    recommended_type?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type recommended_feedAvgOrderByAggregateInput = {
    recommended_feed_id?: SortOrder
    hobby_post_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type recommended_feedMaxOrderByAggregateInput = {
    recommended_feed_id?: SortOrder
    hobby_post_id?: SortOrder
    recommended_type?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type recommended_feedMinOrderByAggregateInput = {
    recommended_feed_id?: SortOrder
    hobby_post_id?: SortOrder
    recommended_type?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type recommended_feedSumOrderByAggregateInput = {
    recommended_feed_id?: SortOrder
    hobby_post_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type Enumrecommended_feed_recommended_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.recommended_feed_recommended_type | Enumrecommended_feed_recommended_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.recommended_feed_recommended_type[] | null
    notIn?: $Enums.recommended_feed_recommended_type[] | null
    not?: NestedEnumrecommended_feed_recommended_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.recommended_feed_recommended_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumrecommended_feed_recommended_typeNullableFilter<$PrismaModel>
    _max?: NestedEnumrecommended_feed_recommended_typeNullableFilter<$PrismaModel>
  }

  export type Enumreport_report_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.report_report_status | Enumreport_report_statusFieldRefInput<$PrismaModel>
    in?: $Enums.report_report_status[]
    notIn?: $Enums.report_report_status[]
    not?: NestedEnumreport_report_statusFilter<$PrismaModel> | $Enums.report_report_status
  }

  export type reportOrderByRelevanceInput = {
    fields: reportOrderByRelevanceFieldEnum | reportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type reportCreated_atUser_idCompoundUniqueInput = {
    created_at: Date | string
    user_id: bigint | number
  }

  export type reportCountOrderByAggregateInput = {
    report_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrder
    comment_id?: SortOrder
    sub_comment_id?: SortOrder
    report_content?: SortOrder
    report_status?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type reportAvgOrderByAggregateInput = {
    report_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrder
    comment_id?: SortOrder
    sub_comment_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type reportMaxOrderByAggregateInput = {
    report_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrder
    comment_id?: SortOrder
    sub_comment_id?: SortOrder
    report_content?: SortOrder
    report_status?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type reportMinOrderByAggregateInput = {
    report_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrder
    comment_id?: SortOrder
    sub_comment_id?: SortOrder
    report_content?: SortOrder
    report_status?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type reportSumOrderByAggregateInput = {
    report_id?: SortOrder
    user_id?: SortOrder
    hobby_post_id?: SortOrder
    comment_id?: SortOrder
    sub_comment_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type Enumreport_report_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.report_report_status | Enumreport_report_statusFieldRefInput<$PrismaModel>
    in?: $Enums.report_report_status[]
    notIn?: $Enums.report_report_status[]
    not?: NestedEnumreport_report_statusWithAggregatesFilter<$PrismaModel> | $Enums.report_report_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreport_report_statusFilter<$PrismaModel>
    _max?: NestedEnumreport_report_statusFilter<$PrismaModel>
  }

  export type settingCountOrderByAggregateInput = {
    setting_id?: SortOrder
    user_id?: SortOrder
    notification?: SortOrder
    marketing?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type settingAvgOrderByAggregateInput = {
    setting_id?: SortOrder
    user_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type settingMaxOrderByAggregateInput = {
    setting_id?: SortOrder
    user_id?: SortOrder
    notification?: SortOrder
    marketing?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type settingMinOrderByAggregateInput = {
    setting_id?: SortOrder
    user_id?: SortOrder
    notification?: SortOrder
    marketing?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    modified_at?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type settingSumOrderByAggregateInput = {
    setting_id?: SortOrder
    user_id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
  }

  export type today_hobbyOrderByRelevanceInput = {
    fields: today_hobbyOrderByRelevanceFieldEnum | today_hobbyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type today_hobbyCountOrderByAggregateInput = {
    today_hobby_id?: SortOrder
    hobby_category_id?: SortOrder
    today_theme_code?: SortOrder
    today_theme_name?: SortOrder
    today_hobby_details_name?: SortOrder
    today_hobby_details_description?: SortOrder
    today_hobby_details_attributes?: SortOrder
    today_hobby_thumbnail?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type today_hobbyAvgOrderByAggregateInput = {
    today_hobby_id?: SortOrder
    hobby_category_id?: SortOrder
    today_theme_code?: SortOrder
  }

  export type today_hobbyMaxOrderByAggregateInput = {
    today_hobby_id?: SortOrder
    hobby_category_id?: SortOrder
    today_theme_code?: SortOrder
    today_theme_name?: SortOrder
    today_hobby_details_name?: SortOrder
    today_hobby_details_description?: SortOrder
    today_hobby_details_attributes?: SortOrder
    today_hobby_thumbnail?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type today_hobbyMinOrderByAggregateInput = {
    today_hobby_id?: SortOrder
    hobby_category_id?: SortOrder
    today_theme_code?: SortOrder
    today_theme_name?: SortOrder
    today_hobby_details_name?: SortOrder
    today_hobby_details_description?: SortOrder
    today_hobby_details_attributes?: SortOrder
    today_hobby_thumbnail?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type today_hobbySumOrderByAggregateInput = {
    today_hobby_id?: SortOrder
    hobby_category_id?: SortOrder
    today_theme_code?: SortOrder
  }

  export type Enumuser_user_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.user_user_type | Enumuser_user_typeFieldRefInput<$PrismaModel>
    in?: $Enums.user_user_type[]
    notIn?: $Enums.user_user_type[]
    not?: NestedEnumuser_user_typeFilter<$PrismaModel> | $Enums.user_user_type
  }

  export type Enumuser_provider_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.user_provider_type | Enumuser_provider_typeFieldRefInput<$PrismaModel>
    in?: $Enums.user_provider_type[]
    notIn?: $Enums.user_provider_type[]
    not?: NestedEnumuser_provider_typeFilter<$PrismaModel> | $Enums.user_provider_type
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    user_id?: SortOrder
    user_email?: SortOrder
    user_profile?: SortOrder
    user_password?: SortOrder
    user_type?: SortOrder
    user_nickname?: SortOrder
    provider_type?: SortOrder
    provider_key?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    user_last_login_date?: SortOrder
    deleted?: SortOrder
    dormancy?: SortOrder
    refresh_token?: SortOrder
    profile_description?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    user_id?: SortOrder
    user_email?: SortOrder
    user_profile?: SortOrder
    user_password?: SortOrder
    user_type?: SortOrder
    user_nickname?: SortOrder
    provider_type?: SortOrder
    provider_key?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    user_last_login_date?: SortOrder
    deleted?: SortOrder
    dormancy?: SortOrder
    refresh_token?: SortOrder
    profile_description?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    user_id?: SortOrder
    user_email?: SortOrder
    user_profile?: SortOrder
    user_password?: SortOrder
    user_type?: SortOrder
    user_nickname?: SortOrder
    provider_type?: SortOrder
    provider_key?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
    user_last_login_date?: SortOrder
    deleted?: SortOrder
    dormancy?: SortOrder
    refresh_token?: SortOrder
    profile_description?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type Enumuser_user_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_user_type | Enumuser_user_typeFieldRefInput<$PrismaModel>
    in?: $Enums.user_user_type[]
    notIn?: $Enums.user_user_type[]
    not?: NestedEnumuser_user_typeWithAggregatesFilter<$PrismaModel> | $Enums.user_user_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_user_typeFilter<$PrismaModel>
    _max?: NestedEnumuser_user_typeFilter<$PrismaModel>
  }

  export type Enumuser_provider_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_provider_type | Enumuser_provider_typeFieldRefInput<$PrismaModel>
    in?: $Enums.user_provider_type[]
    notIn?: $Enums.user_provider_type[]
    not?: NestedEnumuser_provider_typeWithAggregatesFilter<$PrismaModel> | $Enums.user_provider_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_provider_typeFilter<$PrismaModel>
    _max?: NestedEnumuser_provider_typeFilter<$PrismaModel>
  }

  export type user_metricsCountOrderByAggregateInput = {
    id?: SortOrder
    new_users?: SortOrder
    total_users?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type user_metricsAvgOrderByAggregateInput = {
    id?: SortOrder
    new_users?: SortOrder
    total_users?: SortOrder
  }

  export type user_metricsMaxOrderByAggregateInput = {
    id?: SortOrder
    new_users?: SortOrder
    total_users?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type user_metricsMinOrderByAggregateInput = {
    id?: SortOrder
    new_users?: SortOrder
    total_users?: SortOrder
    created_at?: SortOrder
    modified_at?: SortOrder
  }

  export type user_metricsSumOrderByAggregateInput = {
    id?: SortOrder
    new_users?: SortOrder
    total_users?: SortOrder
  }

  export type QRTZ_TRIGGERSCreateNestedOneWithoutQRTZ_BLOB_TRIGGERSInput = {
    create?: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_BLOB_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_BLOB_TRIGGERSInput>
    connectOrCreate?: QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_BLOB_TRIGGERSInput
    connect?: QRTZ_TRIGGERSWhereUniqueInput
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type QRTZ_TRIGGERSUpdateOneRequiredWithoutQRTZ_BLOB_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_BLOB_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_BLOB_TRIGGERSInput>
    connectOrCreate?: QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_BLOB_TRIGGERSInput
    upsert?: QRTZ_TRIGGERSUpsertWithoutQRTZ_BLOB_TRIGGERSInput
    connect?: QRTZ_TRIGGERSWhereUniqueInput
    update?: XOR<XOR<QRTZ_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_BLOB_TRIGGERSInput, QRTZ_TRIGGERSUpdateWithoutQRTZ_BLOB_TRIGGERSInput>, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_BLOB_TRIGGERSInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type QRTZ_TRIGGERSCreateNestedOneWithoutQRTZ_CRON_TRIGGERSInput = {
    create?: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_CRON_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_CRON_TRIGGERSInput>
    connectOrCreate?: QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_CRON_TRIGGERSInput
    connect?: QRTZ_TRIGGERSWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type QRTZ_TRIGGERSUpdateOneRequiredWithoutQRTZ_CRON_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_CRON_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_CRON_TRIGGERSInput>
    connectOrCreate?: QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_CRON_TRIGGERSInput
    upsert?: QRTZ_TRIGGERSUpsertWithoutQRTZ_CRON_TRIGGERSInput
    connect?: QRTZ_TRIGGERSWhereUniqueInput
    update?: XOR<XOR<QRTZ_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_CRON_TRIGGERSInput, QRTZ_TRIGGERSUpdateWithoutQRTZ_CRON_TRIGGERSInput>, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_CRON_TRIGGERSInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QRTZ_TRIGGERSCreateNestedManyWithoutQRTZ_JOB_DETAILSInput = {
    create?: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_JOB_DETAILSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_JOB_DETAILSInput> | QRTZ_TRIGGERSCreateWithoutQRTZ_JOB_DETAILSInput[] | QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_JOB_DETAILSInput[]
    connectOrCreate?: QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_JOB_DETAILSInput | QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_JOB_DETAILSInput[]
    createMany?: QRTZ_TRIGGERSCreateManyQRTZ_JOB_DETAILSInputEnvelope
    connect?: QRTZ_TRIGGERSWhereUniqueInput | QRTZ_TRIGGERSWhereUniqueInput[]
  }

  export type QRTZ_TRIGGERSUncheckedCreateNestedManyWithoutQRTZ_JOB_DETAILSInput = {
    create?: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_JOB_DETAILSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_JOB_DETAILSInput> | QRTZ_TRIGGERSCreateWithoutQRTZ_JOB_DETAILSInput[] | QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_JOB_DETAILSInput[]
    connectOrCreate?: QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_JOB_DETAILSInput | QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_JOB_DETAILSInput[]
    createMany?: QRTZ_TRIGGERSCreateManyQRTZ_JOB_DETAILSInputEnvelope
    connect?: QRTZ_TRIGGERSWhereUniqueInput | QRTZ_TRIGGERSWhereUniqueInput[]
  }

  export type QRTZ_TRIGGERSUpdateManyWithoutQRTZ_JOB_DETAILSNestedInput = {
    create?: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_JOB_DETAILSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_JOB_DETAILSInput> | QRTZ_TRIGGERSCreateWithoutQRTZ_JOB_DETAILSInput[] | QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_JOB_DETAILSInput[]
    connectOrCreate?: QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_JOB_DETAILSInput | QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_JOB_DETAILSInput[]
    upsert?: QRTZ_TRIGGERSUpsertWithWhereUniqueWithoutQRTZ_JOB_DETAILSInput | QRTZ_TRIGGERSUpsertWithWhereUniqueWithoutQRTZ_JOB_DETAILSInput[]
    createMany?: QRTZ_TRIGGERSCreateManyQRTZ_JOB_DETAILSInputEnvelope
    set?: QRTZ_TRIGGERSWhereUniqueInput | QRTZ_TRIGGERSWhereUniqueInput[]
    disconnect?: QRTZ_TRIGGERSWhereUniqueInput | QRTZ_TRIGGERSWhereUniqueInput[]
    delete?: QRTZ_TRIGGERSWhereUniqueInput | QRTZ_TRIGGERSWhereUniqueInput[]
    connect?: QRTZ_TRIGGERSWhereUniqueInput | QRTZ_TRIGGERSWhereUniqueInput[]
    update?: QRTZ_TRIGGERSUpdateWithWhereUniqueWithoutQRTZ_JOB_DETAILSInput | QRTZ_TRIGGERSUpdateWithWhereUniqueWithoutQRTZ_JOB_DETAILSInput[]
    updateMany?: QRTZ_TRIGGERSUpdateManyWithWhereWithoutQRTZ_JOB_DETAILSInput | QRTZ_TRIGGERSUpdateManyWithWhereWithoutQRTZ_JOB_DETAILSInput[]
    deleteMany?: QRTZ_TRIGGERSScalarWhereInput | QRTZ_TRIGGERSScalarWhereInput[]
  }

  export type QRTZ_TRIGGERSUncheckedUpdateManyWithoutQRTZ_JOB_DETAILSNestedInput = {
    create?: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_JOB_DETAILSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_JOB_DETAILSInput> | QRTZ_TRIGGERSCreateWithoutQRTZ_JOB_DETAILSInput[] | QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_JOB_DETAILSInput[]
    connectOrCreate?: QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_JOB_DETAILSInput | QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_JOB_DETAILSInput[]
    upsert?: QRTZ_TRIGGERSUpsertWithWhereUniqueWithoutQRTZ_JOB_DETAILSInput | QRTZ_TRIGGERSUpsertWithWhereUniqueWithoutQRTZ_JOB_DETAILSInput[]
    createMany?: QRTZ_TRIGGERSCreateManyQRTZ_JOB_DETAILSInputEnvelope
    set?: QRTZ_TRIGGERSWhereUniqueInput | QRTZ_TRIGGERSWhereUniqueInput[]
    disconnect?: QRTZ_TRIGGERSWhereUniqueInput | QRTZ_TRIGGERSWhereUniqueInput[]
    delete?: QRTZ_TRIGGERSWhereUniqueInput | QRTZ_TRIGGERSWhereUniqueInput[]
    connect?: QRTZ_TRIGGERSWhereUniqueInput | QRTZ_TRIGGERSWhereUniqueInput[]
    update?: QRTZ_TRIGGERSUpdateWithWhereUniqueWithoutQRTZ_JOB_DETAILSInput | QRTZ_TRIGGERSUpdateWithWhereUniqueWithoutQRTZ_JOB_DETAILSInput[]
    updateMany?: QRTZ_TRIGGERSUpdateManyWithWhereWithoutQRTZ_JOB_DETAILSInput | QRTZ_TRIGGERSUpdateManyWithWhereWithoutQRTZ_JOB_DETAILSInput[]
    deleteMany?: QRTZ_TRIGGERSScalarWhereInput | QRTZ_TRIGGERSScalarWhereInput[]
  }

  export type QRTZ_TRIGGERSCreateNestedOneWithoutQRTZ_SIMPLE_TRIGGERSInput = {
    create?: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_SIMPLE_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_SIMPLE_TRIGGERSInput>
    connectOrCreate?: QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_SIMPLE_TRIGGERSInput
    connect?: QRTZ_TRIGGERSWhereUniqueInput
  }

  export type QRTZ_TRIGGERSUpdateOneRequiredWithoutQRTZ_SIMPLE_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_SIMPLE_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_SIMPLE_TRIGGERSInput>
    connectOrCreate?: QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_SIMPLE_TRIGGERSInput
    upsert?: QRTZ_TRIGGERSUpsertWithoutQRTZ_SIMPLE_TRIGGERSInput
    connect?: QRTZ_TRIGGERSWhereUniqueInput
    update?: XOR<XOR<QRTZ_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_SIMPLE_TRIGGERSInput, QRTZ_TRIGGERSUpdateWithoutQRTZ_SIMPLE_TRIGGERSInput>, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_SIMPLE_TRIGGERSInput>
  }

  export type QRTZ_TRIGGERSCreateNestedOneWithoutQRTZ_SIMPROP_TRIGGERSInput = {
    create?: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_SIMPROP_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_SIMPROP_TRIGGERSInput>
    connectOrCreate?: QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_SIMPROP_TRIGGERSInput
    connect?: QRTZ_TRIGGERSWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type QRTZ_TRIGGERSUpdateOneRequiredWithoutQRTZ_SIMPROP_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_SIMPROP_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_SIMPROP_TRIGGERSInput>
    connectOrCreate?: QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_SIMPROP_TRIGGERSInput
    upsert?: QRTZ_TRIGGERSUpsertWithoutQRTZ_SIMPROP_TRIGGERSInput
    connect?: QRTZ_TRIGGERSWhereUniqueInput
    update?: XOR<XOR<QRTZ_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_SIMPROP_TRIGGERSInput, QRTZ_TRIGGERSUpdateWithoutQRTZ_SIMPROP_TRIGGERSInput>, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_SIMPROP_TRIGGERSInput>
  }

  export type QRTZ_BLOB_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput = {
    create?: XOR<QRTZ_BLOB_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_BLOB_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_BLOB_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    connect?: QRTZ_BLOB_TRIGGERSWhereUniqueInput
  }

  export type QRTZ_CRON_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput = {
    create?: XOR<QRTZ_CRON_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_CRON_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_CRON_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    connect?: QRTZ_CRON_TRIGGERSWhereUniqueInput
  }

  export type QRTZ_SIMPLE_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput = {
    create?: XOR<QRTZ_SIMPLE_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPLE_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_SIMPLE_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    connect?: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
  }

  export type QRTZ_SIMPROP_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput = {
    create?: XOR<QRTZ_SIMPROP_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPROP_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_SIMPROP_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    connect?: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
  }

  export type QRTZ_JOB_DETAILSCreateNestedOneWithoutQRTZ_TRIGGERSInput = {
    create?: XOR<QRTZ_JOB_DETAILSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_JOB_DETAILSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_JOB_DETAILSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    connect?: QRTZ_JOB_DETAILSWhereUniqueInput
  }

  export type QRTZ_BLOB_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput = {
    create?: XOR<QRTZ_BLOB_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_BLOB_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_BLOB_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    connect?: QRTZ_BLOB_TRIGGERSWhereUniqueInput
  }

  export type QRTZ_CRON_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput = {
    create?: XOR<QRTZ_CRON_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_CRON_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_CRON_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    connect?: QRTZ_CRON_TRIGGERSWhereUniqueInput
  }

  export type QRTZ_SIMPLE_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput = {
    create?: XOR<QRTZ_SIMPLE_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPLE_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_SIMPLE_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    connect?: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
  }

  export type QRTZ_SIMPROP_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput = {
    create?: XOR<QRTZ_SIMPROP_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPROP_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_SIMPROP_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    connect?: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
  }

  export type QRTZ_BLOB_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_BLOB_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_BLOB_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_BLOB_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    upsert?: QRTZ_BLOB_TRIGGERSUpsertWithoutQRTZ_TRIGGERSInput
    disconnect?: QRTZ_BLOB_TRIGGERSWhereInput | boolean
    delete?: QRTZ_BLOB_TRIGGERSWhereInput | boolean
    connect?: QRTZ_BLOB_TRIGGERSWhereUniqueInput
    update?: XOR<XOR<QRTZ_BLOB_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput, QRTZ_BLOB_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput>, QRTZ_BLOB_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_CRON_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_CRON_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_CRON_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_CRON_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    upsert?: QRTZ_CRON_TRIGGERSUpsertWithoutQRTZ_TRIGGERSInput
    disconnect?: QRTZ_CRON_TRIGGERSWhereInput | boolean
    delete?: QRTZ_CRON_TRIGGERSWhereInput | boolean
    connect?: QRTZ_CRON_TRIGGERSWhereUniqueInput
    update?: XOR<XOR<QRTZ_CRON_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput, QRTZ_CRON_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput>, QRTZ_CRON_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_SIMPLE_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_SIMPLE_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPLE_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_SIMPLE_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    upsert?: QRTZ_SIMPLE_TRIGGERSUpsertWithoutQRTZ_TRIGGERSInput
    disconnect?: QRTZ_SIMPLE_TRIGGERSWhereInput | boolean
    delete?: QRTZ_SIMPLE_TRIGGERSWhereInput | boolean
    connect?: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
    update?: XOR<XOR<QRTZ_SIMPLE_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPLE_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput>, QRTZ_SIMPLE_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_SIMPROP_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_SIMPROP_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPROP_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_SIMPROP_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    upsert?: QRTZ_SIMPROP_TRIGGERSUpsertWithoutQRTZ_TRIGGERSInput
    disconnect?: QRTZ_SIMPROP_TRIGGERSWhereInput | boolean
    delete?: QRTZ_SIMPROP_TRIGGERSWhereInput | boolean
    connect?: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
    update?: XOR<XOR<QRTZ_SIMPROP_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPROP_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput>, QRTZ_SIMPROP_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_JOB_DETAILSUpdateOneRequiredWithoutQRTZ_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_JOB_DETAILSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_JOB_DETAILSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_JOB_DETAILSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    upsert?: QRTZ_JOB_DETAILSUpsertWithoutQRTZ_TRIGGERSInput
    connect?: QRTZ_JOB_DETAILSWhereUniqueInput
    update?: XOR<XOR<QRTZ_JOB_DETAILSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput, QRTZ_JOB_DETAILSUpdateWithoutQRTZ_TRIGGERSInput>, QRTZ_JOB_DETAILSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_BLOB_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_BLOB_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_BLOB_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_BLOB_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    upsert?: QRTZ_BLOB_TRIGGERSUpsertWithoutQRTZ_TRIGGERSInput
    disconnect?: QRTZ_BLOB_TRIGGERSWhereInput | boolean
    delete?: QRTZ_BLOB_TRIGGERSWhereInput | boolean
    connect?: QRTZ_BLOB_TRIGGERSWhereUniqueInput
    update?: XOR<XOR<QRTZ_BLOB_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput, QRTZ_BLOB_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput>, QRTZ_BLOB_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_CRON_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_CRON_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_CRON_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_CRON_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    upsert?: QRTZ_CRON_TRIGGERSUpsertWithoutQRTZ_TRIGGERSInput
    disconnect?: QRTZ_CRON_TRIGGERSWhereInput | boolean
    delete?: QRTZ_CRON_TRIGGERSWhereInput | boolean
    connect?: QRTZ_CRON_TRIGGERSWhereUniqueInput
    update?: XOR<XOR<QRTZ_CRON_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput, QRTZ_CRON_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput>, QRTZ_CRON_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_SIMPLE_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_SIMPLE_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPLE_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_SIMPLE_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    upsert?: QRTZ_SIMPLE_TRIGGERSUpsertWithoutQRTZ_TRIGGERSInput
    disconnect?: QRTZ_SIMPLE_TRIGGERSWhereInput | boolean
    delete?: QRTZ_SIMPLE_TRIGGERSWhereInput | boolean
    connect?: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
    update?: XOR<XOR<QRTZ_SIMPLE_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPLE_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput>, QRTZ_SIMPLE_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_SIMPROP_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput = {
    create?: XOR<QRTZ_SIMPROP_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPROP_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    connectOrCreate?: QRTZ_SIMPROP_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput
    upsert?: QRTZ_SIMPROP_TRIGGERSUpsertWithoutQRTZ_TRIGGERSInput
    disconnect?: QRTZ_SIMPROP_TRIGGERSWhereInput | boolean
    delete?: QRTZ_SIMPROP_TRIGGERSWhereInput | boolean
    connect?: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
    update?: XOR<XOR<QRTZ_SIMPROP_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPROP_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput>, QRTZ_SIMPROP_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type Enumhobby_category_hobby_category_nameFieldUpdateOperationsInput = {
    set?: $Enums.hobby_category_hobby_category_name
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type Enumhobby_top_ten_categoryFieldUpdateOperationsInput = {
    set?: $Enums.hobby_top_ten_category
  }

  export type Enumhobby_view_history_categoryFieldUpdateOperationsInput = {
    set?: $Enums.hobby_view_history_category
  }

  export type Enumpolicy_agree_policy_typeFieldUpdateOperationsInput = {
    set?: $Enums.policy_agree_policy_type
  }

  export type Enumpolicy_history_policy_typeFieldUpdateOperationsInput = {
    set?: $Enums.policy_history_policy_type
  }

  export type NullableEnumrecommended_feed_recommended_typeFieldUpdateOperationsInput = {
    set?: $Enums.recommended_feed_recommended_type | null
  }

  export type Enumreport_report_statusFieldUpdateOperationsInput = {
    set?: $Enums.report_report_status
  }

  export type Enumuser_user_typeFieldUpdateOperationsInput = {
    set?: $Enums.user_user_type
  }

  export type Enumuser_provider_typeFieldUpdateOperationsInput = {
    set?: $Enums.user_provider_type
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumhobby_category_hobby_category_nameFilter<$PrismaModel = never> = {
    equals?: $Enums.hobby_category_hobby_category_name | Enumhobby_category_hobby_category_nameFieldRefInput<$PrismaModel>
    in?: $Enums.hobby_category_hobby_category_name[]
    notIn?: $Enums.hobby_category_hobby_category_name[]
    not?: NestedEnumhobby_category_hobby_category_nameFilter<$PrismaModel> | $Enums.hobby_category_hobby_category_name
  }

  export type NestedEnumhobby_category_hobby_category_nameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.hobby_category_hobby_category_name | Enumhobby_category_hobby_category_nameFieldRefInput<$PrismaModel>
    in?: $Enums.hobby_category_hobby_category_name[]
    notIn?: $Enums.hobby_category_hobby_category_name[]
    not?: NestedEnumhobby_category_hobby_category_nameWithAggregatesFilter<$PrismaModel> | $Enums.hobby_category_hobby_category_name
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumhobby_category_hobby_category_nameFilter<$PrismaModel>
    _max?: NestedEnumhobby_category_hobby_category_nameFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumhobby_top_ten_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.hobby_top_ten_category | Enumhobby_top_ten_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.hobby_top_ten_category[]
    notIn?: $Enums.hobby_top_ten_category[]
    not?: NestedEnumhobby_top_ten_categoryFilter<$PrismaModel> | $Enums.hobby_top_ten_category
  }

  export type NestedEnumhobby_top_ten_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.hobby_top_ten_category | Enumhobby_top_ten_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.hobby_top_ten_category[]
    notIn?: $Enums.hobby_top_ten_category[]
    not?: NestedEnumhobby_top_ten_categoryWithAggregatesFilter<$PrismaModel> | $Enums.hobby_top_ten_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumhobby_top_ten_categoryFilter<$PrismaModel>
    _max?: NestedEnumhobby_top_ten_categoryFilter<$PrismaModel>
  }

  export type NestedEnumhobby_view_history_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.hobby_view_history_category | Enumhobby_view_history_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.hobby_view_history_category[]
    notIn?: $Enums.hobby_view_history_category[]
    not?: NestedEnumhobby_view_history_categoryFilter<$PrismaModel> | $Enums.hobby_view_history_category
  }

  export type NestedEnumhobby_view_history_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.hobby_view_history_category | Enumhobby_view_history_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.hobby_view_history_category[]
    notIn?: $Enums.hobby_view_history_category[]
    not?: NestedEnumhobby_view_history_categoryWithAggregatesFilter<$PrismaModel> | $Enums.hobby_view_history_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumhobby_view_history_categoryFilter<$PrismaModel>
    _max?: NestedEnumhobby_view_history_categoryFilter<$PrismaModel>
  }

  export type NestedEnumpolicy_agree_policy_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.policy_agree_policy_type | Enumpolicy_agree_policy_typeFieldRefInput<$PrismaModel>
    in?: $Enums.policy_agree_policy_type[]
    notIn?: $Enums.policy_agree_policy_type[]
    not?: NestedEnumpolicy_agree_policy_typeFilter<$PrismaModel> | $Enums.policy_agree_policy_type
  }

  export type NestedEnumpolicy_agree_policy_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.policy_agree_policy_type | Enumpolicy_agree_policy_typeFieldRefInput<$PrismaModel>
    in?: $Enums.policy_agree_policy_type[]
    notIn?: $Enums.policy_agree_policy_type[]
    not?: NestedEnumpolicy_agree_policy_typeWithAggregatesFilter<$PrismaModel> | $Enums.policy_agree_policy_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpolicy_agree_policy_typeFilter<$PrismaModel>
    _max?: NestedEnumpolicy_agree_policy_typeFilter<$PrismaModel>
  }

  export type NestedEnumpolicy_history_policy_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.policy_history_policy_type | Enumpolicy_history_policy_typeFieldRefInput<$PrismaModel>
    in?: $Enums.policy_history_policy_type[]
    notIn?: $Enums.policy_history_policy_type[]
    not?: NestedEnumpolicy_history_policy_typeFilter<$PrismaModel> | $Enums.policy_history_policy_type
  }

  export type NestedEnumpolicy_history_policy_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.policy_history_policy_type | Enumpolicy_history_policy_typeFieldRefInput<$PrismaModel>
    in?: $Enums.policy_history_policy_type[]
    notIn?: $Enums.policy_history_policy_type[]
    not?: NestedEnumpolicy_history_policy_typeWithAggregatesFilter<$PrismaModel> | $Enums.policy_history_policy_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpolicy_history_policy_typeFilter<$PrismaModel>
    _max?: NestedEnumpolicy_history_policy_typeFilter<$PrismaModel>
  }

  export type NestedEnumrecommended_feed_recommended_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.recommended_feed_recommended_type | Enumrecommended_feed_recommended_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.recommended_feed_recommended_type[] | null
    notIn?: $Enums.recommended_feed_recommended_type[] | null
    not?: NestedEnumrecommended_feed_recommended_typeNullableFilter<$PrismaModel> | $Enums.recommended_feed_recommended_type | null
  }

  export type NestedEnumrecommended_feed_recommended_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.recommended_feed_recommended_type | Enumrecommended_feed_recommended_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.recommended_feed_recommended_type[] | null
    notIn?: $Enums.recommended_feed_recommended_type[] | null
    not?: NestedEnumrecommended_feed_recommended_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.recommended_feed_recommended_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumrecommended_feed_recommended_typeNullableFilter<$PrismaModel>
    _max?: NestedEnumrecommended_feed_recommended_typeNullableFilter<$PrismaModel>
  }

  export type NestedEnumreport_report_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.report_report_status | Enumreport_report_statusFieldRefInput<$PrismaModel>
    in?: $Enums.report_report_status[]
    notIn?: $Enums.report_report_status[]
    not?: NestedEnumreport_report_statusFilter<$PrismaModel> | $Enums.report_report_status
  }

  export type NestedEnumreport_report_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.report_report_status | Enumreport_report_statusFieldRefInput<$PrismaModel>
    in?: $Enums.report_report_status[]
    notIn?: $Enums.report_report_status[]
    not?: NestedEnumreport_report_statusWithAggregatesFilter<$PrismaModel> | $Enums.report_report_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreport_report_statusFilter<$PrismaModel>
    _max?: NestedEnumreport_report_statusFilter<$PrismaModel>
  }

  export type NestedEnumuser_user_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.user_user_type | Enumuser_user_typeFieldRefInput<$PrismaModel>
    in?: $Enums.user_user_type[]
    notIn?: $Enums.user_user_type[]
    not?: NestedEnumuser_user_typeFilter<$PrismaModel> | $Enums.user_user_type
  }

  export type NestedEnumuser_provider_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.user_provider_type | Enumuser_provider_typeFieldRefInput<$PrismaModel>
    in?: $Enums.user_provider_type[]
    notIn?: $Enums.user_provider_type[]
    not?: NestedEnumuser_provider_typeFilter<$PrismaModel> | $Enums.user_provider_type
  }

  export type NestedEnumuser_user_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_user_type | Enumuser_user_typeFieldRefInput<$PrismaModel>
    in?: $Enums.user_user_type[]
    notIn?: $Enums.user_user_type[]
    not?: NestedEnumuser_user_typeWithAggregatesFilter<$PrismaModel> | $Enums.user_user_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_user_typeFilter<$PrismaModel>
    _max?: NestedEnumuser_user_typeFilter<$PrismaModel>
  }

  export type NestedEnumuser_provider_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_provider_type | Enumuser_provider_typeFieldRefInput<$PrismaModel>
    in?: $Enums.user_provider_type[]
    notIn?: $Enums.user_provider_type[]
    not?: NestedEnumuser_provider_typeWithAggregatesFilter<$PrismaModel> | $Enums.user_provider_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_provider_typeFilter<$PrismaModel>
    _max?: NestedEnumuser_provider_typeFilter<$PrismaModel>
  }

  export type QRTZ_TRIGGERSCreateWithoutQRTZ_BLOB_TRIGGERSInput = {
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_JOB_DETAILS: QRTZ_JOB_DETAILSCreateNestedOneWithoutQRTZ_TRIGGERSInput
  }

  export type QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_BLOB_TRIGGERSInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
  }

  export type QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_BLOB_TRIGGERSInput = {
    where: QRTZ_TRIGGERSWhereUniqueInput
    create: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_BLOB_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_BLOB_TRIGGERSInput>
  }

  export type QRTZ_TRIGGERSUpsertWithoutQRTZ_BLOB_TRIGGERSInput = {
    update: XOR<QRTZ_TRIGGERSUpdateWithoutQRTZ_BLOB_TRIGGERSInput, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_BLOB_TRIGGERSInput>
    create: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_BLOB_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_BLOB_TRIGGERSInput>
    where?: QRTZ_TRIGGERSWhereInput
  }

  export type QRTZ_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_BLOB_TRIGGERSInput = {
    where?: QRTZ_TRIGGERSWhereInput
    data: XOR<QRTZ_TRIGGERSUpdateWithoutQRTZ_BLOB_TRIGGERSInput, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_BLOB_TRIGGERSInput>
  }

  export type QRTZ_TRIGGERSUpdateWithoutQRTZ_BLOB_TRIGGERSInput = {
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_JOB_DETAILS?: QRTZ_JOB_DETAILSUpdateOneRequiredWithoutQRTZ_TRIGGERSNestedInput
  }

  export type QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_BLOB_TRIGGERSInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: StringFieldUpdateOperationsInput | string
    JOB_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
  }

  export type QRTZ_TRIGGERSCreateWithoutQRTZ_CRON_TRIGGERSInput = {
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_JOB_DETAILS: QRTZ_JOB_DETAILSCreateNestedOneWithoutQRTZ_TRIGGERSInput
  }

  export type QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_CRON_TRIGGERSInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
  }

  export type QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_CRON_TRIGGERSInput = {
    where: QRTZ_TRIGGERSWhereUniqueInput
    create: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_CRON_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_CRON_TRIGGERSInput>
  }

  export type QRTZ_TRIGGERSUpsertWithoutQRTZ_CRON_TRIGGERSInput = {
    update: XOR<QRTZ_TRIGGERSUpdateWithoutQRTZ_CRON_TRIGGERSInput, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_CRON_TRIGGERSInput>
    create: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_CRON_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_CRON_TRIGGERSInput>
    where?: QRTZ_TRIGGERSWhereInput
  }

  export type QRTZ_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_CRON_TRIGGERSInput = {
    where?: QRTZ_TRIGGERSWhereInput
    data: XOR<QRTZ_TRIGGERSUpdateWithoutQRTZ_CRON_TRIGGERSInput, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_CRON_TRIGGERSInput>
  }

  export type QRTZ_TRIGGERSUpdateWithoutQRTZ_CRON_TRIGGERSInput = {
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_JOB_DETAILS?: QRTZ_JOB_DETAILSUpdateOneRequiredWithoutQRTZ_TRIGGERSNestedInput
  }

  export type QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_CRON_TRIGGERSInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: StringFieldUpdateOperationsInput | string
    JOB_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
  }

  export type QRTZ_TRIGGERSCreateWithoutQRTZ_JOB_DETAILSInput = {
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
  }

  export type QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_JOB_DETAILSInput = {
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
  }

  export type QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_JOB_DETAILSInput = {
    where: QRTZ_TRIGGERSWhereUniqueInput
    create: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_JOB_DETAILSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_JOB_DETAILSInput>
  }

  export type QRTZ_TRIGGERSCreateManyQRTZ_JOB_DETAILSInputEnvelope = {
    data: QRTZ_TRIGGERSCreateManyQRTZ_JOB_DETAILSInput | QRTZ_TRIGGERSCreateManyQRTZ_JOB_DETAILSInput[]
    skipDuplicates?: boolean
  }

  export type QRTZ_TRIGGERSUpsertWithWhereUniqueWithoutQRTZ_JOB_DETAILSInput = {
    where: QRTZ_TRIGGERSWhereUniqueInput
    update: XOR<QRTZ_TRIGGERSUpdateWithoutQRTZ_JOB_DETAILSInput, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_JOB_DETAILSInput>
    create: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_JOB_DETAILSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_JOB_DETAILSInput>
  }

  export type QRTZ_TRIGGERSUpdateWithWhereUniqueWithoutQRTZ_JOB_DETAILSInput = {
    where: QRTZ_TRIGGERSWhereUniqueInput
    data: XOR<QRTZ_TRIGGERSUpdateWithoutQRTZ_JOB_DETAILSInput, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_JOB_DETAILSInput>
  }

  export type QRTZ_TRIGGERSUpdateManyWithWhereWithoutQRTZ_JOB_DETAILSInput = {
    where: QRTZ_TRIGGERSScalarWhereInput
    data: XOR<QRTZ_TRIGGERSUpdateManyMutationInput, QRTZ_TRIGGERSUncheckedUpdateManyWithoutQRTZ_JOB_DETAILSInput>
  }

  export type QRTZ_TRIGGERSScalarWhereInput = {
    AND?: QRTZ_TRIGGERSScalarWhereInput | QRTZ_TRIGGERSScalarWhereInput[]
    OR?: QRTZ_TRIGGERSScalarWhereInput[]
    NOT?: QRTZ_TRIGGERSScalarWhereInput | QRTZ_TRIGGERSScalarWhereInput[]
    SCHED_NAME?: StringFilter<"QRTZ_TRIGGERS"> | string
    TRIGGER_NAME?: StringFilter<"QRTZ_TRIGGERS"> | string
    TRIGGER_GROUP?: StringFilter<"QRTZ_TRIGGERS"> | string
    JOB_NAME?: StringFilter<"QRTZ_TRIGGERS"> | string
    JOB_GROUP?: StringFilter<"QRTZ_TRIGGERS"> | string
    DESCRIPTION?: StringNullableFilter<"QRTZ_TRIGGERS"> | string | null
    NEXT_FIRE_TIME?: BigIntNullableFilter<"QRTZ_TRIGGERS"> | bigint | number | null
    PREV_FIRE_TIME?: BigIntNullableFilter<"QRTZ_TRIGGERS"> | bigint | number | null
    PRIORITY?: IntNullableFilter<"QRTZ_TRIGGERS"> | number | null
    TRIGGER_STATE?: StringFilter<"QRTZ_TRIGGERS"> | string
    TRIGGER_TYPE?: StringFilter<"QRTZ_TRIGGERS"> | string
    START_TIME?: BigIntFilter<"QRTZ_TRIGGERS"> | bigint | number
    END_TIME?: BigIntNullableFilter<"QRTZ_TRIGGERS"> | bigint | number | null
    CALENDAR_NAME?: StringNullableFilter<"QRTZ_TRIGGERS"> | string | null
    MISFIRE_INSTR?: IntNullableFilter<"QRTZ_TRIGGERS"> | number | null
    JOB_DATA?: BytesNullableFilter<"QRTZ_TRIGGERS"> | Uint8Array | null
  }

  export type QRTZ_TRIGGERSCreateWithoutQRTZ_SIMPLE_TRIGGERSInput = {
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_JOB_DETAILS: QRTZ_JOB_DETAILSCreateNestedOneWithoutQRTZ_TRIGGERSInput
  }

  export type QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_SIMPLE_TRIGGERSInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
  }

  export type QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_SIMPLE_TRIGGERSInput = {
    where: QRTZ_TRIGGERSWhereUniqueInput
    create: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_SIMPLE_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_SIMPLE_TRIGGERSInput>
  }

  export type QRTZ_TRIGGERSUpsertWithoutQRTZ_SIMPLE_TRIGGERSInput = {
    update: XOR<QRTZ_TRIGGERSUpdateWithoutQRTZ_SIMPLE_TRIGGERSInput, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_SIMPLE_TRIGGERSInput>
    create: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_SIMPLE_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_SIMPLE_TRIGGERSInput>
    where?: QRTZ_TRIGGERSWhereInput
  }

  export type QRTZ_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_SIMPLE_TRIGGERSInput = {
    where?: QRTZ_TRIGGERSWhereInput
    data: XOR<QRTZ_TRIGGERSUpdateWithoutQRTZ_SIMPLE_TRIGGERSInput, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_SIMPLE_TRIGGERSInput>
  }

  export type QRTZ_TRIGGERSUpdateWithoutQRTZ_SIMPLE_TRIGGERSInput = {
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_JOB_DETAILS?: QRTZ_JOB_DETAILSUpdateOneRequiredWithoutQRTZ_TRIGGERSNestedInput
  }

  export type QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_SIMPLE_TRIGGERSInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: StringFieldUpdateOperationsInput | string
    JOB_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
  }

  export type QRTZ_TRIGGERSCreateWithoutQRTZ_SIMPROP_TRIGGERSInput = {
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_JOB_DETAILS: QRTZ_JOB_DETAILSCreateNestedOneWithoutQRTZ_TRIGGERSInput
  }

  export type QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_SIMPROP_TRIGGERSInput = {
    SCHED_NAME: string
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUncheckedCreateNestedOneWithoutQRTZ_TRIGGERSInput
  }

  export type QRTZ_TRIGGERSCreateOrConnectWithoutQRTZ_SIMPROP_TRIGGERSInput = {
    where: QRTZ_TRIGGERSWhereUniqueInput
    create: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_SIMPROP_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_SIMPROP_TRIGGERSInput>
  }

  export type QRTZ_TRIGGERSUpsertWithoutQRTZ_SIMPROP_TRIGGERSInput = {
    update: XOR<QRTZ_TRIGGERSUpdateWithoutQRTZ_SIMPROP_TRIGGERSInput, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_SIMPROP_TRIGGERSInput>
    create: XOR<QRTZ_TRIGGERSCreateWithoutQRTZ_SIMPROP_TRIGGERSInput, QRTZ_TRIGGERSUncheckedCreateWithoutQRTZ_SIMPROP_TRIGGERSInput>
    where?: QRTZ_TRIGGERSWhereInput
  }

  export type QRTZ_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_SIMPROP_TRIGGERSInput = {
    where?: QRTZ_TRIGGERSWhereInput
    data: XOR<QRTZ_TRIGGERSUpdateWithoutQRTZ_SIMPROP_TRIGGERSInput, QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_SIMPROP_TRIGGERSInput>
  }

  export type QRTZ_TRIGGERSUpdateWithoutQRTZ_SIMPROP_TRIGGERSInput = {
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_JOB_DETAILS?: QRTZ_JOB_DETAILSUpdateOneRequiredWithoutQRTZ_TRIGGERSNestedInput
  }

  export type QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_SIMPROP_TRIGGERSInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: StringFieldUpdateOperationsInput | string
    JOB_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
  }

  export type QRTZ_BLOB_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput = {
    BLOB_DATA?: Uint8Array | null
  }

  export type QRTZ_BLOB_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput = {
    BLOB_DATA?: Uint8Array | null
  }

  export type QRTZ_BLOB_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput = {
    where: QRTZ_BLOB_TRIGGERSWhereUniqueInput
    create: XOR<QRTZ_BLOB_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_BLOB_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_CRON_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput = {
    CRON_EXPRESSION: string
    TIME_ZONE_ID?: string | null
  }

  export type QRTZ_CRON_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput = {
    CRON_EXPRESSION: string
    TIME_ZONE_ID?: string | null
  }

  export type QRTZ_CRON_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput = {
    where: QRTZ_CRON_TRIGGERSWhereUniqueInput
    create: XOR<QRTZ_CRON_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_CRON_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_SIMPLE_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput = {
    REPEAT_COUNT: bigint | number
    REPEAT_INTERVAL: bigint | number
    TIMES_TRIGGERED: bigint | number
  }

  export type QRTZ_SIMPLE_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput = {
    REPEAT_COUNT: bigint | number
    REPEAT_INTERVAL: bigint | number
    TIMES_TRIGGERED: bigint | number
  }

  export type QRTZ_SIMPLE_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput = {
    where: QRTZ_SIMPLE_TRIGGERSWhereUniqueInput
    create: XOR<QRTZ_SIMPLE_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPLE_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_SIMPROP_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput = {
    STR_PROP_1?: string | null
    STR_PROP_2?: string | null
    STR_PROP_3?: string | null
    INT_PROP_1?: number | null
    INT_PROP_2?: number | null
    LONG_PROP_1?: bigint | number | null
    LONG_PROP_2?: bigint | number | null
    DEC_PROP_1?: Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: string | null
    BOOL_PROP_2?: string | null
  }

  export type QRTZ_SIMPROP_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput = {
    STR_PROP_1?: string | null
    STR_PROP_2?: string | null
    STR_PROP_3?: string | null
    INT_PROP_1?: number | null
    INT_PROP_2?: number | null
    LONG_PROP_1?: bigint | number | null
    LONG_PROP_2?: bigint | number | null
    DEC_PROP_1?: Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: string | null
    BOOL_PROP_2?: string | null
  }

  export type QRTZ_SIMPROP_TRIGGERSCreateOrConnectWithoutQRTZ_TRIGGERSInput = {
    where: QRTZ_SIMPROP_TRIGGERSWhereUniqueInput
    create: XOR<QRTZ_SIMPROP_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPROP_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_JOB_DETAILSCreateWithoutQRTZ_TRIGGERSInput = {
    SCHED_NAME: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION?: string | null
    JOB_CLASS_NAME: string
    IS_DURABLE: string
    IS_NONCONCURRENT: string
    IS_UPDATE_DATA: string
    REQUESTS_RECOVERY: string
    JOB_DATA?: Uint8Array | null
  }

  export type QRTZ_JOB_DETAILSUncheckedCreateWithoutQRTZ_TRIGGERSInput = {
    SCHED_NAME: string
    JOB_NAME: string
    JOB_GROUP: string
    DESCRIPTION?: string | null
    JOB_CLASS_NAME: string
    IS_DURABLE: string
    IS_NONCONCURRENT: string
    IS_UPDATE_DATA: string
    REQUESTS_RECOVERY: string
    JOB_DATA?: Uint8Array | null
  }

  export type QRTZ_JOB_DETAILSCreateOrConnectWithoutQRTZ_TRIGGERSInput = {
    where: QRTZ_JOB_DETAILSWhereUniqueInput
    create: XOR<QRTZ_JOB_DETAILSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_JOB_DETAILSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_BLOB_TRIGGERSUpsertWithoutQRTZ_TRIGGERSInput = {
    update: XOR<QRTZ_BLOB_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput, QRTZ_BLOB_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
    create: XOR<QRTZ_BLOB_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_BLOB_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    where?: QRTZ_BLOB_TRIGGERSWhereInput
  }

  export type QRTZ_BLOB_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput = {
    where?: QRTZ_BLOB_TRIGGERSWhereInput
    data: XOR<QRTZ_BLOB_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput, QRTZ_BLOB_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_BLOB_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput = {
    BLOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type QRTZ_BLOB_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput = {
    BLOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type QRTZ_CRON_TRIGGERSUpsertWithoutQRTZ_TRIGGERSInput = {
    update: XOR<QRTZ_CRON_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput, QRTZ_CRON_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
    create: XOR<QRTZ_CRON_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_CRON_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    where?: QRTZ_CRON_TRIGGERSWhereInput
  }

  export type QRTZ_CRON_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput = {
    where?: QRTZ_CRON_TRIGGERSWhereInput
    data: XOR<QRTZ_CRON_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput, QRTZ_CRON_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_CRON_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput = {
    CRON_EXPRESSION?: StringFieldUpdateOperationsInput | string
    TIME_ZONE_ID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_CRON_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput = {
    CRON_EXPRESSION?: StringFieldUpdateOperationsInput | string
    TIME_ZONE_ID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_SIMPLE_TRIGGERSUpsertWithoutQRTZ_TRIGGERSInput = {
    update: XOR<QRTZ_SIMPLE_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPLE_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
    create: XOR<QRTZ_SIMPLE_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPLE_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    where?: QRTZ_SIMPLE_TRIGGERSWhereInput
  }

  export type QRTZ_SIMPLE_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput = {
    where?: QRTZ_SIMPLE_TRIGGERSWhereInput
    data: XOR<QRTZ_SIMPLE_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPLE_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_SIMPLE_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput = {
    REPEAT_COUNT?: BigIntFieldUpdateOperationsInput | bigint | number
    REPEAT_INTERVAL?: BigIntFieldUpdateOperationsInput | bigint | number
    TIMES_TRIGGERED?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type QRTZ_SIMPLE_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput = {
    REPEAT_COUNT?: BigIntFieldUpdateOperationsInput | bigint | number
    REPEAT_INTERVAL?: BigIntFieldUpdateOperationsInput | bigint | number
    TIMES_TRIGGERED?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type QRTZ_SIMPROP_TRIGGERSUpsertWithoutQRTZ_TRIGGERSInput = {
    update: XOR<QRTZ_SIMPROP_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPROP_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
    create: XOR<QRTZ_SIMPROP_TRIGGERSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPROP_TRIGGERSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    where?: QRTZ_SIMPROP_TRIGGERSWhereInput
  }

  export type QRTZ_SIMPROP_TRIGGERSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput = {
    where?: QRTZ_SIMPROP_TRIGGERSWhereInput
    data: XOR<QRTZ_SIMPROP_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput, QRTZ_SIMPROP_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_SIMPROP_TRIGGERSUpdateWithoutQRTZ_TRIGGERSInput = {
    STR_PROP_1?: NullableStringFieldUpdateOperationsInput | string | null
    STR_PROP_2?: NullableStringFieldUpdateOperationsInput | string | null
    STR_PROP_3?: NullableStringFieldUpdateOperationsInput | string | null
    INT_PROP_1?: NullableIntFieldUpdateOperationsInput | number | null
    INT_PROP_2?: NullableIntFieldUpdateOperationsInput | number | null
    LONG_PROP_1?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    LONG_PROP_2?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    DEC_PROP_1?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: NullableStringFieldUpdateOperationsInput | string | null
    BOOL_PROP_2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_SIMPROP_TRIGGERSUncheckedUpdateWithoutQRTZ_TRIGGERSInput = {
    STR_PROP_1?: NullableStringFieldUpdateOperationsInput | string | null
    STR_PROP_2?: NullableStringFieldUpdateOperationsInput | string | null
    STR_PROP_3?: NullableStringFieldUpdateOperationsInput | string | null
    INT_PROP_1?: NullableIntFieldUpdateOperationsInput | number | null
    INT_PROP_2?: NullableIntFieldUpdateOperationsInput | number | null
    LONG_PROP_1?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    LONG_PROP_2?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    DEC_PROP_1?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    DEC_PROP_2?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    BOOL_PROP_1?: NullableStringFieldUpdateOperationsInput | string | null
    BOOL_PROP_2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QRTZ_JOB_DETAILSUpsertWithoutQRTZ_TRIGGERSInput = {
    update: XOR<QRTZ_JOB_DETAILSUpdateWithoutQRTZ_TRIGGERSInput, QRTZ_JOB_DETAILSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
    create: XOR<QRTZ_JOB_DETAILSCreateWithoutQRTZ_TRIGGERSInput, QRTZ_JOB_DETAILSUncheckedCreateWithoutQRTZ_TRIGGERSInput>
    where?: QRTZ_JOB_DETAILSWhereInput
  }

  export type QRTZ_JOB_DETAILSUpdateToOneWithWhereWithoutQRTZ_TRIGGERSInput = {
    where?: QRTZ_JOB_DETAILSWhereInput
    data: XOR<QRTZ_JOB_DETAILSUpdateWithoutQRTZ_TRIGGERSInput, QRTZ_JOB_DETAILSUncheckedUpdateWithoutQRTZ_TRIGGERSInput>
  }

  export type QRTZ_JOB_DETAILSUpdateWithoutQRTZ_TRIGGERSInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: StringFieldUpdateOperationsInput | string
    JOB_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    JOB_CLASS_NAME?: StringFieldUpdateOperationsInput | string
    IS_DURABLE?: StringFieldUpdateOperationsInput | string
    IS_NONCONCURRENT?: StringFieldUpdateOperationsInput | string
    IS_UPDATE_DATA?: StringFieldUpdateOperationsInput | string
    REQUESTS_RECOVERY?: StringFieldUpdateOperationsInput | string
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type QRTZ_JOB_DETAILSUncheckedUpdateWithoutQRTZ_TRIGGERSInput = {
    SCHED_NAME?: StringFieldUpdateOperationsInput | string
    JOB_NAME?: StringFieldUpdateOperationsInput | string
    JOB_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    JOB_CLASS_NAME?: StringFieldUpdateOperationsInput | string
    IS_DURABLE?: StringFieldUpdateOperationsInput | string
    IS_NONCONCURRENT?: StringFieldUpdateOperationsInput | string
    IS_UPDATE_DATA?: StringFieldUpdateOperationsInput | string
    REQUESTS_RECOVERY?: StringFieldUpdateOperationsInput | string
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type QRTZ_TRIGGERSCreateManyQRTZ_JOB_DETAILSInput = {
    TRIGGER_NAME: string
    TRIGGER_GROUP: string
    DESCRIPTION?: string | null
    NEXT_FIRE_TIME?: bigint | number | null
    PREV_FIRE_TIME?: bigint | number | null
    PRIORITY?: number | null
    TRIGGER_STATE: string
    TRIGGER_TYPE: string
    START_TIME: bigint | number
    END_TIME?: bigint | number | null
    CALENDAR_NAME?: string | null
    MISFIRE_INSTR?: number | null
    JOB_DATA?: Uint8Array | null
  }

  export type QRTZ_TRIGGERSUpdateWithoutQRTZ_JOB_DETAILSInput = {
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUpdateOneWithoutQRTZ_TRIGGERSNestedInput
  }

  export type QRTZ_TRIGGERSUncheckedUpdateWithoutQRTZ_JOB_DETAILSInput = {
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    QRTZ_BLOB_TRIGGERS?: QRTZ_BLOB_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_CRON_TRIGGERS?: QRTZ_CRON_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPLE_TRIGGERS?: QRTZ_SIMPLE_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
    QRTZ_SIMPROP_TRIGGERS?: QRTZ_SIMPROP_TRIGGERSUncheckedUpdateOneWithoutQRTZ_TRIGGERSNestedInput
  }

  export type QRTZ_TRIGGERSUncheckedUpdateManyWithoutQRTZ_JOB_DETAILSInput = {
    TRIGGER_NAME?: StringFieldUpdateOperationsInput | string
    TRIGGER_GROUP?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    NEXT_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PREV_FIRE_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PRIORITY?: NullableIntFieldUpdateOperationsInput | number | null
    TRIGGER_STATE?: StringFieldUpdateOperationsInput | string
    TRIGGER_TYPE?: StringFieldUpdateOperationsInput | string
    START_TIME?: BigIntFieldUpdateOperationsInput | bigint | number
    END_TIME?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    CALENDAR_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    MISFIRE_INSTR?: NullableIntFieldUpdateOperationsInput | number | null
    JOB_DATA?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}